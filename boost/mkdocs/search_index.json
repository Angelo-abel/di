{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Introduction\n\n\n\n\n\n\n\n\n[Boost].DI\n\n\n\n\n\n\n\n\n\n\n\n\nYour C++14 header only Dependency Injection library with no dependencies (\nTry it online!\n)\n\n\nGitHub\n\n\n\n\n\n\n\n\n\n\n Latest Release: \nv1.1.0\n (Jan 7, 2019)\n\n\n \nDownload\n \n \n \nChangelog\n \n \n \nTutorial\n \n \n \nExamples\n\n\n\n\n\nWhat is Dependency Injection?\n\n\n\n\n\"Don't call us, we'll call you\", Hollywood principle\n\n\n\n\nDependency Injection\n (DI)\n involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the client\u2019s state.\nIt is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test.\n\n\n\nIn short, DI is all about construction!\n\n\n\n\n\"Let's make some coffee!\"\n\n\n\n\n\n\n\n\n                      No Dependency injection                 | Dependency Injection\n                      ----------------------------------------|-------------------------------------------\n                      class coffee_maker {                    | class coffee_maker {\n                      public:                                 | public:\n                          void brew() {                       |   coffee_maker(const shared_ptr\niheater\n heater\n                              heater-\non();                   |              , unique_ptr\nipump\n pump)\n                              pump-\npump();                   |         : heater(heater), pump(move(pump))\n                              clog \n \ncoffee\n! \n endl;      |     { }\n                              heater-\noff();                  |\n                          }                                   |     void brew() {\n                                                              |         heater-\non();\n                      private:                                |         pump-\npump();\n                          shared_ptr\niheater\n heater =        |         clog \n \ncoffee!\n \n endl;\n                              make_shared\nelectric_heater\n(); |         heater-\noff();\n                                                              |     }\n                          unique_ptr\nipump\n pump =            |\n                              make_unique\nheat_pump\n(heater); | private:\n                      };                                      |     shared_ptr\niheater\n heater;\n                                                              |     unique_ptr\nipump\n pump;\n                                                              | };\n\n\n\n\nDo I use a Dependency Injection already?\n\n\n\n\nIf you are using constructors in your code then you are probably using some form of Dependency Injection too!\n\n\n\n\nclass Button {\n public:\n  Button(const std::string\n name, Position position); // Dependency Injection!\n};\n\n\n\n\nDo I use Dependency Injection correctly?\n\n\nCommon mistakes when using Dependency Injection are:\n\n\n\n\n\n\nPassing a dependency to create another dependency inside your object\n\n\nIt's a bad practice to pass dependencies to an object just in order\nto create another one with those dependencies.\nIt's much cleaner to create the latter object beforehand and pass it to the former.\n\n\n\n\n\n\nclass Model {\n public:\n   Model(int width, int height)\n     : board(std::make_unique\nBoard\n(width, height)) // Bad\n   { }\n\n   explicit Model(std::unique_ptr\nIBoard\n board) // Better\n     : board(std::move(board))\n   { }\n\n   ...\n\n private:\n  std::unique_ptr\nIBoard\n board;\n};\n\n\n\n\n\n\n\n\nCarrying dependencies\n\n\nIt's also important NOT to pass depenencies through layers of constructors (carrying them).\nIt's much better to always pass only dependecies which are required ONLY by the given constructor.\n\n\n\n\n\n\nclass Model : public Service { // Bad\n public:\n   explicit Model(std::unique_ptr\nIBoard\n board) // Bad\n     : Service(std::move(board))\n   { }\n\n   void update() {\n     Service::do_something_with_board(); // Bad\n   }\n};\n\nclass Model { // Better\n public:\n   explicit Model(std::unique_ptr\nService\n service) // Better\n     : service(std::move(service))\n   { }\n\n   void update() {\n     service-\ndo_something_with_board(); // Better\n   }\n\n private:\n   std::unique_ptr\nService\n service;\n};\n\n\n\n\n\n\n\n\nCarrying injector (Service Locator pattern)\n\n\nService locator is consider to be an anti-pattern because its instance\nis required to be passed as the ONLY constructor parameter into all\nconstructors. Such approach makes the code highly coupled to the Service Locator framework.\nIt's better to pass required dependencies direclty instead and use a DI framework to inject them.\n\n\n\n\n\n\nclass Model {\n public:\n   explicit Model(service_locator\n sl) // Bad (ask)\n     : service(sl.resolve\nunique_ptr\nService\n())\n   { }\n\n   explicit Model(std::unique_ptr\nService\n service) // Better (tell)\n     : service(std::move(service))\n   { }\n\n   ...\n\n private:\n   std::unique_ptr\nService\n service;\n};\n\n\n\n\n\n\n\n\nNot using strong typedefs for constructor parameters\n\n\nBeing explicit and declarative is always better than being impilicit.\nUsing common types (ex. numbers) in order to define any common-like type may cause\nmissusage of the constructor interface. Using \nstrong typedefs\n is easier to follow and\nprotects against missusage of the constructor interface.\n\n\n\n\n\n\nclass Board {\n public:\n   Board(int /*width*/, int /*height*/)  // Bad; Board{2, 3} vs Board{3, 2}?\n\n   Board(width, height) // Better, explicit; Board{width{2}, height{3}};\n\n   ...\n};\n\n\n\n\nDo I need a Dependency Injection?\n\n\n\n\nDI provides loosely coupled code (separation of business logic and object creation)\n\n\nDI provides easier to maintain code (different objects might be easily injected)\n\n\nDI provides easier to test code (fakes objects might be injected)\n\n\n\n\nSTUPID vs SOLID - \"Clean Code\" Uncle Bob\n\n\n\n  \nS\nSingleton\n\n  \nT\nTight Coupling\n\n  \nU\nUntestability\n\n  \nP\nPremature Optimization\n\n  \nI\nIndescriptive Naming\n\n  \nD\nDuplication\n\n\n\n\n\n\n\nvs\n\n\n\n\n\n  \nS\nSingle Responsibility\n\n  \nO\nOpen-close\n\n  \nL\nLiskov substitution\n\n  \nI\nInterface segregation\n\n  \nD\nDependency inversion\n\n\n\n\n\nDo I need a DI Framework/Library?\n\n\nDepending on a project and its scale you may put up with or without a DI library, however, in any project\na DI framework may \nfree you\n from maintaining a following (boilerplate) code...\n\n\nlogger logger_;\nrenderer renderer_;\nview view_{renderer_, logger_};\nmodel model_{logger_};\ncontroller controller_{model_, view_, logger_};\nuser user_{logger_};\napp app_{controller_, user_};\n\n\n\n\nNotice that \nORDER\n in which above dependencies are created is \nIMPORTANT\n as well as that\n\nANY\n change in \nANY\n of the objects constructor will \nREQUIRE\n a change in this code!\n\n\nManual DI - Wiring Mess (Avoid it by using [Boost].DI)\n\n\n* Single Responsibility Principle\n  =\n\n    * A lot of classes\n    =\n\n      * Wiring Mess\n      =\n\n        * Hard to maintain + Lazy programmers (99%)\n        =\n\n          * Hacks/Workarounds (~~Single Responsibility~~)\n\n\n\n\n\n\n Motivation Example\n\n\n\n\n\n\nRight now, imagine a project with hundreds or thousands of those dependencies and a critical issue\nwhich has to be fixed ASAP. Unfortunately, in order to fix the bug properly a new non-trivial dependency has to be\nintroduced.\n\n\nNow, imagine that a 'smart' dev figured out that it will be much easier to extend the functionally\nof already passed object and sneak a workaround/'solution' this way. Such approach will possibly break the \nsingle responsibility principle\n\nof the changed object but no worries though, it might be refactored later on (meaning: most likely, the workaround will stay unchanged forever and that there are no tests).\n\n\nIf that sounds familiar\n, take a look into DI library as it helps to solve developer dilemma by taking care\nof creating all required dependencies whereas dev may focus on fixing and testing the issue.\n\n\n\n\nDI library\n, not only let you forget about maintaining dependencies creation (See \nCreate Objects Tree\n),\nbut also can help you with...\n\n\n\n\nTesting (See \nMocks Provider\n)\n\n\nSerializing (See \nSerialize\n)\n\n\nUnderstand code dependencies (See \nUML Dumper\n)\n\n\nRestrict what types and how they should be created (See \nConstructible Policy\n)\n\n\n\n\nReal Life examples?\n\n\n\n\nMatch-3 Game\n\n\nSimple web game in C++14 using SDL2 / Model View Controller / Meta State Machine / Dependency Injection / Range-V3 / Emscripten\n\n\nPlay it online!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAutomatic Mocks Injector\n\n\nAutomatically create and inject required mocks to tested classes via constructors\n\n\n\n\n\n\n\n\n\n\n\n\nExperimental Boost.SML\n\n\nC++14 header only Meta State Machine library with no dependencies\n\n\n\n\n\n\n\n\nWhy [Boost].DI?\n\n\n\n\n[Boost].DI has none run-time overhead (See \nPerformance\n)\n\n\n[Boost].DI compiles fast / \nFaster than Java-\nDagger2\n!\n (See \nBenchmarks\n)\n\n\n[Boost].DI gives short diagnostic messages (See \nError messages\n)\n\n\n[Boost].DI is non-intrusive (See \nInjections\n)\n\n\n[Boost].DI reduces boilerplate code (See \nCreate Objects Tree\n)\n\n\n[Boost].DI reduces testing effort (See \nMocks Provider\n)\n\n\n[Boost].DI gives better control of what and how is created (See \nConstructible Policy\n)\n\n\n[Boost].DI gives better understanding about objects hierarchy (See \nUML Dumper\n)\n\n\n\n\n\n\nTry it online!\n\n\n\n\n\n\n UML Dumper Extension\n\n\n XML Injection Extension\n\n\n Constructible Example\n\n\n\n\n\n\n[Boost].DI design goals\n\n\n\n\nBe as fast as possible (See \nPerformance\n)\n\n\nCompile as fast as possible (See \nBenchmarks\n)\n\n\nGive short and intuitive error messages (See \nError messages\n)\n\n\nGuarantee object creation at compile-time (See \nCreate Objects Tree\n)\n\n\nBe as non-intrusive as possible (See \nInjections\n)\n\n\nBe easy to extend (See \nExtensions\n)\n\n\n\n\nArticles\n\n\n\n\nInversion of Control Containers and the Dependency Injection pattern\n\n\nDIP in the Wild\n\n\nConcepts driven design with Dependency Injection\n\n\n\n\nVideos\n\n\n[Boost].DI\n\n\n\n\nCppCon 2018: [Boost].DI - Inject all the things!\n | \nSlides\n\n\nC++Now 2016: C++14 Dependency Injection Library\n | \nSlides\n\n\nMeeting C++ 2016: TDD/BDD and Dependency Injection\n | \nSlides\n\n\nBoost your design with C++14 dependency injection\n | \nSlides\n\n\n\n\nDependency Injection In General\n\n\n\n\nDependency Injection\n\n\nThe Clean Code Talks - Don't Look For Things!\n\n\nA New Type of dependency injection\n\n\nThe Future of Dependency Injection with Dagger 2\n\n\nDesign Patterns in C++: Creational\n\n\n\n\nAcknowledgements\n\n\n\n\nThanks to \nBartosz Kalinczuk\n for code review and tips how to improve \n[Boost].DI\n\n\nThanks to \nKanstantsin Chernik\n for all his contributions to \n[Boost].DI\n\n\nThanks to \nOlof Edlund\n for very useful feedback and for all the improvements to the documentation\n\n\nThanks to \nRob Stewart\n and \nRobert Ramey\n for documentation feedback and tips how to improve it\n\n\nThanks to \nSohail Somani\n for support and tips how to improve \n[Boost].DI", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#introduction", 
            "text": "[Boost].DI       Your C++14 header only Dependency Injection library with no dependencies ( Try it online! )  GitHub", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#what-is-dependency-injection", 
            "text": "\"Don't call us, we'll call you\", Hollywood principle   Dependency Injection  (DI)  involves passing (injecting) one or more dependencies (or services) to a dependent object (or client) which become part of the client\u2019s state.\nIt is like the Strategy Pattern, except the strategy is set once, at construction. DI enables loosely coupled designs, which are easier to maintain and test.  \nIn short, DI is all about construction!   \"Let's make some coffee!\"                           No Dependency injection                 | Dependency Injection\n                      ----------------------------------------|-------------------------------------------\n                      class coffee_maker {                    | class coffee_maker {\n                      public:                                 | public:\n                          void brew() {                       |   coffee_maker(const shared_ptr iheater  heater\n                              heater- on();                   |              , unique_ptr ipump  pump)\n                              pump- pump();                   |         : heater(heater), pump(move(pump))\n                              clog    coffee !   endl;      |     { }\n                              heater- off();                  |\n                          }                                   |     void brew() {\n                                                              |         heater- on();\n                      private:                                |         pump- pump();\n                          shared_ptr iheater  heater =        |         clog    coffee!    endl;\n                              make_shared electric_heater (); |         heater- off();\n                                                              |     }\n                          unique_ptr ipump  pump =            |\n                              make_unique heat_pump (heater); | private:\n                      };                                      |     shared_ptr iheater  heater;\n                                                              |     unique_ptr ipump  pump;\n                                                              | };", 
            "title": "What is Dependency Injection?"
        }, 
        {
            "location": "/index.html#do-i-use-a-dependency-injection-already", 
            "text": "If you are using constructors in your code then you are probably using some form of Dependency Injection too!   class Button {\n public:\n  Button(const std::string  name, Position position); // Dependency Injection!\n};", 
            "title": "Do I use a Dependency Injection already?"
        }, 
        {
            "location": "/index.html#do-i-use-dependency-injection-correctly", 
            "text": "Common mistakes when using Dependency Injection are:    Passing a dependency to create another dependency inside your object  It's a bad practice to pass dependencies to an object just in order\nto create another one with those dependencies.\nIt's much cleaner to create the latter object beforehand and pass it to the former.    class Model {\n public:\n   Model(int width, int height)\n     : board(std::make_unique Board (width, height)) // Bad\n   { }\n\n   explicit Model(std::unique_ptr IBoard  board) // Better\n     : board(std::move(board))\n   { }\n\n   ...\n\n private:\n  std::unique_ptr IBoard  board;\n};    Carrying dependencies  It's also important NOT to pass depenencies through layers of constructors (carrying them).\nIt's much better to always pass only dependecies which are required ONLY by the given constructor.    class Model : public Service { // Bad\n public:\n   explicit Model(std::unique_ptr IBoard  board) // Bad\n     : Service(std::move(board))\n   { }\n\n   void update() {\n     Service::do_something_with_board(); // Bad\n   }\n};\n\nclass Model { // Better\n public:\n   explicit Model(std::unique_ptr Service  service) // Better\n     : service(std::move(service))\n   { }\n\n   void update() {\n     service- do_something_with_board(); // Better\n   }\n\n private:\n   std::unique_ptr Service  service;\n};    Carrying injector (Service Locator pattern)  Service locator is consider to be an anti-pattern because its instance\nis required to be passed as the ONLY constructor parameter into all\nconstructors. Such approach makes the code highly coupled to the Service Locator framework.\nIt's better to pass required dependencies direclty instead and use a DI framework to inject them.    class Model {\n public:\n   explicit Model(service_locator  sl) // Bad (ask)\n     : service(sl.resolve unique_ptr Service ())\n   { }\n\n   explicit Model(std::unique_ptr Service  service) // Better (tell)\n     : service(std::move(service))\n   { }\n\n   ...\n\n private:\n   std::unique_ptr Service  service;\n};    Not using strong typedefs for constructor parameters  Being explicit and declarative is always better than being impilicit.\nUsing common types (ex. numbers) in order to define any common-like type may cause\nmissusage of the constructor interface. Using  strong typedefs  is easier to follow and\nprotects against missusage of the constructor interface.    class Board {\n public:\n   Board(int /*width*/, int /*height*/)  // Bad; Board{2, 3} vs Board{3, 2}?\n\n   Board(width, height) // Better, explicit; Board{width{2}, height{3}};\n\n   ...\n};", 
            "title": "Do I use Dependency Injection correctly?"
        }, 
        {
            "location": "/index.html#do-i-need-a-dependency-injection", 
            "text": "DI provides loosely coupled code (separation of business logic and object creation)  DI provides easier to maintain code (different objects might be easily injected)  DI provides easier to test code (fakes objects might be injected)", 
            "title": "Do I need a Dependency Injection?"
        }, 
        {
            "location": "/index.html#stupid-vs-solid-clean-code-uncle-bob", 
            "text": "S Singleton \n   T Tight Coupling \n   U Untestability \n   P Premature Optimization \n   I Indescriptive Naming \n   D Duplication    vs   \n   S Single Responsibility \n   O Open-close \n   L Liskov substitution \n   I Interface segregation \n   D Dependency inversion", 
            "title": "STUPID vs SOLID - \"Clean Code\" Uncle Bob"
        }, 
        {
            "location": "/index.html#do-i-need-a-di-frameworklibrary", 
            "text": "Depending on a project and its scale you may put up with or without a DI library, however, in any project\na DI framework may  free you  from maintaining a following (boilerplate) code...  logger logger_;\nrenderer renderer_;\nview view_{renderer_, logger_};\nmodel model_{logger_};\ncontroller controller_{model_, view_, logger_};\nuser user_{logger_};\napp app_{controller_, user_};  Notice that  ORDER  in which above dependencies are created is  IMPORTANT  as well as that ANY  change in  ANY  of the objects constructor will  REQUIRE  a change in this code!", 
            "title": "Do I need a DI Framework/Library?"
        }, 
        {
            "location": "/index.html#manual-di-wiring-mess-avoid-it-by-using-boostdi", 
            "text": "* Single Responsibility Principle\n  = \n    * A lot of classes\n    = \n      * Wiring Mess\n      = \n        * Hard to maintain + Lazy programmers (99%)\n        = \n          * Hacks/Workarounds (~~Single Responsibility~~)    Motivation Example    Right now, imagine a project with hundreds or thousands of those dependencies and a critical issue\nwhich has to be fixed ASAP. Unfortunately, in order to fix the bug properly a new non-trivial dependency has to be\nintroduced.  Now, imagine that a 'smart' dev figured out that it will be much easier to extend the functionally\nof already passed object and sneak a workaround/'solution' this way. Such approach will possibly break the  single responsibility principle \nof the changed object but no worries though, it might be refactored later on (meaning: most likely, the workaround will stay unchanged forever and that there are no tests).  If that sounds familiar , take a look into DI library as it helps to solve developer dilemma by taking care\nof creating all required dependencies whereas dev may focus on fixing and testing the issue.   DI library , not only let you forget about maintaining dependencies creation (See  Create Objects Tree ),\nbut also can help you with...   Testing (See  Mocks Provider )  Serializing (See  Serialize )  Understand code dependencies (See  UML Dumper )  Restrict what types and how they should be created (See  Constructible Policy )", 
            "title": "Manual DI - Wiring Mess (Avoid it by using [Boost].DI)"
        }, 
        {
            "location": "/index.html#real-life-examples", 
            "text": "Match-3 Game  Simple web game in C++14 using SDL2 / Model View Controller / Meta State Machine / Dependency Injection / Range-V3 / Emscripten  Play it online!         Automatic Mocks Injector  Automatically create and inject required mocks to tested classes via constructors       Experimental Boost.SML  C++14 header only Meta State Machine library with no dependencies", 
            "title": "Real Life examples?"
        }, 
        {
            "location": "/index.html#why-boostdi", 
            "text": "[Boost].DI has none run-time overhead (See  Performance )  [Boost].DI compiles fast /  Faster than Java- Dagger2 !  (See  Benchmarks )  [Boost].DI gives short diagnostic messages (See  Error messages )  [Boost].DI is non-intrusive (See  Injections )  [Boost].DI reduces boilerplate code (See  Create Objects Tree )  [Boost].DI reduces testing effort (See  Mocks Provider )  [Boost].DI gives better control of what and how is created (See  Constructible Policy )  [Boost].DI gives better understanding about objects hierarchy (See  UML Dumper )    Try it online!     UML Dumper Extension   XML Injection Extension   Constructible Example", 
            "title": "Why [Boost].DI?"
        }, 
        {
            "location": "/index.html#boostdi-design-goals", 
            "text": "Be as fast as possible (See  Performance )  Compile as fast as possible (See  Benchmarks )  Give short and intuitive error messages (See  Error messages )  Guarantee object creation at compile-time (See  Create Objects Tree )  Be as non-intrusive as possible (See  Injections )  Be easy to extend (See  Extensions )", 
            "title": "[Boost].DI design goals"
        }, 
        {
            "location": "/index.html#articles", 
            "text": "Inversion of Control Containers and the Dependency Injection pattern  DIP in the Wild  Concepts driven design with Dependency Injection", 
            "title": "Articles"
        }, 
        {
            "location": "/index.html#videos", 
            "text": "", 
            "title": "Videos"
        }, 
        {
            "location": "/index.html#boostdi", 
            "text": "CppCon 2018: [Boost].DI - Inject all the things!  |  Slides  C++Now 2016: C++14 Dependency Injection Library  |  Slides  Meeting C++ 2016: TDD/BDD and Dependency Injection  |  Slides  Boost your design with C++14 dependency injection  |  Slides", 
            "title": "[Boost].DI"
        }, 
        {
            "location": "/index.html#dependency-injection-in-general", 
            "text": "Dependency Injection  The Clean Code Talks - Don't Look For Things!  A New Type of dependency injection  The Future of Dependency Injection with Dagger 2  Design Patterns in C++: Creational", 
            "title": "Dependency Injection In General"
        }, 
        {
            "location": "/index.html#acknowledgements", 
            "text": "Thanks to  Bartosz Kalinczuk  for code review and tips how to improve  [Boost].DI  Thanks to  Kanstantsin Chernik  for all his contributions to  [Boost].DI  Thanks to  Olof Edlund  for very useful feedback and for all the improvements to the documentation  Thanks to  Rob Stewart  and  Robert Ramey  for documentation feedback and tips how to improve it  Thanks to  Sohail Somani  for support and tips how to improve  [Boost].DI", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/overview/index.html", 
            "text": "Quick Start\n\n\n\n\nGet \nboost/di.hpp\n header\n\n\n\n\nwget https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp\n\n\n\n\n\n\nInclude the header and define \ndi\n namespace alias\n\n\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n\n\n\n\n\n\nCompile with C++14 support\n\n\n\n\n$CXX -std=c++14 ...\n\n\n\n\n \nNote\n\n[Boost].DI compiles with -fno-exceptions -fno-rtti -Wall -Wextra -Werror -pedantic -pedantic-errors\n\n\n\n\n\nTo run tests\n\n\n\n\ngit clone https://github.com/boost-experimental/di \n cd di \n make\n\n\n\n\nDependencies\n\n\n\n\nNo external dependencies are required (neither STL nor Boost)\n\n\n\n\nSupported/Tested compilers\n\n\n\n\nClang-3.4+\n\n\nGCC-5.2+\n\n\nMSVC-2015+\n\n\n\n\nConfiguration\n\n\n\n\n\n\n\n\nMacro\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBOOST_DI_VERSION\n\n\nCurrent version of [Boost].DI (ex. 1'0'0)\n\n\n\n\n\n\nBOOST_DI_CFG\n\n\nGlobal configuration allows to customize provider and policies (See \nConfig\n)\n\n\n\n\n\n\nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n\n\nLimits number of allowed constructor parameters [0-10, default=10] (See \nInjections\n)\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\nGives more information with error messages (See \nError messages\n)\n\n\n\n\n\n\nBOOST_DI_NAMESPACE_BEGIN\n\n\nnamespace boost { namespace di { inline namespace v_1_0_0 {\n\n\n\n\n\n\nBOOST_DI_NAMESPACE_END\n\n\n}}}\n\n\n\n\n\n\n\n\nException Safety\n\n\n\n\n[Boost].DI is not using exceptions internally and therefore might be compiled with \n-fno-exceptions\n.\n\n\nCheck \nUser Guide\n to verify which API's are marked \nnoexcept\n.\n\n\n\n\nThread Safety\n\n\n\n\n[Boost].DI is thread safe.\n\n\n\n\nError Messages\n\n\n\n\n[Boost].DI is designed to give great diagnostic errors. The examples below will show you the actual error messages for different scenarios. Check \nConcepts\n to check it out.\n\n\n\n\nPerformance\n\n\n\n\n[Boost].DI has none run-time overhead and compiles faster than Java's DI frameworks. Check \nBenchmarks\n to see more.", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/index.html#quick-start", 
            "text": "Get  boost/di.hpp  header   wget https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp   Include the header and define  di  namespace alias   #include  boost/di.hpp \nnamespace di = boost::di;   Compile with C++14 support   $CXX -std=c++14 ...    Note \n[Boost].DI compiles with -fno-exceptions -fno-rtti -Wall -Wextra -Werror -pedantic -pedantic-errors   To run tests   git clone https://github.com/boost-experimental/di   cd di   make", 
            "title": "Quick Start"
        }, 
        {
            "location": "/overview/index.html#dependencies", 
            "text": "No external dependencies are required (neither STL nor Boost)", 
            "title": "Dependencies"
        }, 
        {
            "location": "/overview/index.html#supportedtested-compilers", 
            "text": "Clang-3.4+  GCC-5.2+  MSVC-2015+", 
            "title": "Supported/Tested compilers"
        }, 
        {
            "location": "/overview/index.html#configuration", 
            "text": "Macro  Description      BOOST_DI_VERSION  Current version of [Boost].DI (ex. 1'0'0)    BOOST_DI_CFG  Global configuration allows to customize provider and policies (See  Config )    BOOST_DI_CFG_CTOR_LIMIT_SIZE  Limits number of allowed constructor parameters [0-10, default=10] (See  Injections )    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  Gives more information with error messages (See  Error messages )    BOOST_DI_NAMESPACE_BEGIN  namespace boost { namespace di { inline namespace v_1_0_0 {    BOOST_DI_NAMESPACE_END  }}}", 
            "title": "Configuration"
        }, 
        {
            "location": "/overview/index.html#exception-safety", 
            "text": "[Boost].DI is not using exceptions internally and therefore might be compiled with  -fno-exceptions .  Check  User Guide  to verify which API's are marked  noexcept .", 
            "title": "Exception Safety"
        }, 
        {
            "location": "/overview/index.html#thread-safety", 
            "text": "[Boost].DI is thread safe.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/overview/index.html#error-messages", 
            "text": "[Boost].DI is designed to give great diagnostic errors. The examples below will show you the actual error messages for different scenarios. Check  Concepts  to check it out.", 
            "title": "Error Messages"
        }, 
        {
            "location": "/overview/index.html#performance", 
            "text": "[Boost].DI has none run-time overhead and compiles faster than Java's DI frameworks. Check  Benchmarks  to see more.", 
            "title": "Performance"
        }, 
        {
            "location": "/tutorial/index.html", 
            "text": "0. [Pre] Refactor towards DI\n\n\nIf you write a new application you can skip this step and go directly to \nstep 1\n.\nHowever, if you have a lot code which is not using DI and you wonder what can it be refactored,\nthen you are in the right place.\n\n\nBasically, there is a only one (big) step to get all benefits of Dependency Injection.\nYou have to separate creation logic from business logic, which means that your code\nshould be free of object creation inside other objects...\n\n\nclass controller {\npublic:\n  controller(config c) \n    : model_(std::make_unique\nmodel\n(c))\n  { }\n\n  void run();\n\nprivate:\n  std::unique_ptr\nmodel\n model_;\n};\n\nint main() {\n  controller controller_;\n  controller_.run();\n}\n\n\n\n\nInstead, DI approach would look like that...\n\n\nclass controller {\npublic:\n  explicit controller(model\n m) : model_(m) {}\n  void run();\n\nprivate:\n  model\n model_;\n};\n\nint main() {\n  model model_;\n  controller controller_{model_};\n  controller_.run();\n}\n\n\n\n\nSo, what happened here? We just took the responsibility of creation \nmodel\n out from the \ncontroller\n. In other words,\nwe have split the creation logic and the business logic.\n\n\nThat's basically everything you have to remember in order to create applications using DI.\nNevertheless, please, be careful and don't 'carry out' your dependencies. What is meant by that,\nis NOT to pass an object into constructor if it won't be stored (\nLaw of Demeter\n).\n\n\nclass app {\npublic:\n  explicit app(model\n m) : controller_(m) {} // BAD\n  explicit app(controller\n c) : controller_(c) {} // GOOD\n\nprivate:\n  controller controller_;\n};\nclass controller {\npublic:\n  explicit controller(model\n);\n};\n\nint main() {\n  model model_;\n  app app_{model_};\n}\n\n\n\n\nAdditionally, you can consider using \nstrong typedefs\n which will make your constructor interface cleaner/stronger.\n\n\nclass button {\npublic:\n  button(int, int); // weak constructor interface (cpp file has to checked in order to figure out the meaning of int's)\n};\n\n\n\n\nbutton\n constructor is not clear because \nint's\n are ambiguous and both present just a number.\nIt can be seen more clearly in the following example.\n\n\nbutton{10, 15}; // OK, but what's 10? what's 15? Can I swap them?\nbutton{15, 10}; // Hmm, potenial missue of the constructor\n\n\n\n\nA better approach would be to introduce a strong typedefs for both numbers\nin order to avoid potential misuse of the constructor, especially when used by other/external teams.\n\n\nstruct width {\n  int value;\n  constexpr operator int() const { return value; }\n};\nstruct height {\n  int value;\n  constexpr operator int() const { return value; }\n};\nclass button {\npublic:\n  button(width, height); // strong constructor interface\n};\n\n\n\n\nRight now, \nbutton\n constructor is much easier to follow (no need to check cpp file) because\nit expresses the intention.\n\n\nbutton{width{10}, height{15}}; // OK, declartive approach\nbutton{height{10}, with{15}}; // Compile Error\nbutton{10, 15}; // Compile Error\n\n\n\n\nSimilar mechanism is used by [Boost].DI to achieve \nnamed\n parameters which and it will be presented in this tutorial later on.\n\n\n1. [Basic] Create objects tree\n\n\nBefore we will get into creating objects tree, let's first create a 'dummy' example.\nIn order to do so, firstly, we have to include (one and only) \nboost/di.hpp\n header\n\n\nwget https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp\n\n\n\n\nand declare a convenient \ndi\n namespace alias.\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n\n\n\n\nThat is enough to try out \n[Boost].DI\n!\n\n\nTo have a first complete and working example we just have to add \nmain\n function as usual.\n\n\nint main() {}\n\n\n\n\nand compile our code using compiler supporting C++14 standard (Clang-3.4/GCC-5/MSVC-2015).\n\n\n$CXX -std=c++14 example.cpp\n\n\n\n\nCongrats, you are now ready to check out \n[Boost].DI\n features!\n\n\n\n\nLet's move on to creating objects tree. Applications, usually, consists of a number of objects\nwhich have to be instantiated. For example, let's consider a simplified Model View Controller code...\n\n\n\n\nThe usual approach to create \napp\n would be following...\n\n\nrenderer renderer_;\nview view_{\n, renderer_};\nmodel model_;\ncontroller controller_{model_, view_};\nuser user_;\napp app_{controller_, user_};\n\n\n\n\nWhich is alright for a really small applications. However, it's really tedious to maintain.\nJust imagine, that we have to change something here. For instance, \nview\n may need a new object \nwindow\n\nor, even worse, we refactored the code and dependencies order has changed - yea \nORDER\n of above is important!\n\nANY\n change in these classes constructors require developer input to maintain above boilerplate code!\nNot fun, not fun at all :(\n\n\nRight now imagine that your maintain effort will be minimized almost to none. How does it sound?\nWell, that might be simply achieved with \n[Boost].DI\n!\n\n\nThe same result might be achieved with [Boost].DI. All, non-ambiguous, dependencies will be automatically\nresolved and injected properly. It doesn't matter how big the hierarchy will be and/or if the order of constructor parameters will be changed in the future.\nWe just have to create \ninjector\n using \nmake_injector\n, create the \napp\n and DI will take care of injecting proper types for us.\n\n\nauto app_ = make_injector().create\napp\n(); // It will create an `app` on stack and call its copy constructor\n\n\n\n\nHow is that possible? [Boost].DI is able to figure out what parameters are required for the constructor of type T.\nAlso, [Boost].DI is able to do it recursively for all required types by the constructor T. Hence, NO information\nabout constructors parameters is required to be registered.\n\n\nMoreover, changes in the constructor of created objects will be handled automatically, so in our case\nwhen we add a \nwindow\n to \nview\n or change \nview\n to \nstd::shared_ptr\nview\n required effort will be\nexactly '0'. \n[Boost].DI\n will take care of everything for us!\n\n\n\n\n\n\n\n\nType \nT\n\n\nIs allowed?\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nT*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\nReference with \nsingleton\n / Temporary with \nunique\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::unique_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::weak_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nboost_shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\n\n\nFurthermore, there is no performance penalty for using \n[Boost].DI\n (see \nPerformance\n)!\n\n\n \nNote\n\n[Boost].DI can \ninject\n dependencies using direct initialization \nT(...)\n or uniform initialization \nT{...}\n for aggregate types.\n\n\n\nAnd full example!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct renderer {\n  int device;\n};\n\nclass view {\n public:\n  view(std::string /*title*/, const renderer\n) {}\n};\n\nclass model {};\n\nclass controller {\n public:\n  controller(model\n, view\n) {}\n};\n\nclass user {};\n\nclass app {\n public:\n  app(controller\n, user\n) {}\n};\n\nint main() {\n  /**\n   * renderer renderer_;\n   * view view_{\n, renderer_};\n   * model model_;\n   * controller controller_{model_, view_};\n   * user user_;\n   * app app_{controller_, user_};\n   */\n\n  auto injector = di::make_injector();\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_create_objects_tree.cpp\n\n\n\n\nCheck out also other examples. Please, notice that the diagram was also generated using \n[Boost].DI\n but we will get into that a bit later.\n\n\n\n\n Hello World Example\n\n\n Automatic Injection Example\n\n\n UML Dumper Extension\n\n\n\n\n\n\n2. [Basic] First steps with bindings\n\n\nBut objects tree is not everything. A lot of classes uses interfaces or required a value to be passed.\n\n[Boost].DI\n solution for this are \nbindings\n.\n\n\nFor purpose of this tutorial, let's change \nview\n class into interface \niview\n in order to support \ntext_view\n and \ngui_view\n.\n\n\nclass iview {\npublic:\n  virtual ~iview() noexcept = default;\n  virtual void update() =0;\n};\n\nclass gui_view: public iview {\npublic:\n  gui_view(std::string title, const renderer\n) {}\n  void update() override {}\n};\n\nclass text_view: public iview {\npublic:\n  void update() override {}\n};\n\n\n\n\nPlease, notice that \ntext_view\n doesn't require any constructor parameters, whilst \ngui_view\n does.\n\n\nSo, what will happen right now, when we try to create an \napp\n?\n\n\nauto app = make_injector().create\napp\n();\n\n\n\n\nCOMPILE error! (See also: \nError Messages\n)\n\n\nwarning: 'create\napp\n' is deprecated: creatable constraint not satisfied\n  injector.create\napp\n();\n           ^\nboost/di.hpp:870:2: error: 'boost::di::v1_0_0::concepts::abstract_type\niview\n::is_not_bound::error'\n  error(_ = \ntype is not bound, did you forget to add: 'di::bind\ninterface\n.to\nimplementation\n()'?\n);\n\n\n\n\n \nNote\n\nYou can get more info about error by increasing \nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n [0-2] value (default=1).\n\n\n\nAh, okay, we haven't bound \niview\n which means that \nBOOST.DI\n can't figure out whether we want \ntext_view\n or \ngui_view\n?\nWell, it's really simple to fix it, we just follow suggestion provided.\n\n\nconst auto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n()\n);\n\n\n\n\nLet's try again. Yay! It's compiling.\n\n\nBut what about \nrender.device\n value? So far, it was value initialized by default(=0).\nWhat, if you we want to initialize it with a user defined value instead?\nWe've already seen how to bind interface to implementation.\nThe same approach might be used in order to bind a type to a value.\n\n\ndi::bind\nT\n.to(value) // bind type T to given value\n\n\n\n\nMoving back to our \nrender.device\n...\n\n\nstruct renderer {\n  int device;\n};\n\n\n\n\n \nNote\n\nIf you want change the default behaviour and be sure that all required dependencies are bound and not value initialized\ntake a look at \nconstructible\n policy.\n\n\n\nconst auto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n()\n, di::bind\nint\n.to(42) // renderer.device | [Boost].DI can also deduce 'int' type for you -\n 'di::bind\n.to(42)'\n);\n\n\n\n\n \nNote\n\n[Boost].DI is a compile time beast which means that it guarantees that if your code compiles, all dependencies will be resolved\ncorrectly. No runtime exceptions or runtime asserts, EVER!\n\n\n\nAnd full example!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nclass iview {\n public:\n  virtual ~iview() noexcept = default;\n  virtual void update() = 0;\n};\n\nclass gui_view : public iview {\n public:\n  gui_view(std::string /*title*/, const renderer\n r) { assert(42 == r.device); }\n  void update() override {}\n};\n\nclass text_view : public iview {\n public:\n  void update() override {}\n};\n\n\nclass controller {\n public:\n  controller(model\n, iview\n) {}\n};\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\niview\n().to\ngui_view\n()\n  , di::bind\nint\n().to(42) // renderer device\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings.cpp\n\n\n\n\nThat's nice but I don't want to be using a dynamic (virtual) dispatch. What about concepts/templates?\nGood news, \n[Boost].DI\n can inject concepts/templates too!\n\n\ntemplate \nclass T = class Greater\n\nstruct example { \n  using type = T;\n};\n\nstruct hello {};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind\nclass Greater\n.to\nhello\n()\n  );\n\n  auto object = injector.create\nexample\n();\n  static_assert(std::is_same\nhello, decltype(object)::type\n{});\n}\n\n\n\n\nAnd full example!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nclass Greater;\n\ntemplate \nclass T = Greater\n\nstruct example {\n  using type = T;\n};\n\nstruct hello {};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind\nGreater\n().to\nhello\n()\n  );\n\n  auto object = injector.create\nexample\n();\n  static_assert(std::is_same\nhello, decltype(object)::type\n{}, \n);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_template_bindings.cpp\n\n\n\n\nGreat, but my code is more dynamic than that! I mean that I want to choose \ngui_view\n or \ntext_view\n at runtime.\n\n[Boost].DI\n can handle that too!\n\n\nauto use_gui_view = true/false;\n\nconst auto injector = di::make_injector(\n  di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n    if (use_gui_view)\n      return injector.template create\ngui_view\n();\n    else\n      return injector.template create\ntext_view\n();\n  })\n, di::bind\n.to(42) // renderer device\n);\n\n\n\n\n \nNote\n\nIt is safe to throw exceptions from lambda. It will be passed through.\n\n\n\nNotice, that \ninjector\n was passed to lambda expression in order to create \ngui_view\n / \ntext_view\n.\nThis way \n[Boost].DI\n can inject appropriate dependencies into chosen types. See \nbindings\n for more details.\n\n\nAnd full example!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nclass user {};\n\nclass app {\n public:\n  app(controller\n, user\n) {}\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\nint\n().to(42) // renderer device\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_dynamic_bindings.cpp\n\n\n\n\nOkay, so what about the input. We have \nuser\n, however, in the real life, we will have more clients.\n\n[Boost].DI\n allows multiple bindings to the same type for \narray/vector/set\n. Let's do it then!\n\n\nclass iclient {\n public:\n   virtual ~iclient() noexcept = default;\n   virtual void process() = 0;\n};\n\nclass user : public iclient {\n public:\n   void process() override {};\n};\n\nclass timer : public iclient {\n public:\n   void process() override {};\n};\n\nclass app {\n public:\n  app(controller\n, std::vector\nstd::unique_ptr\niclient\n);\n};\n\n\n\n\nAnd our bindings...\n\n\ndi::bind\niclient*[]\n.to\nuser, client\n()\n\n\n\n\nAnd full example!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nclass user : public iclient {\n public:\n  void process() override{};\n};\n\nclass timer : public iclient {\n public:\n  void process() override{};\n};\n\nclass app {\n public:\n  app(controller\n, std::vector\nstd::unique_ptr\niclient\n v) {\n    assert(2 == v.size());\n    assert(dynamic_cast\nuser*\n(v[0].get()));\n    assert(dynamic_cast\ntimer*\n(v[1].get()));\n  }\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_multiple_bindings.cpp\n\n\n\n\nThe last but not least, sometimes, it's really useful to override some bindings. For example, for testing purposes.\nWith \n[Boost].DI\n you can easily do that with \noverride\n specifier (Implemented using \noperator[](override)\n).\n\n\nconst auto injector = di::make_injector(\n  di::bind\nint\n.to(42) // renderer device\n, di::bind\nint\n.to(123) [di::override] // override renderer device\n);\n\n\n\n\nWithout the \ndi::override\n following compilation error will occur...\n\n\nboost/di.hpp:281:3: error: static_assert failed \nconstraint not satisfied\n\nboost/di.hpp:2683:80: type\nint\n::is_bound_more_than_once\n  inline auto make_injector(TDeps... args) noexcept\n\n\n\n\nAnd full example!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\nint\n().to(123) [di::override] // override renderer device\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings_override.cpp\n\n\n\n\nCheck out also.\n\n\n\n\n Bindings Example\n\n\n Forward Bindings Example\n\n\n Dynamic Bindings Example\n\n\n Multiple Bindings Example\n\n\n Constructor Bindings Extension\n\n\n\n\n\n\n3. [Basic] Decide the life times\n\n\nSo far so good but where are these objects stored?\nWell, \n[Boost].DI\n supports \nscopes\n which are response for maintaining the life time of created objects.\nBy default there are 4 scopes\n\n\n\n\ndeduce\n scope (default)\n\n\ninstance\n scope (bind\n.to(value) where value is maintained by the user)\n\n\nunique\n scope (one instance per request)\n\n\nsingleton\n scope (shared instance)\n\n\n\n\nBy default \ndeduce\n scope is used which means that scope is deduced based on a constructor parameter.\nFor instance, reference, shared_ptr will be deduced as \nsingleton\n scope and pointer, unique_ptr will be deduced as \nunique\n scope.\n\n\n\n\n\n\n\n\nType\n\n\nScope\n\n\n\n\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nT\n\n\nsingleton\n\n\n\n\n\n\nconst T\n\n\nunique\n (temporary) / \nsingleton\n\n\n\n\n\n\nT*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nconst T*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nstd::unique_ptr\n\n\nunique\n\n\n\n\n\n\nstd::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nboost::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nstd::weak_ptr\n\n\nsingleton\n\n\n\n\n\n\n\n\nExample\n\n\nclass scopes_deduction {\n  scopes_deduction(const int\n /*singleton scope*/,\n                   std::shared_ptr\nint\n /*singleton scope*/,\n                   std::unique_ptr\nint\n /*unique scope*/,\n                   int /*unique scope*/)\n  { }\n};\n\ndi::make_injector().create\nexample\n(); // scopes will be deduced based on constructor parameter types\n\n\n\n\nComing back to our example, we got quite a few \nsingletons\n there as we just needed one instance per application life time.\nAlthough scope deduction is very useful, it's not always what we need and therefore \n[Boost].DI\n allows changing the scope for a given type.\n\n\nconst auto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n().in(di::singleton) // explicitly specify singleton scope\n);\n\n\n\n\nWhat if I want to change \ngui_view\n to be a different instance per each request. Let's change the scope to \nunique\n then.\n\n\nconst auto injector = di::make_injector(\n  di::bind\niview\n.to\ngui_view\n().in(di::unique)\n);\n\n\n\n\nWe will get a COMPILATION TIME ERROR because a unique scope can't be converted to a reference.\nIn other words, having a reference to a copy is forbidden and it won't compile!\n\n\nwarning: 'create\napp\n' is deprecated: creatable constraint not satisfied\n  injector.create\napp\n();\n           ^\nboost/di.hpp:897:2: error: 'scoped\nscopes::unique, gui_view\n::is_not_convertible_to\niview \n::error'\n  error(_ = \nscoped object is not convertible to the requested type, did you mistake the scope: 'di::bind\nT\n.in(scope)'?\n);\n\n\n\n\nAh, reference doesn't make much sense with \nunique\n scope because it would mean that it has to be stored somewhere.\nIt would be better to use \nstd::unique_ptr\niview\n instead.\n\n\n\n\n\n\n\n\nType/Scope\n\n\nunique\n\n\nsingleton\n\n\ninstance\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT* (transfer ownership)\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\n\n\nHmm, let's try something else then. We have list of unique clients, we can share objects just by changing the list to\nuse \nstd::shared_ptr\n instead.\n\n\nclass app {\n public:\n  app(controller\n, std::vector\nstd::shared_ptr\niclient\n);\n};\n\n\n\n\nBut, it would be better if \ntimer\n was always created per request, although it's a \nshared_ptr\n.\nTo do so, we just need add scope when binding it, like this...\n\n\nconst auto injector = di::make_injector(\n  di::bind\ntimer\n.in(di::unique) // different per request\n);\n\n\n\n\nCheck out the full example here.\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n().in(di::unique) // different per request\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\nint\n().to(123) [di::override] // override renderer device\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_decide_the_life_times.cpp\n\n\n\n\nSee also.\n\n\n\n\n Deduce Scope Example\n\n\n Scopes Example\n\n\n Eager Singletons Example\n\n\n\n\n\n\n4. [Basic] Annotations to the rescue\n\n\nAbove example are fine and dandy, nonetheless, they don't cover one important thing.\nHow \n[Boost].DI\n knows which constructor to choose and what if they are ambiguous?\n\n\nWell, the algorithm is very simple. The longest (most parameters), unique constructor will be chosen.\nOtherwise, \n[Boost].DI\n will give up with a compile time error. However, which constructor should\nbe chosen is configurable by \nBOOST_DI_INJECT\n.\n\n\nTo illustrate this, let's modify \nmodel\n constructor.\n\n\nclass model {\n public:\n   model(int size, double precision) { }\n   model(int rows, int cols) { }\n};\n\n\n\n\nRight now, as expected, we get a compile time error!\n\n\nwarning: 'create\napp\n' is deprecated: creatable constraint not satisfied\n  injector.create\napp\n();\n           ^\nboost/di.hpp:942:4: error: 'type\nmodel\n::has_ambiguous_number_of_constructor_parameters::error'\n  error(_ = \nverify BOOST_DI_INJECT_TRAITS or di::ctor_traits\n);\n\n\n\n\nLet's fix it using \nBOOST_DI_INJECT\n then!\n\n\nclass model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, int rows, int cols) { } // this constructor will be injected\n};\n\n\n\n\n \nNote\n\nWe can also write \nmodel(int rows, int cols, ...)\n to get the same result.\nBy adding \n...\n as the last parameter of the constructor it's guaranteed by [Boost].DI\nthat it will be used for injection as it will have the highest number of constructor parameters (infinite number).\n\n\n\nOkay, right now it compiles but, wait a minute, \n123\n (renderer device) was injected for both \nrows\n and \ncols\n!\nWell, it wasn't even close to what we wanted, but we can fix it easily using \nnamed\n annotations.\n\n\nFirstly, we have to create names. That's easy as names are just unique objects.\n\n\nauto Rows = []{};\nauto Cols = []{};\n\n\n\n\nSecondly, we have to tell \nmodel\n constructor about it.\n\n\nclass model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols); // this constructor will be injected\n};\n\nmodel::model(int rows, int cols) {}\n\n\n\n\nPlease, notice that we have separated \nmodel\n constructor definition and declaration to show that definition doesn't\nrequire named annotations.\n\n\n \nNote\n\nIf you happen to use clang/gcc compiler you can use string literals instead of creating objects,\nfor example \n(named = \"Rows\"_s)\n.\n\n\n\nFinally, we have to bind our values.\n\n\nconst auto injector = di::make_injector(\n  di::bind\nint\n.named(Rows).to(6)\n, di::bind\nint\n.named(Cols).to(8)\n);\n\n\n\n\nThat's all.\n\n\n \nNote\n\nThe same result might be accomplished with having different types for rows and cols.\n\n\n\nFull example here.\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto Rows = [] {};\nauto Cols = [] {};\n\n\nclass model {\n public:\n  model(int /*size*/, double /*precision*/) {}\n  BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols);\n};\n\nmodel::model(int rows, int cols) {\n  assert(6 == rows);\n  assert(8 == cols);\n}\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n().in(di::unique) // different per request\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\nint\n().to(123) [di::override] // override renderer device\n  , di::bind\nint\n().named(Rows).to(6)\n  , di::bind\nint\n().named(Cols).to(8)\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_annotations_to_the_rescue.cpp\n\n\n\n\nCheck out also...\n\n\n\n\n Constructor Injection Example\n\n\n Constructor Signature Example\n\n\n Annotations Example\n\n\n\n\n\n\n5. [Basic] Split your configuration\n\n\nBut my project has hundreds of interfaces and I would like to split my bindings into separate components.\nThis is simple to do with [Boost.DI] as an \ninjector\n can be extended by other injectors.\n\n\nLet's split our configuration then and keep our \nmodel\n bindings separately from \napp\n bindings.\n\n\nauto model_module = [] {\n  return di::make_injector(\n    di::bind\nint\n.named(Rows).to(6)\n  , di::bind\nint\n.named(Cols).to(8)\n  );\n};\n\nauto app_module = [](const bool\n use_gui_view) {\n  return di::make_injector(\n    di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n.in(di::unique) // different per request\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  );\n};\n\n\n\n\nAnd glue them into one injector the same way...\n\n\n  const auto injector = di::make_injector(\n    model_module()\n  , app_module(use_gui_view)\n  );\n\n\n\n\n \nNote\n\nGluing many \ninjector\ns into one is order independent.\n\n\n\nAnd full example!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nauto model_module = [] {\n  return di::make_injector(\n    di::bind\nint\n().named(Rows).to(6)\n  , di::bind\nint\n().named(Cols).to(8)\n  );\n};\n\nauto app_module = [](const bool\n use_gui_view) {\n  return di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n().in(di::unique) // different per request\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\nint\n().to(123) [di::override] // override renderer device\n  );\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    model_module()\n  , app_module(use_gui_view)\n  );\n\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration.cpp\n\n\n\n\nBut I would like to have a module in \ncpp\n file, how can I do that?\nSuch design might be achieved with \n[Boost].DI\n using \ninjector\n and exposing given types.\n\n\n\n\nExpose all types (default)\n\n\n\n\nconst const auto injector = // auto exposes all types\n  di::make_injector(\n    di::bind\nint\n.to(42)\n  , di::bind\ndouble\n.to(87.0)\n  );\n\ninjector.create\nint\n(); OK\ninjector.create\ndouble\n(); // OK\n\n\n\n\n\n\nExpose only specific types\n\n\n\n\nconst di::injector\nint\n injector = // only int is exposed\n  di::make_injector(\n    di::bind\nint\n.to(42)\n  , di::bind\ndouble\n.to(87.0)\n  );\n\ninjector.create\nint\n(); OK\ninjector.create\ndouble\n(); // COMPILE TIME ERROR, double is not exposed by the injector\n\n\n\n\nWhen exposing all types using \nauto\n modules have to be implemented in a header file.\nWith \ndi::injector\nT...\n a definition might be put in a cpp file as it\u2019s just a regular type.\n\n\nSuch approach has a few benefits:\n* It\u2019s useful for encapsulation (ex. Another team provides a module but they don't want to expose an ability to create implementation details)\n* May also speed compilation times in case of extend usage of cpp files\n\n\n \nNote\n\nThere is no performance (compile-time, run-time) overhead between exposing all types or just a specific ones.\n\n\n\nMoving back to our example. Let's refactor it then.\n\n\ndi::injector\nmodel\n model_module() {\n  return di::make_injector(\n    di::bind\nint\n.named(Rows).to(6)\n  , di::bind\nint\n.named(Cols).to(8)\n  );\n}\n\ndi::injector\napp\n app_module(const bool\n use_gui_view) {\n  return di::make_injector(\n    di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n.in(di::unique) // different per request\n  , di::bind\niclient*[]\n.to\nuser, timer\n() // bind many clients\n  , model_module()\n  );\n}\n\n\n\n\nRight now you can easily separate definition and declaration between \nhpp\n and \ncpp\n files.\n\n\nCheck the full example here!\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto Rows = [] {};\nauto Cols = [] {};\n\n\ndi::injector\nmodel\n model_module() {\n  return di::make_injector(\n    di::bind\nint\n().named(Rows).to(6)\n  , di::bind\nint\n().named(Cols).to(8)\n  );\n}\n\ndi::injector\napp\n app_module(const bool\n use_gui_view) {\n  return di::make_injector(\n    di::bind\niview\n().to([\n](const auto\n injector) -\n iview\n {\n      if (use_gui_view)\n        return injector.template create\ngui_view\n();\n      else\n        return injector.template create\ntext_view\n();\n    })\n  , di::bind\ntimer\n().in(di::unique) // different per request\n  , di::bind\niclient*[]\n().to\nuser, timer\n() // bind many clients\n  , di::bind\nint\n().to(42) // renderer device\n  , di::bind\nint\n().to(123) [di::override] // override renderer device\n  , model_module()\n  );\n}\n\nint main() {\n  auto use_gui_view = true;\n  auto injector = app_module(use_gui_view);\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration_expose.cpp\n\n\n\n\n \nNote\n\nYou can also expose named parameters using \ndi::injector\nBOOST_DI_EXPOSE((named = Rows) int)\n.\nDifferent variations of the same type have to be exposed explicitly using \ndi::injector\nmodel\n, std::unique_ptr\nmodel\n.\nType erasure is used under the hood when types are exposed explicitly (\ndi::injector\nT\u2026\n).\n\n\nCheck out more examples here!\n\n\n\n\n Modules Example\n\n\n Exposed Annotated Type Example\n\n\n Exposed Complex Types Example\n\n\n\n\n\n\nCongrats! You have finished the basic part of the tutorial.\nHopefully, you have noticed potential of DI and \n[Boost].DI\n but if are still not convinced check out the \nAdvanced\n part.\n\n\n6. [Advanced] Dump/Limit your types\n\n\nIt's often a case that we would like to generate object diagram of our application in order to see code dependencies\nmore clear. Usually, it's a really hard task as creation of objects may happen anywhere in the code. However,\nif the responsibility for creation  objects will be given to \n[Boost].DI\n we get such functionality for free.\nThe only thing we have to do is to implement how to dump our objects.\n\n\nLet's dump our dependencies using \nPlant UML\n format.\n\n\n#include \nboost/di/extension/policies/uml_dumper.hpp\n\n\n#include \nmemory\n\n\nnamespace di = boost::di;\n\n\nint main() {\n  /*\ndefine injector\n*/\n  auto injector = di::make_injector\ndi::extension::uml_dumper\n(\n    di::bind\ni0\n().to\nc0\n()\n  , di::bind\nint\n().named(int_1).to(42)\n  , di::bind\nint\n().named(int_2).to(42)\n  );\n\n  /*\niterate through created objects with `types_dumper`\n*/\n  injector.create\nc3\n();\n\n  /*\noutput [@images/uml_dumper.png [$images/uml_dumper.png [width 75%] [height 75%] ]]\n*/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/uml_dumper.cpp\n\n\n\n\n\n\nSee also.  \n\n* \n Custom Policy Example\n\n* \n Types Dumper Extension\n\n\n\n\nOn the other hand, it would be great to be able to limit types which might be constructed. For example, we just want to allow\nsmart pointers and disallow raw pointers too. We may want to have a \nview\n only with const parameters being passed, etc.\n\n[Boost].DI\n allows you to do so by using \nconstructible\n policy or writing a custom \npolicy\n.\n\n\nclass all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include \nboost/di.hpp\n\n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same\ndi::_, int\n{} || is_bound\ndi::_\n{}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create\nint\n());\n  // di::make_injector().create\ndouble\n(); // compile error\n  assert(42.0 == make_injector(di::bind\ndouble\n().to(42.0)).create\ndouble\n());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_global.cpp\n\n\n\n\nSee also.\n\n\n\n\n Constructible Example\n\n\n\n\n\n\n7. [Advanced] Customize it\n\n\n[Boost].DI\n was design having extensibility in mind. You can easily customize\n\n\n\n\nscopes\n - to have custom life time of an object\n\n\nproviders\n - to have custom way of creating objects, for example by using preallocated memory\n\n\n\n\npolicies\n - to have custom way of dumping types at run-time or limiting them at compile-time\n\n\n\n\n\n\n Custom Policy Example\n\n\n\n\n Custom Provider Example\n\n\n Pool Provider Example\n\n\n\n\n\n\n8. [Advanced] Extend it\n\n\nAs mentioned before, \n[Boost].DI\n is quite easy to extend and therefore a lot of extensions exists already.\nPlease check them out and write your own!\n\n\n\n\nConstructor Bindings\n\n\nAssisted Injection\n\n\nConcepts\n\n\nLazy\n\n\nNamed Parameters\n\n\nXML Injection\n\n\nTypes Dumper\n\n\nUML Dumper\n\n\nMocks Provider\n\n\nScoped Scope\n\n\nSession Scope\n\n\nShared Scope", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/index.html#0-pre-refactor-towards-di", 
            "text": "If you write a new application you can skip this step and go directly to  step 1 .\nHowever, if you have a lot code which is not using DI and you wonder what can it be refactored,\nthen you are in the right place.  Basically, there is a only one (big) step to get all benefits of Dependency Injection.\nYou have to separate creation logic from business logic, which means that your code\nshould be free of object creation inside other objects...  class controller {\npublic:\n  controller(config c) \n    : model_(std::make_unique model (c))\n  { }\n\n  void run();\n\nprivate:\n  std::unique_ptr model  model_;\n};\n\nint main() {\n  controller controller_;\n  controller_.run();\n}  Instead, DI approach would look like that...  class controller {\npublic:\n  explicit controller(model  m) : model_(m) {}\n  void run();\n\nprivate:\n  model  model_;\n};\n\nint main() {\n  model model_;\n  controller controller_{model_};\n  controller_.run();\n}  So, what happened here? We just took the responsibility of creation  model  out from the  controller . In other words,\nwe have split the creation logic and the business logic.  That's basically everything you have to remember in order to create applications using DI.\nNevertheless, please, be careful and don't 'carry out' your dependencies. What is meant by that,\nis NOT to pass an object into constructor if it won't be stored ( Law of Demeter ).  class app {\npublic:\n  explicit app(model  m) : controller_(m) {} // BAD\n  explicit app(controller  c) : controller_(c) {} // GOOD\n\nprivate:\n  controller controller_;\n};\nclass controller {\npublic:\n  explicit controller(model );\n};\n\nint main() {\n  model model_;\n  app app_{model_};\n}  Additionally, you can consider using  strong typedefs  which will make your constructor interface cleaner/stronger.  class button {\npublic:\n  button(int, int); // weak constructor interface (cpp file has to checked in order to figure out the meaning of int's)\n};  button  constructor is not clear because  int's  are ambiguous and both present just a number.\nIt can be seen more clearly in the following example.  button{10, 15}; // OK, but what's 10? what's 15? Can I swap them?\nbutton{15, 10}; // Hmm, potenial missue of the constructor  A better approach would be to introduce a strong typedefs for both numbers\nin order to avoid potential misuse of the constructor, especially when used by other/external teams.  struct width {\n  int value;\n  constexpr operator int() const { return value; }\n};\nstruct height {\n  int value;\n  constexpr operator int() const { return value; }\n};\nclass button {\npublic:\n  button(width, height); // strong constructor interface\n};  Right now,  button  constructor is much easier to follow (no need to check cpp file) because\nit expresses the intention.  button{width{10}, height{15}}; // OK, declartive approach\nbutton{height{10}, with{15}}; // Compile Error\nbutton{10, 15}; // Compile Error  Similar mechanism is used by [Boost].DI to achieve  named  parameters which and it will be presented in this tutorial later on.", 
            "title": "0. [Pre] Refactor towards DI"
        }, 
        {
            "location": "/tutorial/index.html#1-basic-create-objects-tree", 
            "text": "Before we will get into creating objects tree, let's first create a 'dummy' example.\nIn order to do so, firstly, we have to include (one and only)  boost/di.hpp  header  wget https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp  and declare a convenient  di  namespace alias.  #include  boost/di.hpp \nnamespace di = boost::di;  That is enough to try out  [Boost].DI !  To have a first complete and working example we just have to add  main  function as usual.  int main() {}  and compile our code using compiler supporting C++14 standard (Clang-3.4/GCC-5/MSVC-2015).  $CXX -std=c++14 example.cpp  Congrats, you are now ready to check out  [Boost].DI  features!   Let's move on to creating objects tree. Applications, usually, consists of a number of objects\nwhich have to be instantiated. For example, let's consider a simplified Model View Controller code...   The usual approach to create  app  would be following...  renderer renderer_;\nview view_{ , renderer_};\nmodel model_;\ncontroller controller_{model_, view_};\nuser user_;\napp app_{controller_, user_};  Which is alright for a really small applications. However, it's really tedious to maintain.\nJust imagine, that we have to change something here. For instance,  view  may need a new object  window \nor, even worse, we refactored the code and dependencies order has changed - yea  ORDER  of above is important! ANY  change in these classes constructors require developer input to maintain above boilerplate code!\nNot fun, not fun at all :(  Right now imagine that your maintain effort will be minimized almost to none. How does it sound?\nWell, that might be simply achieved with  [Boost].DI !  The same result might be achieved with [Boost].DI. All, non-ambiguous, dependencies will be automatically\nresolved and injected properly. It doesn't matter how big the hierarchy will be and/or if the order of constructor parameters will be changed in the future.\nWe just have to create  injector  using  make_injector , create the  app  and DI will take care of injecting proper types for us.  auto app_ = make_injector().create app (); // It will create an `app` on stack and call its copy constructor  How is that possible? [Boost].DI is able to figure out what parameters are required for the constructor of type T.\nAlso, [Boost].DI is able to do it recursively for all required types by the constructor T. Hence, NO information\nabout constructors parameters is required to be registered.  Moreover, changes in the constructor of created objects will be handled automatically, so in our case\nwhen we add a  window  to  view  or change  view  to  std::shared_ptr view  required effort will be\nexactly '0'.  [Boost].DI  will take care of everything for us!     Type  T  Is allowed?  Note      T  \u2714  -    T*  \u2714  Ownership transfer!    const T*  \u2714  Ownership transfer!    T  \u2714  -    const T  \u2714  Reference with  singleton  / Temporary with  unique    T  \u2714  -    std::unique_ptr T  \u2714  -    std::shared_ptr T  \u2714  -    std::weak_ptr T  \u2714  -    boost_shared_ptr T  \u2714  -     Furthermore, there is no performance penalty for using  [Boost].DI  (see  Performance )!    Note \n[Boost].DI can  inject  dependencies using direct initialization  T(...)  or uniform initialization  T{...}  for aggregate types.  And full example!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct renderer {\n  int device;\n};\n\nclass view {\n public:\n  view(std::string /*title*/, const renderer ) {}\n};\n\nclass model {};\n\nclass controller {\n public:\n  controller(model , view ) {}\n};\n\nclass user {};\n\nclass app {\n public:\n  app(controller , user ) {}\n};\n\nint main() {\n  /**\n   * renderer renderer_;\n   * view view_{ , renderer_};\n   * model model_;\n   * controller controller_{model_, view_};\n   * user user_;\n   * app app_{controller_, user_};\n   */\n\n  auto injector = di::make_injector();\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_create_objects_tree.cpp   Check out also other examples. Please, notice that the diagram was also generated using  [Boost].DI  but we will get into that a bit later.    Hello World Example   Automatic Injection Example   UML Dumper Extension", 
            "title": "1. [Basic] Create objects tree"
        }, 
        {
            "location": "/tutorial/index.html#2-basic-first-steps-with-bindings", 
            "text": "But objects tree is not everything. A lot of classes uses interfaces or required a value to be passed. [Boost].DI  solution for this are  bindings .  For purpose of this tutorial, let's change  view  class into interface  iview  in order to support  text_view  and  gui_view .  class iview {\npublic:\n  virtual ~iview() noexcept = default;\n  virtual void update() =0;\n};\n\nclass gui_view: public iview {\npublic:\n  gui_view(std::string title, const renderer ) {}\n  void update() override {}\n};\n\nclass text_view: public iview {\npublic:\n  void update() override {}\n};  Please, notice that  text_view  doesn't require any constructor parameters, whilst  gui_view  does.  So, what will happen right now, when we try to create an  app ?  auto app = make_injector().create app ();  COMPILE error! (See also:  Error Messages )  warning: 'create app ' is deprecated: creatable constraint not satisfied\n  injector.create app ();\n           ^\nboost/di.hpp:870:2: error: 'boost::di::v1_0_0::concepts::abstract_type iview ::is_not_bound::error'\n  error(_ =  type is not bound, did you forget to add: 'di::bind interface .to implementation ()'? );    Note \nYou can get more info about error by increasing  BOOST_DI_CFG_DIAGNOSTICS_LEVEL  [0-2] value (default=1).  Ah, okay, we haven't bound  iview  which means that  BOOST.DI  can't figure out whether we want  text_view  or  gui_view ?\nWell, it's really simple to fix it, we just follow suggestion provided.  const auto injector = di::make_injector(\n  di::bind iview .to gui_view ()\n);  Let's try again. Yay! It's compiling.  But what about  render.device  value? So far, it was value initialized by default(=0).\nWhat, if you we want to initialize it with a user defined value instead?\nWe've already seen how to bind interface to implementation.\nThe same approach might be used in order to bind a type to a value.  di::bind T .to(value) // bind type T to given value  Moving back to our  render.device ...  struct renderer {\n  int device;\n};    Note \nIf you want change the default behaviour and be sure that all required dependencies are bound and not value initialized\ntake a look at  constructible  policy.  const auto injector = di::make_injector(\n  di::bind iview .to gui_view ()\n, di::bind int .to(42) // renderer.device | [Boost].DI can also deduce 'int' type for you -  'di::bind .to(42)'\n);    Note \n[Boost].DI is a compile time beast which means that it guarantees that if your code compiles, all dependencies will be resolved\ncorrectly. No runtime exceptions or runtime asserts, EVER!  And full example!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nclass iview {\n public:\n  virtual ~iview() noexcept = default;\n  virtual void update() = 0;\n};\n\nclass gui_view : public iview {\n public:\n  gui_view(std::string /*title*/, const renderer  r) { assert(42 == r.device); }\n  void update() override {}\n};\n\nclass text_view : public iview {\n public:\n  void update() override {}\n};\n\n\nclass controller {\n public:\n  controller(model , iview ) {}\n};\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind iview ().to gui_view ()\n  , di::bind int ().to(42) // renderer device\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings.cpp   That's nice but I don't want to be using a dynamic (virtual) dispatch. What about concepts/templates?\nGood news,  [Boost].DI  can inject concepts/templates too!  template  class T = class Greater \nstruct example { \n  using type = T;\n};\n\nstruct hello {};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind class Greater .to hello ()\n  );\n\n  auto object = injector.create example ();\n  static_assert(std::is_same hello, decltype(object)::type {});\n}  And full example!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nclass Greater;\n\ntemplate  class T = Greater \nstruct example {\n  using type = T;\n};\n\nstruct hello {};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind Greater ().to hello ()\n  );\n\n  auto object = injector.create example ();\n  static_assert(std::is_same hello, decltype(object)::type {},  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_template_bindings.cpp   Great, but my code is more dynamic than that! I mean that I want to choose  gui_view  or  text_view  at runtime. [Boost].DI  can handle that too!  auto use_gui_view = true/false;\n\nconst auto injector = di::make_injector(\n  di::bind iview .to([ ](const auto  injector) -  iview  {\n    if (use_gui_view)\n      return injector.template create gui_view ();\n    else\n      return injector.template create text_view ();\n  })\n, di::bind .to(42) // renderer device\n);    Note \nIt is safe to throw exceptions from lambda. It will be passed through.  Notice, that  injector  was passed to lambda expression in order to create  gui_view  /  text_view .\nThis way  [Boost].DI  can inject appropriate dependencies into chosen types. See  bindings  for more details.  And full example!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nclass user {};\n\nclass app {\n public:\n  app(controller , user ) {}\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind int ().to(42) // renderer device\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_dynamic_bindings.cpp   Okay, so what about the input. We have  user , however, in the real life, we will have more clients. [Boost].DI  allows multiple bindings to the same type for  array/vector/set . Let's do it then!  class iclient {\n public:\n   virtual ~iclient() noexcept = default;\n   virtual void process() = 0;\n};\n\nclass user : public iclient {\n public:\n   void process() override {};\n};\n\nclass timer : public iclient {\n public:\n   void process() override {};\n};\n\nclass app {\n public:\n  app(controller , std::vector std::unique_ptr iclient );\n};  And our bindings...  di::bind iclient*[] .to user, client ()  And full example!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nclass user : public iclient {\n public:\n  void process() override{};\n};\n\nclass timer : public iclient {\n public:\n  void process() override{};\n};\n\nclass app {\n public:\n  app(controller , std::vector std::unique_ptr iclient  v) {\n    assert(2 == v.size());\n    assert(dynamic_cast user* (v[0].get()));\n    assert(dynamic_cast timer* (v[1].get()));\n  }\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind int ().to(42) // renderer device\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_multiple_bindings.cpp   The last but not least, sometimes, it's really useful to override some bindings. For example, for testing purposes.\nWith  [Boost].DI  you can easily do that with  override  specifier (Implemented using  operator[](override) ).  const auto injector = di::make_injector(\n  di::bind int .to(42) // renderer device\n, di::bind int .to(123) [di::override] // override renderer device\n);  Without the  di::override  following compilation error will occur...  boost/di.hpp:281:3: error: static_assert failed  constraint not satisfied \nboost/di.hpp:2683:80: type int ::is_bound_more_than_once\n  inline auto make_injector(TDeps... args) noexcept  And full example!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  , di::bind int ().to(42) // renderer device\n  , di::bind int ().to(123) [di::override] // override renderer device\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings_override.cpp   Check out also.    Bindings Example   Forward Bindings Example   Dynamic Bindings Example   Multiple Bindings Example   Constructor Bindings Extension", 
            "title": "2. [Basic] First steps with bindings"
        }, 
        {
            "location": "/tutorial/index.html#3-basic-decide-the-life-times", 
            "text": "So far so good but where are these objects stored?\nWell,  [Boost].DI  supports  scopes  which are response for maintaining the life time of created objects.\nBy default there are 4 scopes   deduce  scope (default)  instance  scope (bind .to(value) where value is maintained by the user)  unique  scope (one instance per request)  singleton  scope (shared instance)   By default  deduce  scope is used which means that scope is deduced based on a constructor parameter.\nFor instance, reference, shared_ptr will be deduced as  singleton  scope and pointer, unique_ptr will be deduced as  unique  scope.     Type  Scope      T  unique    T  singleton    const T  unique  (temporary) /  singleton    T*  unique  (ownership transfer)    const T*  unique  (ownership transfer)    T  unique    std::unique_ptr  unique    std::shared_ptr  singleton    boost::shared_ptr  singleton    std::weak_ptr  singleton     Example  class scopes_deduction {\n  scopes_deduction(const int  /*singleton scope*/,\n                   std::shared_ptr int  /*singleton scope*/,\n                   std::unique_ptr int  /*unique scope*/,\n                   int /*unique scope*/)\n  { }\n};\n\ndi::make_injector().create example (); // scopes will be deduced based on constructor parameter types  Coming back to our example, we got quite a few  singletons  there as we just needed one instance per application life time.\nAlthough scope deduction is very useful, it's not always what we need and therefore  [Boost].DI  allows changing the scope for a given type.  const auto injector = di::make_injector(\n  di::bind iview .to gui_view ().in(di::singleton) // explicitly specify singleton scope\n);  What if I want to change  gui_view  to be a different instance per each request. Let's change the scope to  unique  then.  const auto injector = di::make_injector(\n  di::bind iview .to gui_view ().in(di::unique)\n);  We will get a COMPILATION TIME ERROR because a unique scope can't be converted to a reference.\nIn other words, having a reference to a copy is forbidden and it won't compile!  warning: 'create app ' is deprecated: creatable constraint not satisfied\n  injector.create app ();\n           ^\nboost/di.hpp:897:2: error: 'scoped scopes::unique, gui_view ::is_not_convertible_to iview  ::error'\n  error(_ =  scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind T .in(scope)'? );  Ah, reference doesn't make much sense with  unique  scope because it would mean that it has to be stored somewhere.\nIt would be better to use  std::unique_ptr iview  instead.     Type/Scope  unique  singleton  instance      T  \u2714  -  \u2714    T  -  \u2714  \u2714    const T  \u2714 (temporary)  \u2714  \u2714    T* (transfer ownership)  \u2714  -  -    const T*  \u2714  -  -    T  \u2714  -  \u2714    std::unique_ptr  \u2714  -  -    std::shared_ptr  \u2714  \u2714  \u2714    boost::shared_ptr  \u2714  \u2714  - / \u2714 converted to    std::weak_ptr  -  \u2714  - / \u2714 converted to     Hmm, let's try something else then. We have list of unique clients, we can share objects just by changing the list to\nuse  std::shared_ptr  instead.  class app {\n public:\n  app(controller , std::vector std::shared_ptr iclient );\n};  But, it would be better if  timer  was always created per request, although it's a  shared_ptr .\nTo do so, we just need add scope when binding it, like this...  const auto injector = di::make_injector(\n  di::bind timer .in(di::unique) // different per request\n);  Check out the full example here.  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer ().in(di::unique) // different per request\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  , di::bind int ().to(42) // renderer device\n  , di::bind int ().to(123) [di::override] // override renderer device\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_decide_the_life_times.cpp   See also.    Deduce Scope Example   Scopes Example   Eager Singletons Example", 
            "title": "3. [Basic] Decide the life times"
        }, 
        {
            "location": "/tutorial/index.html#4-basic-annotations-to-the-rescue", 
            "text": "Above example are fine and dandy, nonetheless, they don't cover one important thing.\nHow  [Boost].DI  knows which constructor to choose and what if they are ambiguous?  Well, the algorithm is very simple. The longest (most parameters), unique constructor will be chosen.\nOtherwise,  [Boost].DI  will give up with a compile time error. However, which constructor should\nbe chosen is configurable by  BOOST_DI_INJECT .  To illustrate this, let's modify  model  constructor.  class model {\n public:\n   model(int size, double precision) { }\n   model(int rows, int cols) { }\n};  Right now, as expected, we get a compile time error!  warning: 'create app ' is deprecated: creatable constraint not satisfied\n  injector.create app ();\n           ^\nboost/di.hpp:942:4: error: 'type model ::has_ambiguous_number_of_constructor_parameters::error'\n  error(_ =  verify BOOST_DI_INJECT_TRAITS or di::ctor_traits );  Let's fix it using  BOOST_DI_INJECT  then!  class model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, int rows, int cols) { } // this constructor will be injected\n};    Note \nWe can also write  model(int rows, int cols, ...)  to get the same result.\nBy adding  ...  as the last parameter of the constructor it's guaranteed by [Boost].DI\nthat it will be used for injection as it will have the highest number of constructor parameters (infinite number).  Okay, right now it compiles but, wait a minute,  123  (renderer device) was injected for both  rows  and  cols !\nWell, it wasn't even close to what we wanted, but we can fix it easily using  named  annotations.  Firstly, we have to create names. That's easy as names are just unique objects.  auto Rows = []{};\nauto Cols = []{};  Secondly, we have to tell  model  constructor about it.  class model {\n public:\n   model(int size, double precision) { }\n   BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols); // this constructor will be injected\n};\n\nmodel::model(int rows, int cols) {}  Please, notice that we have separated  model  constructor definition and declaration to show that definition doesn't\nrequire named annotations.    Note \nIf you happen to use clang/gcc compiler you can use string literals instead of creating objects,\nfor example  (named = \"Rows\"_s) .  Finally, we have to bind our values.  const auto injector = di::make_injector(\n  di::bind int .named(Rows).to(6)\n, di::bind int .named(Cols).to(8)\n);  That's all.    Note \nThe same result might be accomplished with having different types for rows and cols.  Full example here.  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto Rows = [] {};\nauto Cols = [] {};\n\n\nclass model {\n public:\n  model(int /*size*/, double /*precision*/) {}\n  BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols);\n};\n\nmodel::model(int rows, int cols) {\n  assert(6 == rows);\n  assert(8 == cols);\n}\n\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer ().in(di::unique) // different per request\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  , di::bind int ().to(42) // renderer device\n  , di::bind int ().to(123) [di::override] // override renderer device\n  , di::bind int ().named(Rows).to(6)\n  , di::bind int ().named(Cols).to(8)\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_annotations_to_the_rescue.cpp   Check out also...    Constructor Injection Example   Constructor Signature Example   Annotations Example", 
            "title": "4. [Basic] Annotations to the rescue"
        }, 
        {
            "location": "/tutorial/index.html#5-basic-split-your-configuration", 
            "text": "But my project has hundreds of interfaces and I would like to split my bindings into separate components.\nThis is simple to do with [Boost.DI] as an  injector  can be extended by other injectors.  Let's split our configuration then and keep our  model  bindings separately from  app  bindings.  auto model_module = [] {\n  return di::make_injector(\n    di::bind int .named(Rows).to(6)\n  , di::bind int .named(Cols).to(8)\n  );\n};\n\nauto app_module = [](const bool  use_gui_view) {\n  return di::make_injector(\n    di::bind iview .to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer .in(di::unique) // different per request\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  );\n};  And glue them into one injector the same way...    const auto injector = di::make_injector(\n    model_module()\n  , app_module(use_gui_view)\n  );    Note \nGluing many  injector s into one is order independent.  And full example!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nauto model_module = [] {\n  return di::make_injector(\n    di::bind int ().named(Rows).to(6)\n  , di::bind int ().named(Cols).to(8)\n  );\n};\n\nauto app_module = [](const bool  use_gui_view) {\n  return di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer ().in(di::unique) // different per request\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  , di::bind int ().to(42) // renderer device\n  , di::bind int ().to(123) [di::override] // override renderer device\n  );\n};\n\nint main() {\n  auto use_gui_view = true;\n\n  auto injector = di::make_injector(\n    model_module()\n  , app_module(use_gui_view)\n  );\n\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration.cpp   But I would like to have a module in  cpp  file, how can I do that?\nSuch design might be achieved with  [Boost].DI  using  injector  and exposing given types.   Expose all types (default)   const const auto injector = // auto exposes all types\n  di::make_injector(\n    di::bind int .to(42)\n  , di::bind double .to(87.0)\n  );\n\ninjector.create int (); OK\ninjector.create double (); // OK   Expose only specific types   const di::injector int  injector = // only int is exposed\n  di::make_injector(\n    di::bind int .to(42)\n  , di::bind double .to(87.0)\n  );\n\ninjector.create int (); OK\ninjector.create double (); // COMPILE TIME ERROR, double is not exposed by the injector  When exposing all types using  auto  modules have to be implemented in a header file.\nWith  di::injector T...  a definition might be put in a cpp file as it\u2019s just a regular type.  Such approach has a few benefits:\n* It\u2019s useful for encapsulation (ex. Another team provides a module but they don't want to expose an ability to create implementation details)\n* May also speed compilation times in case of extend usage of cpp files    Note \nThere is no performance (compile-time, run-time) overhead between exposing all types or just a specific ones.  Moving back to our example. Let's refactor it then.  di::injector model  model_module() {\n  return di::make_injector(\n    di::bind int .named(Rows).to(6)\n  , di::bind int .named(Cols).to(8)\n  );\n}\n\ndi::injector app  app_module(const bool  use_gui_view) {\n  return di::make_injector(\n    di::bind iview .to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer .in(di::unique) // different per request\n  , di::bind iclient*[] .to user, timer () // bind many clients\n  , model_module()\n  );\n}  Right now you can easily separate definition and declaration between  hpp  and  cpp  files.  Check the full example here!  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto Rows = [] {};\nauto Cols = [] {};\n\n\ndi::injector model  model_module() {\n  return di::make_injector(\n    di::bind int ().named(Rows).to(6)\n  , di::bind int ().named(Cols).to(8)\n  );\n}\n\ndi::injector app  app_module(const bool  use_gui_view) {\n  return di::make_injector(\n    di::bind iview ().to([ ](const auto  injector) -  iview  {\n      if (use_gui_view)\n        return injector.template create gui_view ();\n      else\n        return injector.template create text_view ();\n    })\n  , di::bind timer ().in(di::unique) // different per request\n  , di::bind iclient*[] ().to user, timer () // bind many clients\n  , di::bind int ().to(42) // renderer device\n  , di::bind int ().to(123) [di::override] // override renderer device\n  , model_module()\n  );\n}\n\nint main() {\n  auto use_gui_view = true;\n  auto injector = app_module(use_gui_view);\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration_expose.cpp     Note \nYou can also expose named parameters using  di::injector BOOST_DI_EXPOSE((named = Rows) int) .\nDifferent variations of the same type have to be exposed explicitly using  di::injector model , std::unique_ptr model .\nType erasure is used under the hood when types are exposed explicitly ( di::injector T\u2026 ).  Check out more examples here!    Modules Example   Exposed Annotated Type Example   Exposed Complex Types Example    Congrats! You have finished the basic part of the tutorial.\nHopefully, you have noticed potential of DI and  [Boost].DI  but if are still not convinced check out the  Advanced  part.", 
            "title": "5. [Basic] Split your configuration"
        }, 
        {
            "location": "/tutorial/index.html#6-advanced-dumplimit-your-types", 
            "text": "It's often a case that we would like to generate object diagram of our application in order to see code dependencies\nmore clear. Usually, it's a really hard task as creation of objects may happen anywhere in the code. However,\nif the responsibility for creation  objects will be given to  [Boost].DI  we get such functionality for free.\nThe only thing we have to do is to implement how to dump our objects.  Let's dump our dependencies using  Plant UML  format.  #include  boost/di/extension/policies/uml_dumper.hpp \n\n#include  memory \n\nnamespace di = boost::di;\n\n\nint main() {\n  /* define injector */\n  auto injector = di::make_injector di::extension::uml_dumper (\n    di::bind i0 ().to c0 ()\n  , di::bind int ().named(int_1).to(42)\n  , di::bind int ().named(int_2).to(42)\n  );\n\n  /* iterate through created objects with `types_dumper` */\n  injector.create c3 ();\n\n  /* output [@images/uml_dumper.png [$images/uml_dumper.png [width 75%] [height 75%] ]] */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/uml_dumper.cpp    See also.   \n*   Custom Policy Example \n*   Types Dumper Extension   On the other hand, it would be great to be able to limit types which might be constructed. For example, we just want to allow\nsmart pointers and disallow raw pointers too. We may want to have a  view  only with const parameters being passed, etc. [Boost].DI  allows you to do so by using  constructible  policy or writing a custom  policy .  class all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include  boost/di.hpp \n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same di::_, int {} || is_bound di::_ {}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create int ());\n  // di::make_injector().create double (); // compile error\n  assert(42.0 == make_injector(di::bind double ().to(42.0)).create double ());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_global.cpp   See also.    Constructible Example", 
            "title": "6. [Advanced] Dump/Limit your types"
        }, 
        {
            "location": "/tutorial/index.html#7-advanced-customize-it", 
            "text": "[Boost].DI  was design having extensibility in mind. You can easily customize   scopes  - to have custom life time of an object  providers  - to have custom way of creating objects, for example by using preallocated memory   policies  - to have custom way of dumping types at run-time or limiting them at compile-time     Custom Policy Example    Custom Provider Example   Pool Provider Example", 
            "title": "7. [Advanced] Customize it"
        }, 
        {
            "location": "/tutorial/index.html#8-advanced-extend-it", 
            "text": "As mentioned before,  [Boost].DI  is quite easy to extend and therefore a lot of extensions exists already.\nPlease check them out and write your own!   Constructor Bindings  Assisted Injection  Concepts  Lazy  Named Parameters  XML Injection  Types Dumper  UML Dumper  Mocks Provider  Scoped Scope  Session Scope  Shared Scope", 
            "title": "8. [Advanced] Extend it"
        }, 
        {
            "location": "/try_it/index.html", 
            "text": "#include \nboost/di.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace di = boost::di;\n\n\nstruct iworld {\n  virtual ~iworld() noexcept = default;\n};\n\nstruct world : iworld {\n  world() { std::cout \n \n world!\n \n std::endl; }\n};\n\nstruct hello {\n  explicit hello(int i) {\n    assert(42 == i);\n    std::cout \n \nhello\n;\n  }\n};\n\ntemplate \nclass T = class Greater\n\nstruct example {\n  T h;\n  iworld\n w;\n};\n\nint main() {\n  const auto injector = di::make_injector(\n     di::bind\niworld\n().to\nworld\n()    // bind interface to implementation\n   , di::bind\n().to(42)               // bind int to value 42\n   , di::bind\nclass Greater\n().to\nhello\n()   // bind template to type\n  );\n\n  /*\ncreate `example`\n*/\n  injector.create\nexample\n(); // or di::create\nexample\n(injector)\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/try_it.cpp", 
            "title": "Try It Online!"
        }, 
        {
            "location": "/benchmarks/index.html", 
            "text": "Performance\n\n\n\n\nRun-time performance\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\nclang++3.4 -O2 -fno-exceptions / \ngdb -batch -ex 'file ./a.out' -ex 'disassemble main'\n\n\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto test() {\n  auto injector = di::make_injector();\n  return injector.create\nint\n();\n}\n\n/**\n * ASM x86-64 (same as `return 0`)\n *\n * xor %eax,%eax\n * retq\n */\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  );\n\n  return injector.create\nint\n();\n}\n\n/**\n * ASM x86-64 (same as `return 42`)\n *\n * mov $0x2a,%eax\n * retq\n */\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto my_int = [] {};\n\nstruct c {\n  BOOST_DI_INJECT(c, (named = my_int) int i) : i(i) {}\n  int i = 0;\n};\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(my_int).to(42)\n  );\n\n  return injector.create\nc\n().i;\n}\n\n/**\n * ASM x86-64 (same as `return 42`)\n *\n * mov $0x2a,%eax\n * retq\n */\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind\ninterface\n().to\nimplementation\n()\n  );\n\n  return injector.create\nstd::unique_ptr\ninterface\n();\n}\n\n/**\n * ASM x86-64 (same as `std::make_unique\nimplementation\n()`)\n *\n * push   %rbx\n * mov    %rdi,%rbx\n * mov    $0x8,%edi\n * callq  0x4009f0 \n_Znwm@plt\n\n * movq   $0x400e78,(%rax)\n * mov    %rax,(%rbx)\n * mov    %rbx,%rax\n * pop    %rbx\n * retq\n */\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind\ninterface\n().to\nimplementation\n()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create\nstd::unique_ptr\ninterface\n();\n}\n\n/**\n * ASM x86-64 (same as `std::make_unique\nimplementation\n()`)\n *\n * push   %rbx\n * mov    %rdi,%rbx\n * mov    $0x8,%edi\n * callq  0x4008e0 \n_Znwm@plt\n\n * movq   $0x400c78,(%rax)\n * mov    %rax,(%rbx)\n * mov    %rbx,%rax\n * pop    %rbx\n * retq\n */\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nauto module = []() -\n di::injector\nstd::unique_ptr\ninterface\n {\n  return di::make_injector(\n    di::bind\ninterface\n().to\nimplementation\n()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create\nstd::unique_ptr\ninterface\n();\n}\n\n/**\n * ASM x86-64 (additional cost for type erasure)\n *\n * push   %r14\n * push   %rbx\n * push   %rax\n * mov    %rdi,%r14\n * mov    $0x18,%edi\n * callq  0x4008e0 \n_Znwm@plt\n\n * mov    %rax,%rbx\n * movq   $0x400bb0,(%rbx)\n * movq   $0x400bd0,0x8(%rbx)\n * mov    $0x8,%edi\n * callq  0x4008e0 \n_Znwm@plt\n\n * movq   $0x400cd8,(%rax)\n * mov    %rax,(%r14)\n * mov    %rbx,%rdi\n * callq  *0x8(%rbx)\n * mov    %rbx,%rdi\n * callq  0x400880 \n_ZdlPv@plt\n\n * mov    %r14,%rax\n * add    $0x8,%rsp\n * pop    %rbx\n * pop    %r14\n * retq\n */\n\n\n\n\n\n\n\nCompile-time performance\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\nclang++3.4 -O2 -fno-exceptions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[Boost].DI header\n\n\nTime [s]\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\n0.050s\n\n\n\n\n\n\n\n\nLegend:\n    ctor    = raw constructor: T(int i, double d);\n    inject  = inject constructor: BOOST_DI_INJECT(T, int i, double d);\n    all     = all types exposed from module: auto configure();\n    exposed = one type exposed from module: di::injector\nT\n configure();\n\n\n\n\n\n\n* 4248897537 instances created\n* 132 different types\n* 10 modules\n\n\n\n\n\n\n\n\n* 1862039751439806464 instances created\n* 200 different types\n* 10 modules\n\n\n\n\n\n\n\n\n* 5874638529236910091 instances created\n* 310 different types\n* 100 different interfaces\n* 10 modules\n\n\n\n\nC++ Libraries\n\n\n\n\n\n\n\n\nLibrary\n\n\n[Boost].DI (\nSee Performance\n)\n\n\ndicpp\n\n\nGoogle.Fruit\n\n\n\n\n\n\n\n\n\n\nVersion\n\n\n1.0.1\n\n\nHEAD\n\n\n2.0.2\n\n\n\n\n\n\nLanguage\n\n\nC++14\n\n\nC++11\n\n\nC++11\n\n\n\n\n\n\nLicense\n\n\nBoost 1.0\n\n\nBoost 1.0\n\n\nApache 2.0\n\n\n\n\n\n\nLinkage\n\n\nheader only\n\n\nheader only\n\n\nlibrary\n\n\n\n\n\n\nDependencies\n\n\n-\n\n\nboost system/boost thread\n\n\n-\n\n\n\n\n\n\nApproach\n\n\ncompile-time\n\n\nrun-time\n\n\ncompile/run-time\n\n\n\n\n\n\nErrors\n\n\ncompile-time errors\n\n\nexceptions\n\n\ncompile-time errors/exceptions\n\n\n\n\n\n\n\n\n\n\nTo run benchmarks\n\n\n\n\ncd benchmark \n make\n\n\n\n\n\n\nC++ vs Java vs C# Libraries\n\n\n\n\n\n\n\n\nLibrary\n\n\n[Boost].DI\n\n\nGoogle.Guice\n\n\nDagger2\n\n\nNinject\n\n\n\n\n\n\n\n\n\n\nLanguage\n\n\nC++14\n\n\nJava\n\n\nJava\n\n\nC#\n\n\n\n\n\n\nVersion\n\n\n1.0.1\n\n\n4.0\n\n\n2.4\n\n\n3.2\n\n\n\n\n\n\nLicense\n\n\nBoost 1.0\n\n\nApache 2.0\n\n\nApache 2.0\n\n\nApache 2.0\n\n\n\n\n\n\nLinkage\n\n\nheader only\n\n\njar\n\n\njar\n\n\ndll\n\n\n\n\n\n\nApproach\n\n\ncompile-time\n\n\nrun-time\n\n\ncompile-time (annotation processor)\n\n\nrun-time\n\n\n\n\n\n\nErrors\n\n\ncompile-time errors\n\n\nexceptions\n\n\ncompile-time errors\n\n\nexceptions\n\n\n\n\n\n\n\n\n\n\nEnvironment\n\n\nx86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux\n\n\n$CXX -O2/Java8/Mono4.2\n\n\n\n\n\n\n\n\n\n\n\n\nBaseline\n\n\nManual object creation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate a unique objects tree for each iteration\nTYPES: 64\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7 -O2 / Java8 / Mono4.2 --aot\n\n\nBaseline\n\n\n[Boost].DI\n\n\nGoogle.Fruit\n\n\nGoogle.Guice\n\n\nDagger2\n\n\nNinject\n\n\n\n\n\n\nCompilation time\n\n\n0.063s\n\n\n0.376s\n\n\n2.329s / FRUIT_NO_LOOP_CHECK\n\n\n0.570s\n\n\n1.411s\n\n\n0.144s + 0.079s\n\n\n\n\n\n\nExecutable size\n\n\n4.2K\n\n\n8.5K\n\n\n213K\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.002s\n\n\n0.002s\n\n\n0.037s\n\n\n0.528s\n\n\n0.157s\n\n\n1.131s\n\n\n\n\n\n\nTYPES: 128\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.082s\n\n\n0.706s\n\n\n4.375s / FRUIT_NO_LOOP_CHECK\n\n\n0.642s\n\n\n1.903s\n\n\n0.149s + 0.093s\n\n\n\n\n\n\nExecutable size\n\n\n4.2K\n\n\n8.5K\n\n\n513K\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.002s\n\n\n0.002s\n\n\n0.074s\n\n\n0.544s\n\n\n0.210s\n\n\n2.230s\n\n\n\n\n\n\nTYPES: 256\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.131s\n\n\n1.328s\n\n\n9.641s / FRUIT_NO_LOOP_CHECK\n\n\n0.783s\n\n\n2.814s\n\n\n0.151s + 0.114s\n\n\n\n\n\n\nExecutable size\n\n\n4.2K\n\n\n8.7K\n\n\n1.4M\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.003s\n\n\n0.003s\n\n\n0.154s\n\n\n0.723s\n\n\n0.323s\n\n\n4.838s\n\n\n\n\n\n\nTYPES: 512\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.215s\n\n\n2.459s\n\n\n23.924s / FRUIT_NO_LOOP_CHECK\n\n\n1.054s\n\n\n4.231s\n\n\n0.157s + 0.161\n\n\n\n\n\n\nExecutable size\n\n\n8.2K\n\n\n13K\n\n\n4.2M\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.003s\n\n\n0.003s\n\n\n0.328s\n\n\n0.943s\n\n\n0.547s\n\n\n11.123s\n\n\n\n\n\n\nTYPES: 1024\n  \nBINDINGS: 0\n  \nITERATIONS: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.402s\n\n\n4.911s\n\n\n1m9.601s / FRUIT_NO_LOOP_CHECK\n\n\n1.357s\n\n\n5.943s\n\n\n0.167s + 0.258\n\n\n\n\n\n\nExecutable size\n\n\n12K\n\n\n17K\n\n\n15M\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nExecution time\n\n\n0.004s\n\n\n0.004s\n\n\n0.765s\n\n\n1.334s\n\n\n0.998s\n\n\n21.808s\n\n\n\n\n\n\n\n\n\n\nTo run benchmarks\n\n\n\n\ncd benchmark \n make\n\n\n\n\n\n\nUsage of C++ vs Java vs C# Libraries\n\n\n\n\n\n\n\n\nLibrary\n\n\nBind Interface\n\n\nPerformance\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  void dummy() override {}\n};\n\nauto module = [] {\n  return di::make_injector(\n    di::bind\nI\n.to\nImpl\n()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create\nstd::unique_ptr\nI\n();\n}\n\n\n\n\n\n#include \ndi/registry.hpp\n\n#include \ndi/injector.hpp\n\n#include \ndi/constructor.hpp\n\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  DI_CONSTRUCTOR(Impl, ()) {}\n  void dummy() override {}\n};\n\nvoid module(di::registry\n r) {\n  r.add(r.type\nI\n().implementation\nImpl\n());\n}\n\nstd::unique_ptr\nI\n test() {\n  di::injector injector;\n  injector.install(module);\n  std::unique_ptr\nI\n object{injector.construct\nI*\n()};\n  return object;\n}\n\n\n\n\n\n#include \nfruit/fruit.h\n\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  INJECT(Impl()) {}\n  void dummy() override {}\n};\n\nfruit::Component\nI\n module() {\n  return fruit::createComponent()\n    .bind\nI, Impl\n();\n}\n\nstd::unique_ptr\nI\n test() {\n  fruit::Injector\nI\n injector{module()};\n  // get\nunique_ptr\n is not supported\n  std::unique_ptr\nI\n object{injector.get\nI*\n()};\n  return object;\n}\n\n\n\n\n\nimport com.google.inject.*;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    bind(I.class).to(Impl.class);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    I object = injector.getInstance(I.class);\n  }\n}\n\n\n\n\nimport dagger.*;\nimport javax.inject.Inject;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\n@Module\nclass AppModule {\n  @Provides I provideI(Impl impl) { return impl; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  I build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    I object = Dagger_AppComponent.create().build();\n   }\n}\n\n\n\n\nusing Ninject;\n\ninterface I {\n  void dummy();\n};\n\nclass Impl : I {\n  public Impl() { }\n  void I.dummy() { }\n}\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    Bind\nI\n().To\nImpl\n();\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    I object = kernel.Get\nI\n();\n  }\n}\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nBind Value\n\n\nPerformance\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto module = [] {\n  return di::make_injector(\n    di::bind\n.to(42)\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create\nint\n();\n}\n\n\n\n\n\n#include \ndi/registry.hpp\n\n#include \ndi/injector.hpp\n\n\nvoid module(di::registry\n r) {\n  r.add(r.type\nint\n().instance(new int{42}));\n}\n\nauto test() {\n  di::injector injector;\n  injector.install(module);\n  return injector.construct\nint\n();\n}\n\n\n\n\n\n#include \nfruit/fruit.h\n\n\nauto i = 42;  // bindInstance doesn't support l-value's\n\nfruit::Component\nint\n module() {\n  return fruit::createComponent().bindInstance(i);\n}\n\nauto test() {\n  fruit::Injector\nint\n injector{module()};\n  return injector.get\nint\n();\n}\n\n\n\n\n\nimport com.google.inject.*;\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    bind(int.class).toInstance(42);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    injector.getInstance(int.class);\n  }\n}\n\n\n\n\nimport dagger.*;\n\n@Module\nclass AppModule {\n  @Provides int provideint() { return 42; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  int build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    Dagger_AppComponent.create().build();\n  }\n}\n\n\n\n\nusing Ninject;\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    Bind\nint\n().To(42);\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    kernel.Get\nint\n();\n  }\n}\n\n\n\n\n\n\n\n\n\n\nLibrary\n\n\nMissing Bindings Error\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  void dummy() override {}\n};\n\nauto module = [] {\n  return di::make_injector(\n    // di::bind\nI\n.to\nImpl\n()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  std::unique_ptr\nI\n object{injector.create\nI *\n()};\n  object-\ndummy();\n}\n\n/**\n * di.cpp:32:38: warning: 'create\nI *, 0\n' is deprecated: creatable constraint not satisfied\n *   std::unique_ptr\nI\n object{injector.create\nI *\n()};\n *                                      ^\n * boost/di.hpp:2420:3: note: 'create\nI *, 0\n' has been explicitly marked deprecated here\n *   create\n *   ^\n * boost/di.hpp:871:2: error: 'boost::di::v1_0_0::concepts::abstract_type\nI\n::is_not_bound::error'\n *  error(_ = \ntype is not bound, did you forget to add: 'di::bind\ninterface\n.to\nimplementation\n()'?\n);\n *  ^\n */\n\n\n\n\n#include \ndi/registry.hpp\n\n#include \ndi/injector.hpp\n\n#include \ndi/constructor.hpp\n\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  DI_CONSTRUCTOR(Impl, ()) {}\n  void dummy() override {}\n};\n\nvoid module(di::registry\n r) {\n  // r.add(r.type\nI\n().implementation\nImpl\n());\n}\n\nint main() {\n  di::injector injector;\n  injector.install(module);\n  std::unique_ptr\nI\n object{injector.construct\nI*\n()};\n  object-\ndummy();\n}\n\n/**\n * terminate called after throwing an instance of 'std::runtime_error'\n * what():  Requested type without corresponding provider: di::type_key\nI*, void\n.\n * Double check if the type is abstract\n */\n\n\n\n\n#include \nfruit/fruit.h\n\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  INJECT(Impl()) {}\n  void dummy() override {}\n};\n\nfruit::Component\nI\n module() {\n  return fruit::createComponent();\n  //.bind\nI, Impl\n();\n}\n\nint main() {\n  fruit::Injector\nI\n injector{module()};\n  std::unique_ptr\nI\n object{injector.get\nI*\n()};\n  object-\ndummy();\n}\n\n/**\n  *  In file included from fruit.cpp:1:\n  *  In file included from .fruit/include/fruit/fruit.h:25:\n  * fruit/include/fruit/impl/injection_errors.h:33:3: error: static_assert failed\n  * \nNo explicit binding nor C::Inject definition was found for T.\n\n  *  static_assert(AlwaysFalse\nT\n::value,\n  * ^             ~~~~~~~~~~~~~~~~~~~~~\n  * fruit/include/fruit/impl/component.defn.h:41:9: note: in instantiation of\n  * 'fruit::impl::NoBindingFoundError\nI\n' requested here\n  * (void)typename fruit::impl::meta::CheckIfError\ntypename Op::Result\n::type();\n  * ^\n  *  fruit.cpp:6:12: note: in instantiation of function template specialization\n  *  'fruit::Component\nI\n::Component\n\n  *    fruit::impl::meta::ConsComp\n\n  *    fruit::impl::meta::Vector\n*,\n  *    fruit::impl::meta::Vector\n,\n  *    fruit::impl::meta::Vector\n, \n  *    fruit::impl::meta::Vector\n,\n  *    fruit::impl::meta::Vector\n\n  *    \n*\n' requested here\n  *  return fruit::createComponent();\n  */\n\n\n\n\nimport com.google.inject.*;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    //bind(I.class).to(Impl.class);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    I object = injector.getInstance(I.class);\n    object.dummy();\n  }\n}\n\n/**\n  * Exception in thread \nmain\n com.google.inject.ConfigurationException:\n  * Guice configuration errors:\n  *\n  * 1) No implementation for I was bound.\n  * while locating I\n  *\n  * 1 error\n  * at com.google.inject.internal.InjectorImpl.getProvider(InjectorImpl.java:1042)\n  * at com.google.inject.internal.InjectorImpl.getProvider(InjectorImpl.java:1001)\n  * at com.google.inject.internal.InjectorImpl.getInstance(InjectorImpl.java:1051)\n  * at guice.main(guice.java:15)\n  *\n */\n\n\n\n\nimport dagger.*;\nimport javax.inject.Inject;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\n@Module\nclass AppModule {\n  //@Provides I provideI(Impl impl) { return impl; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  I build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    I object = Dagger_AppComponent.create().build();\n    object.dummy();\n   }\n}\n\n/**\n * dagger2.java:13: error: I cannot be provided without an @Provides-annotated method.\n * I build();\n *   ^\n * 1 error\n */\n\n\n\n\nusing Ninject;\n\ninterface I {\n  void dummy();\n};\n\nclass Impl : I {\n  public Impl() { }\n  void I.dummy() { }\n}\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    //Bind\nI\n().To\nImpl\n();\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    I object = kernel.Get\nI\n();\n    object-\ndummy();\n  }\n}\n\n/**\n */", 
            "title": "Benchmarks"
        }, 
        {
            "location": "/benchmarks/index.html#performance", 
            "text": "Run-time performance  Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  clang++3.4 -O2 -fno-exceptions /  gdb -batch -ex 'file ./a.out' -ex 'disassemble main'       #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto test() {\n  auto injector = di::make_injector();\n  return injector.create int ();\n}\n\n/**\n * ASM x86-64 (same as `return 0`)\n *\n * xor %eax,%eax\n * retq\n */  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  );\n\n  return injector.create int ();\n}\n\n/**\n * ASM x86-64 (same as `return 42`)\n *\n * mov $0x2a,%eax\n * retq\n */  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto my_int = [] {};\n\nstruct c {\n  BOOST_DI_INJECT(c, (named = my_int) int i) : i(i) {}\n  int i = 0;\n};\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind int ().named(my_int).to(42)\n  );\n\n  return injector.create c ().i;\n}\n\n/**\n * ASM x86-64 (same as `return 42`)\n *\n * mov $0x2a,%eax\n * retq\n */  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nauto test() {\n  auto injector = di::make_injector(\n    di::bind interface ().to implementation ()\n  );\n\n  return injector.create std::unique_ptr interface ();\n}\n\n/**\n * ASM x86-64 (same as `std::make_unique implementation ()`)\n *\n * push   %rbx\n * mov    %rdi,%rbx\n * mov    $0x8,%edi\n * callq  0x4009f0  _Znwm@plt \n * movq   $0x400e78,(%rax)\n * mov    %rax,(%rbx)\n * mov    %rbx,%rax\n * pop    %rbx\n * retq\n */  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind interface ().to implementation ()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create std::unique_ptr interface ();\n}\n\n/**\n * ASM x86-64 (same as `std::make_unique implementation ()`)\n *\n * push   %rbx\n * mov    %rdi,%rbx\n * mov    $0x8,%edi\n * callq  0x4008e0  _Znwm@plt \n * movq   $0x400c78,(%rax)\n * mov    %rax,(%rbx)\n * mov    %rbx,%rax\n * pop    %rbx\n * retq\n */  #include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nauto module = []() -  di::injector std::unique_ptr interface  {\n  return di::make_injector(\n    di::bind interface ().to implementation ()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create std::unique_ptr interface ();\n}\n\n/**\n * ASM x86-64 (additional cost for type erasure)\n *\n * push   %r14\n * push   %rbx\n * push   %rax\n * mov    %rdi,%r14\n * mov    $0x18,%edi\n * callq  0x4008e0  _Znwm@plt \n * mov    %rax,%rbx\n * movq   $0x400bb0,(%rbx)\n * movq   $0x400bd0,0x8(%rbx)\n * mov    $0x8,%edi\n * callq  0x4008e0  _Znwm@plt \n * movq   $0x400cd8,(%rax)\n * mov    %rax,(%r14)\n * mov    %rbx,%rdi\n * callq  *0x8(%rbx)\n * mov    %rbx,%rdi\n * callq  0x400880  _ZdlPv@plt \n * mov    %r14,%rax\n * add    $0x8,%rsp\n * pop    %rbx\n * pop    %r14\n * retq\n */   Compile-time performance  Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  clang++3.4 -O2 -fno-exceptions          [Boost].DI header  Time [s]      #include  boost/di.hpp  0.050s     Legend:\n    ctor    = raw constructor: T(int i, double d);\n    inject  = inject constructor: BOOST_DI_INJECT(T, int i, double d);\n    all     = all types exposed from module: auto configure();\n    exposed = one type exposed from module: di::injector T  configure();   * 4248897537 instances created\n* 132 different types\n* 10 modules    * 1862039751439806464 instances created\n* 200 different types\n* 10 modules    * 5874638529236910091 instances created\n* 310 different types\n* 100 different interfaces\n* 10 modules", 
            "title": "Performance"
        }, 
        {
            "location": "/benchmarks/index.html#c-libraries", 
            "text": "Library  [Boost].DI ( See Performance )  dicpp  Google.Fruit      Version  1.0.1  HEAD  2.0.2    Language  C++14  C++11  C++11    License  Boost 1.0  Boost 1.0  Apache 2.0    Linkage  header only  header only  library    Dependencies  -  boost system/boost thread  -    Approach  compile-time  run-time  compile/run-time    Errors  compile-time errors  exceptions  compile-time errors/exceptions      To run benchmarks   cd benchmark   make", 
            "title": "C++ Libraries"
        }, 
        {
            "location": "/benchmarks/index.html#c-vs-java-vs-c-libraries", 
            "text": "Library  [Boost].DI  Google.Guice  Dagger2  Ninject      Language  C++14  Java  Java  C#    Version  1.0.1  4.0  2.4  3.2    License  Boost 1.0  Apache 2.0  Apache 2.0  Apache 2.0    Linkage  header only  jar  jar  dll    Approach  compile-time  run-time  compile-time (annotation processor)  run-time    Errors  compile-time errors  exceptions  compile-time errors  exceptions      Environment  x86_64 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz GenuineIntel GNU/Linux  $CXX -O2/Java8/Mono4.2       Baseline  Manual object creation        Create a unique objects tree for each iteration TYPES: 64    BINDINGS: 0    ITERATIONS: 1024            Clang-3.7 -O2 / Java8 / Mono4.2 --aot  Baseline  [Boost].DI  Google.Fruit  Google.Guice  Dagger2  Ninject    Compilation time  0.063s  0.376s  2.329s / FRUIT_NO_LOOP_CHECK  0.570s  1.411s  0.144s + 0.079s    Executable size  4.2K  8.5K  213K  -  -  -    Execution time  0.002s  0.002s  0.037s  0.528s  0.157s  1.131s    TYPES: 128    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.082s  0.706s  4.375s / FRUIT_NO_LOOP_CHECK  0.642s  1.903s  0.149s + 0.093s    Executable size  4.2K  8.5K  513K  -  -  -    Execution time  0.002s  0.002s  0.074s  0.544s  0.210s  2.230s    TYPES: 256    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.131s  1.328s  9.641s / FRUIT_NO_LOOP_CHECK  0.783s  2.814s  0.151s + 0.114s    Executable size  4.2K  8.7K  1.4M  -  -  -    Execution time  0.003s  0.003s  0.154s  0.723s  0.323s  4.838s    TYPES: 512    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.215s  2.459s  23.924s / FRUIT_NO_LOOP_CHECK  1.054s  4.231s  0.157s + 0.161    Executable size  8.2K  13K  4.2M  -  -  -    Execution time  0.003s  0.003s  0.328s  0.943s  0.547s  11.123s    TYPES: 1024    BINDINGS: 0    ITERATIONS: 1024          Compilation time  0.402s  4.911s  1m9.601s / FRUIT_NO_LOOP_CHECK  1.357s  5.943s  0.167s + 0.258    Executable size  12K  17K  15M  -  -  -    Execution time  0.004s  0.004s  0.765s  1.334s  0.998s  21.808s      To run benchmarks   cd benchmark   make", 
            "title": "C++ vs Java vs C# Libraries"
        }, 
        {
            "location": "/benchmarks/index.html#usage-of-c-vs-java-vs-c-libraries", 
            "text": "Library  Bind Interface  Performance            #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  void dummy() override {}\n};\n\nauto module = [] {\n  return di::make_injector(\n    di::bind I .to Impl ()\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create std::unique_ptr I ();\n}  #include  di/registry.hpp \n#include  di/injector.hpp \n#include  di/constructor.hpp \n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  DI_CONSTRUCTOR(Impl, ()) {}\n  void dummy() override {}\n};\n\nvoid module(di::registry  r) {\n  r.add(r.type I ().implementation Impl ());\n}\n\nstd::unique_ptr I  test() {\n  di::injector injector;\n  injector.install(module);\n  std::unique_ptr I  object{injector.construct I* ()};\n  return object;\n}  #include  fruit/fruit.h \n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  INJECT(Impl()) {}\n  void dummy() override {}\n};\n\nfruit::Component I  module() {\n  return fruit::createComponent()\n    .bind I, Impl ();\n}\n\nstd::unique_ptr I  test() {\n  fruit::Injector I  injector{module()};\n  // get unique_ptr  is not supported\n  std::unique_ptr I  object{injector.get I* ()};\n  return object;\n}  import com.google.inject.*;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    bind(I.class).to(Impl.class);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    I object = injector.getInstance(I.class);\n  }\n}  import dagger.*;\nimport javax.inject.Inject;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\n@Module\nclass AppModule {\n  @Provides I provideI(Impl impl) { return impl; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  I build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    I object = Dagger_AppComponent.create().build();\n   }\n}  using Ninject;\n\ninterface I {\n  void dummy();\n};\n\nclass Impl : I {\n  public Impl() { }\n  void I.dummy() { }\n}\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    Bind I ().To Impl ();\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    I object = kernel.Get I ();\n  }\n}     Library  Bind Value  Performance            #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto module = [] {\n  return di::make_injector(\n    di::bind .to(42)\n  );\n};\n\nauto test() {\n  auto injector = di::make_injector(module());\n  return injector.create int ();\n}  #include  di/registry.hpp \n#include  di/injector.hpp \n\nvoid module(di::registry  r) {\n  r.add(r.type int ().instance(new int{42}));\n}\n\nauto test() {\n  di::injector injector;\n  injector.install(module);\n  return injector.construct int ();\n}  #include  fruit/fruit.h \n\nauto i = 42;  // bindInstance doesn't support l-value's\n\nfruit::Component int  module() {\n  return fruit::createComponent().bindInstance(i);\n}\n\nauto test() {\n  fruit::Injector int  injector{module()};\n  return injector.get int ();\n}  import com.google.inject.*;\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    bind(int.class).toInstance(42);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    injector.getInstance(int.class);\n  }\n}  import dagger.*;\n\n@Module\nclass AppModule {\n  @Provides int provideint() { return 42; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  int build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    Dagger_AppComponent.create().build();\n  }\n}  using Ninject;\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    Bind int ().To(42);\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    kernel.Get int ();\n  }\n}     Library  Missing Bindings Error           #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  void dummy() override {}\n};\n\nauto module = [] {\n  return di::make_injector(\n    // di::bind I .to Impl ()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  std::unique_ptr I  object{injector.create I * ()};\n  object- dummy();\n}\n\n/**\n * di.cpp:32:38: warning: 'create I *, 0 ' is deprecated: creatable constraint not satisfied\n *   std::unique_ptr I  object{injector.create I * ()};\n *                                      ^\n * boost/di.hpp:2420:3: note: 'create I *, 0 ' has been explicitly marked deprecated here\n *   create\n *   ^\n * boost/di.hpp:871:2: error: 'boost::di::v1_0_0::concepts::abstract_type I ::is_not_bound::error'\n *  error(_ =  type is not bound, did you forget to add: 'di::bind interface .to implementation ()'? );\n *  ^\n */  #include  di/registry.hpp \n#include  di/injector.hpp \n#include  di/constructor.hpp \n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  DI_CONSTRUCTOR(Impl, ()) {}\n  void dummy() override {}\n};\n\nvoid module(di::registry  r) {\n  // r.add(r.type I ().implementation Impl ());\n}\n\nint main() {\n  di::injector injector;\n  injector.install(module);\n  std::unique_ptr I  object{injector.construct I* ()};\n  object- dummy();\n}\n\n/**\n * terminate called after throwing an instance of 'std::runtime_error'\n * what():  Requested type without corresponding provider: di::type_key I*, void .\n * Double check if the type is abstract\n */  #include  fruit/fruit.h \n\nstruct I {\n  virtual ~I() noexcept = default;\n  virtual void dummy() = 0;\n};\nstruct Impl : I {\n  INJECT(Impl()) {}\n  void dummy() override {}\n};\n\nfruit::Component I  module() {\n  return fruit::createComponent();\n  //.bind I, Impl ();\n}\n\nint main() {\n  fruit::Injector I  injector{module()};\n  std::unique_ptr I  object{injector.get I* ()};\n  object- dummy();\n}\n\n/**\n  *  In file included from fruit.cpp:1:\n  *  In file included from .fruit/include/fruit/fruit.h:25:\n  * fruit/include/fruit/impl/injection_errors.h:33:3: error: static_assert failed\n  *  No explicit binding nor C::Inject definition was found for T. \n  *  static_assert(AlwaysFalse T ::value,\n  * ^             ~~~~~~~~~~~~~~~~~~~~~\n  * fruit/include/fruit/impl/component.defn.h:41:9: note: in instantiation of\n  * 'fruit::impl::NoBindingFoundError I ' requested here\n  * (void)typename fruit::impl::meta::CheckIfError typename Op::Result ::type();\n  * ^\n  *  fruit.cpp:6:12: note: in instantiation of function template specialization\n  *  'fruit::Component I ::Component \n  *    fruit::impl::meta::ConsComp \n  *    fruit::impl::meta::Vector *,\n  *    fruit::impl::meta::Vector ,\n  *    fruit::impl::meta::Vector , \n  *    fruit::impl::meta::Vector ,\n  *    fruit::impl::meta::Vector \n  *     * ' requested here\n  *  return fruit::createComponent();\n  */  import com.google.inject.*;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\nclass Module extends AbstractModule {\n  @Override\n  protected void configure() {\n    //bind(I.class).to(Impl.class);\n  }\n}\n\npublic class guice {\n  public static void main(String[] args) {\n    Injector injector = Guice.createInjector(new Module());\n    I object = injector.getInstance(I.class);\n    object.dummy();\n  }\n}\n\n/**\n  * Exception in thread  main  com.google.inject.ConfigurationException:\n  * Guice configuration errors:\n  *\n  * 1) No implementation for I was bound.\n  * while locating I\n  *\n  * 1 error\n  * at com.google.inject.internal.InjectorImpl.getProvider(InjectorImpl.java:1042)\n  * at com.google.inject.internal.InjectorImpl.getProvider(InjectorImpl.java:1001)\n  * at com.google.inject.internal.InjectorImpl.getInstance(InjectorImpl.java:1051)\n  * at guice.main(guice.java:15)\n  *\n */  import dagger.*;\nimport javax.inject.Inject;\n\ninterface I {\n  public void dummy();\n};\n\nclass Impl implements I {\n  @Inject Impl() { }\n  @Override public void dummy() { }\n}\n\n@Module\nclass AppModule {\n  //@Provides I provideI(Impl impl) { return impl; }\n}\n\n@Component(modules = AppModule.class)\ninterface AppComponent {\n  I build();\n}\n\npublic class dagger2 {\n  public static void main(String[] args) {\n    I object = Dagger_AppComponent.create().build();\n    object.dummy();\n   }\n}\n\n/**\n * dagger2.java:13: error: I cannot be provided without an @Provides-annotated method.\n * I build();\n *   ^\n * 1 error\n */  using Ninject;\n\ninterface I {\n  void dummy();\n};\n\nclass Impl : I {\n  public Impl() { }\n  void I.dummy() { }\n}\n\nclass Module : Ninject.Modules.NinjectModule {\n  public override void Load() {\n    //Bind I ().To Impl ();\n  }\n}\n\nclass ninject {\n  static void Main(string[] args) {\n    Ninject.IKernel kernel = new StandardKernel(new Module());\n    I object = kernel.Get I ();\n    object- dummy();\n  }\n}\n\n/**\n */", 
            "title": "Usage of C++ vs Java vs C# Libraries"
        }, 
        {
            "location": "/user_guide/index.html", 
            "text": "Injector\n\n\ndi::make_injector\n\n\n\n\n\n\nBindings\n\n\ndi::bind\n\n\n\n\n\n\nInjections\n\n\nautomatic (default)\n\n\nBOOST_DI_INJECT\n\n\nBOOST_DI_INJECT_TRAITS\n\n\ndi::inject\n\n\ndi::ctor_traits\n\n\n\n\n\n\nAnnotations\n\n\n(named = name)\n\n\n\n\n\n\nScopes\n\n\ndi::deduce (default)\n\n\ndi::instance (di::bind\n.to(value))\n\n\ndi::singleton\n\n\ndi::unique\n\n\n\n\n\n\nModules\n\n\nBOOST_DI_EXPOSE\n\n\n\n\n\n\nProviders\n\n\ndi::providers::stack_over_heap (default)\n\n\ndi::providers::heap\n\n\n\n\n\n\nPolicies\n\n\ndi::policies::constructible\n\n\n\n\n\n\nConcepts\n\n\ndi::concepts::boundable\n\n\ndi::concepts::callable\n\n\ndi::concepts::configurable\n\n\ndi::concepts::creatable\n\n\ndi::concepts::providable\n\n\ndi::concepts::scopable\n\n\n\n\n\n\nConfiguration\n\n\ndi::config\n\n\n\n\n\n\nImplementation details\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComponent\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBindings\n\n\nDSL to create dependencies representation which will be used by core to resolve types\n\n\n\n\n\n\nScopes\n\n\nResponsible for maintain objects life time\n\n\n\n\n\n\nProviders\n\n\nResponsible for providing object instance\n\n\n\n\n\n\nPolicies\n\n\nCompile-time limitations for types / Run-time types vistor\n\n\n\n\n\n\nConfig\n\n\nConfiguration for [Policies] and [Providers]\n\n\n\n\n\n\nCore\n\n\nResponsible for resolving requested types (implementation detail)\n\n\n\n\n\n\nWrappers\n\n\nResponsible for conversion to required type (implementation detail)\n\n\n\n\n\n\n\n\n\n\nLet's assume all examples below include \nboost/di.hpp\n header and define a convenient \ndi\n\nnamespace alias as well as some basic interfaces and types.\n\n\n#include \nboost/di.hpp\n\nnamespace di = boost::di;\n\nstruct i1 { virtual ~i1() = default; virtual void dummy1() = 0; };\nstruct i2 { virtual ~i2() = default; virtual void dummy2() = 0; };\nstruct impl1 : i1 { void dummy1() override { } };\nstruct impl2 : i2 { void dummy2() override { } };\nstruct impl : i1, i2 { void dummy1() override { } void dummy2() override { } };\n\n\n\n\nInjector\n\n\n\n\nInjector is a core component providing types creation functionality using \nbindings\n.\n\n\n--- \ndi::make_injector\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nCreates \ninjector\n type.\n\n\nSemantics\n\n\ntemplate\nclass... TDeps\n requires boundable\nTDeps...\n\nclass injector {\npublic:\n  using deps; // list of dependencies\n  using config; // configuration\n\n  injector(injector\n) = default;\n  template \nclass... Ts\n // no requirements\n  injector(core::injector\nTs...\n) noexcept;\n  explicit injector(const TDeps\n...) noexcept;\n\n  template \nclass T\n\n  injector\n operator=(T\n other) noexcept;\n\n  template\nclass T\n requires creatable\nT\n\n  T create() const;\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTDeps...\n\n\nboundable\nTDeps...>\n\n\nBindings\n to be used as configuration\n\n\n-\n\n\n\n\n\n\ncreate\nT\n()\n\n\ncreatable\nT>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType \nT\n\n\nIs allowed?\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nT*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\nOwnership transfer!\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\nReference with \nsingleton\n / Temporary with \nunique\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::unique_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nstd::weak_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\nboost_shared_ptr\nT\n\n\n\u2714\n\n\n-\n\n\n\n\n\n\n\n\ntemplate\n\n  class TConfig = di::config\n, class... TBindings\n\n requires configurable\nTConfig\n \n boundable\nTBindings...\n\nauto make_injector(TBindings...) noexcept;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTConfig\n\n\nconfigurable\nTConfig>\n\n\nConfiguration\n per \ninjector\n\n\n-\n\n\n\n\n\n\nmake_injector(TBindings...)\n\n\nboundable\nTBindings...>\n\n\nCreates \ninjector\n with given \nBindings\n\n\ninjector\n\n\n\n\n\n\n\n\nTest\n\n\n\nint main() {\n  auto injector = di::make_injector();\n\n  assert(0 == injector.create\nint\n());\n}\n\n\n\n\nExample\n\n\n\n\n Hello World Example\n\n\n Create Objects Tree Example\n\n\n\n\n\n\nInjection in a nutshell\n (implementation detail)\n\n\nThe main interface of the injector is a \ncreate\n method.\nWhen \ncreate\n method is called for type \nT\n the magic happens.\nFirstly, policies are verified (for example, whether the type \nT\n is allowed to be created).\nThen, the constructor traits are deduced (\nctor_traits\n ) for type \nT\n and dependencies of the constructor\nparameters are resolved (\nbinder\n). \nwrapper\n is used to convert internal representation\nof the dependency into a required type (ex. \nshared_ptr\nT\n). Whole process is repeated\nrecursively for all required parameters of \nT\n constructor.\n\n\nstruct direct; // T(...)\nstruct uniform; // T{...}\n\ntemplate\nclass T, class... TArgs\n is_braces_constructible; // type T is constructible using T{...}\ntemplate\nclass T, class... TArgs\n is_constructible; // Type T is constructible using T(...)\n\ntemplate\nclass T\n is_injectable; // Type T uses BOOST_DI_INJECT or BOOST_DI_INJECT_TRAITS\n\ntemplate\nclass TConfig, class... TBindings\n // For Example, TBindings = { di::bind\nInterface\n.to\nImplementation\n }\nstruct core::injector : TBindings... {\n  using config = TConfig;\n  using deps = TBindings...;\n\n  template\nclass T\n // For example, T = Interface\n  auto create() const noexcept {\n    TConfig::policies\nT\n()...; // verify policies\n    using Type = core::binder\nTBindings...\n().resolve\nT\n(*this); // Type = Implementation\n    return core::wrapper\nT\n{dependency.create(provider\nTInjector\n{*this}.get\nType\n())};\n  }\n};\n\ntemplate\nclass TInjector, class TConfig\n\nstruct provider {\n  template\nclass T\n auto get() const noexcept {\n    using pair\nTInitialization, TCtor...\n = decltype(ctor_traits\nTInjector, T\n());\n    return TConfig::provider().get(TInitialization{}, TCtor...);\n  }\n  const TInjector\n injector;\n};\n\ntemplate\nclass TInjector\n\nstruct any_type {\n  template\nclass T\n\n  operator T() const {\n    return injector.templte create\nT\n();\n  }\n  const TInjector\n injector;\n};\n\ntemplate\nclass TInjector, class T\n\nauto ctor_traits() {\n  if (is_injectable\nT\n() {\n    return pair\ndirect, typename T::boost_di_inject__\n{}; // BOOST_DI_INJECT(T, args...) -\n T(args...)\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i \n= 0; --i) {\n    if (is_constructible\nT, any_type\nTInjector\n...\n()) { // ... -\n i times\n      return pair\ndirect, any_type\nTInjector\n...\n{}; // T(any_type...)\n    }\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i \n= 0; --i) {\n    if (is_braces_constructible\nT, any_type\nTInjector\n...\n()) { // ... -\n i times\n      return pair\nuniform, any_type\nTInjector\n...\n{}; // T{any_type...}\n    }\n  }\n\n  return error(...);\n};\n\n\n\n\n \nNote\n\n\nAutomatic injection\n depends on template implicit conversion operator and therefore\nconversion constructors \ntemplate\nclass I\n T(I)\n are not supported and have to be injected using \nBOOST_DI_INJECT\n, \nBOOST_DI_INJECT_TRAITS\n, \ndi::inject\n or \ndi::ctor_traits\n.\n\n\n\n\n\nBindings\n\n\nBindings define dependencies configuration describing what types will be created\nand what values will be passed into them.\n\n\n\n--- \ndi::bind\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nAllows to bind interface to implementation and associate value with it.\n\n\nSemantics\n\n\nstruct override; // overrides given configuration\n\nnamespace detail {\n  template\nclass I, class... Is/*any_of*/\n requires boundable\nI, Is...\n\n  struct bind {\n    bind(bind\n) noexcept = default;\n\n    template \nclass T\n requires !is_array\nI\n \n boundable\nI, T\n\n    auto to() noexcept;\n\n    template \nclass... Ts\n requires is_array\nI\n \n boundable\nTs...\n\n    auto to() noexcept;\n\n    template\nclass T\n requires boundable\nI, T\n\n    auto to(T\n) noexcept;\n\n    template\nclass TScope\n requires scopable\nTScope\n\n    auto in(const TScope\n = di::deduce) noexcept;\n\n    template\nclass TName\n // no requirements\n    auto named(const TName\n = {}) noexcept;\n\n    auto operator[](const override\n) noexcept;\n  };\n} // detail\n\ntemplate\nclass... Ts\n requires boundable\nTs...\n\ndetail::bind\nTs...\n bind{};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nI\n, \nIs...\n\n\nboundable\nI, Is...>\n\n\n'Interface' types\n\n\n-\n\n\n\n\n\n\nto\nT\n\n\nboundable\nT>\n\n\nBinds \nI, Is...\n to \nT\n type\n\n\nboundable\n\n\n\n\n\n\nto\nTs...\n\n\nboundable\nTs...>\n\n\nBinds \nI, Is...\n to \nTs...\n type\n\n\nboundable\n\n\n\n\n\n\nto(T\n)\n\n\nboundable\nT>\n\n\nBinds \nI, Is...\n to \nT\n object\n\n\nboundable\n\n\n\n\n\n\nin(const TScope\n)\n\n\nscopable\nTScope>\n\n\nBinds \nI, Is...\n in TScope`\n\n\nboundable\n\n\n\n\n\n\nnamed(const TName\n)\n\n\n-\n\n\nBinds \nI, Is...\n using \nnamed\n annotation\n\n\nboundable\n\n\n\n\n\n\noperator[](const override\n)\n\n\n-\n\n\nOverrides given binding\n\n\nboundable\n\n\n\n\n\n\n\n\n \nNote\n\nCheck out also \ninstance\n scope to read more about binding to values: \ndi::bind\n.to(value)\n.\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nMultiple Interfaces\n\n\n\n\n\n\n\n\ndi::bind\nInterface1, Interface2, ...\n.to\nImplementation\n()\n\n\nBinds \nInterface1, Interface2, ...\n to \nImplementation\n using one object\n\n\n\n\n\n\nMultiple Bindings\n (std::array, std::vector, std::set)\n\n\n\n\n\n\n\n\ndi::bind\nint[]\n.to({1, 2, ...})\n\n\nBinds \nint\n to values \n1, 2, ...\n\n\n\n\n\n\ndi::bind\nInterface*[]\n.to\nImplementation1, Implementation2, ...\n()\n\n\nBinds \nInterface\n to \nImplementation1, Implementation2, ...\n\n\n\n\n\n\nDynamic Bindings\n\n\n\n\n\n\n\n\ndi::bind\nInterface\n.to([](const auto\n injector)\n{ return injector.template create\nImplementation\n()})\n\n\nAllows to bind \nInterface\n depending on a run-time condition\n\n\n\n\n\n\n\n\nTest\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  );\n\n  auto object = injector.create\nstd::unique_ptr\ni1\n();\n  assert(dynamic_cast\nimpl1*\n(object.get()));\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  );\n\n  assert(42 == injector.create\nint\n());\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\n().to(42)\n  );\n\n  assert(42 == injector.create\nint\n());\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to\nstd::integral_constant\nint, 42\n()\n  );\n\n  assert(42 == injector.create\nint\n());\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1, i2\n().to\nimpl\n()\n  );\n\n  auto object1 = injector.create\nstd::shared_ptr\ni1\n();\n  auto object2 = injector.create\nstd::shared_ptr\ni2\n();\n  assert(dynamic_cast\nimpl*\n(object1.get()));\n  assert(dynamic_cast\nimpl*\n(object2.get()));\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1\n().to([\n](const auto\n injector) -\n i1\n {\n      if (true)\n        return injector.template create\nimpl1\n();\n      else\n        return injector.template create\nimpl\n();\n    })\n  );\n\n  auto\n object = injector.create\ni1\n();\n  assert(dynamic_cast\nimpl1*\n(\nobject));\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1*[]\n().to\nimpl, impl1\n()\n  );\n\n  auto v = injector.create\nstd::vector\nstd::unique_ptr\ni1\n();\n  assert(2 == v.size());\n  assert(dynamic_cast\nimpl*\n(v[0].get()));\n  assert(dynamic_cast\nimpl1*\n(v[1].get()));\n}\n\n\n\n\n\nint main() {\n  auto il = {1, 2, 3};\n  auto injector = di::make_injector(\n    di::bind\nint[]\n().to(il) // or di::bind\nint*[]\n.to(il)\n  );\n\n  auto v = injector.create\nstd::vector\nint\n();\n  assert(3 == v.size());\n  assert(1 == v[0]);\n  assert(2 == v[1]);\n  assert(3 == v[2]);\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\nint\n().to(123) [di::override]\n  );\n\n  assert(123 == injector.create\nint\n());\n}\n\n\n\n\n\nint main() {\n  auto injector = di::make_injector(\n#if defined(__cpp_variable_templates)\n      di::bind\ni1\n.to\nimpl1\n()\n#else\n      di::bind\ni1\n().to\nimpl1\n()  // no variable templates\n#endif\n          );\n\n  auto object = injector.create\nstd::unique_ptr\ni1\n();\n  assert(dynamic_cast\nimpl1*\n(object.get()));\n}\n\n\n\n\nExample\n\n\n\n\n Bindings Example\n\n\n Forward Bindings Example\n\n\n Dynamic Bindings Example\n\n\n Multiple Bindings Example\n\n\n Constructor Bindings Extension\n\n\n\n\n\n\nInjections\n\n\nConstructor Injection\n is the most powerful of available injections.\nIt guarantees initialized state of data members. [Boost].DI constructor injection is achieved without any additional work from the user.\n\n\n\n--- \nautomatic (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\n[Boost].DI will deduce the best available constructor to be used for injection - unique constructor with the longest parameter list.\nIf the default behavior should be changed constructor has to be explicitly marked with\n\nBOOST_DI_INJECT\n or \nBOOST_DI_INJECT_TRAITS\n or di::ctor_traits] or \ndi::inject\n.\n\n\n \nNote\n\nAutomatic constructor parameters deduction is limited to \nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n, which by default is set to 10.\n\n\n\nSemantics\n\n\nclass T {\npublic:\n  T(auto parameter1, auto parameter2, ..., auto parameterN);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nparameter1-parameterN\n\n\n-\n\n\nN\n constructor parameter\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\n[Boost].DI is not able to automatically distinguish between ambiguous constructors with the same (longest) number of parameters.\nUse \nBOOST_DI_INJECT\n or \nBOOST_DI_INJECT_TRAITS\n or \ndi::ctor_traits\n or \ndi::inject\n to explicitly mark constructor to be injected.\n\n\n\nTest\n\n\n\nstruct T {\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\n\nstruct T {\n  int a;     // = 0;\n  double d;  // = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\n\nstruct T {\n  T();\n  T(int a) : a(a) {}\n  T(int a, double d) : a(a), d(d) {}  // longest will be chosen\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\n\nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d, ...) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\nExample\n\n\n\n\n Automatic Injection Example\n\n\n Constructor Signature Example\n\n\n Lazy Extension\n\n\n XML Injection Extension\n\n\n\n\n\n\n\n--- \nBOOST_DI_INJECT\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBOOST_DI_INJECT is a macro definition used to explicitly say [Boost].DI which constructor should be used as well as to annotate types - see \nannotations\n for further reding.\nWhen class has more than one constructor [Boost].DI will by default choose the one with the longest parameter list.\nIn case of constructors ambiguity, [Boost].DI is not able to choose the best one.\nThen BOOST_DI_INJECT becomes handy to point which constructor should be used.\n\n\nSemantics\n\n\nstruct T {\n    BOOST_DI_INJECT(T, ...) { }\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nT\n\n\n-\n\n\nClass/Struct name\n\n\n-\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\nBOOST_DI_INJECT constructor parameters is limited to \nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n, which by default is set to 10.\n\n\n\nTest\n\n\n\nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  BOOST_DI_INJECT(T, int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\nExample\n\n\n\n\n Constructor Injection Example\n\n\n Concepts Extension\n\n\n\n\n\n\n\n--- \nBOOST_DI_INJECT_TRAITS\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBOOST_DI_INJECT_TRAITS is a macro definition used to define constructor traits.\n\n\nSemantics\n\n\nstruct T {\n  BOOST_DI_INJECT_TRAITS(...) { }\n  T(...) { }\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\nBOOST_DI_INJECT_TRAITS constructor parameters is limited to \nBOOST_DI_CFG_CTOR_LIMIT_SIZE\n, which by default is set to 10.\n\n\n\nTest\n\n\n\nstruct T {\n  BOOST_DI_INJECT_TRAITS(int, double);\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\n\nclass example {\n public:\n  BOOST_DI_INJECT_TRAITS(int);\n  explicit example(int i, double d = 42.0) : i(i), d(d) {}\n\n  int i = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector();\n  auto object = injector.create\nexample\n();\n  assert(0 == object.i);\n  assert(42.0 == object.d);\n}\n\n\n\n\nExample\n\n\n\n\n Constructor Injection Example\n\n\n\n\n\n\n\n--- \ndi::inject\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\ndi::inject\n informs [Boost].DI about constructor parameters.\nIt's useful for generated/generic classes as it doesn't have constructor parameters size limitations.\n\n\nSemantics\n\n\nstruct T {\n  using boost_di_inject__ = di::inject\n...\n;\n  T(...) {}\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\n...\n\n\n-\n\n\nT\n constructor parameters\n\n\n-\n\n\n\n\n\n\n\n\n \nNote\n\n\ndi::inject\n has no limitations if it comes to constructor parameters, however, \nnamed\n parameters are not allowed.\nMoreover, you can replace \ndi::inject\n with any variadic type list type to remove dependency to [Boost].DI.\nFor example, \ntemplate\nclass...\n struct type_list{};\n \nusing boost_di_inject__ = type_list\n...\n;\n\n\n\n\nTest\n\n\n\nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n  using boost_di_inject__ = di::inject\nint, double\n;\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\n\nstruct T {\n  using boost_di_inject__ = di::inject\n\n    int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int\n;\n\n  T(int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int) { }\n};\n\nint main() {\n  auto injector = di::make_injector();\n  injector.create\nT\n();  // compile clean\n}\n\n\n\n\nExample\n\n\n\n\n Constructor Injection Example\n\n\n\n\n\n\n\n--- \ndi::ctor_traits\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\ndi::ctor_traits\n is a trait in which constructor parameters for type \nT\n might be specified.\nIt's useful for third party classes you don't have access to and which can't be created using \nautomatic\n injection.\n\n\nSemantics\n\n\nnamespace boost {\nnamespace di {\n  template \n\n  struct ctor_traits\nT\n {\n    BOOST_DI_INJECT_TRAITS(...); // or using type = di::inject\n...\n;\n  };\n}}\n\n\n\nTest\n\n\n\nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nnamespace boost {\nnamespace di {\ntemplate \n\nstruct ctor_traits\nT\n {\n  BOOST_DI_INJECT_TRAITS(int, double);\n};\n}  // namespace di\n}  // namespace boost\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}\n\n\n\n\nExample\n\n\n\n\n Constructor Injection Example\n\n\n\n\n\n\nAnnotations\n\n\nAnnotations are type properties specified in order to refer to a type by the name instead of the type it self.\nThey are useful when constructor has more than one parameter of the same type.\nFor example, \nT(int, int)\n.\n\n\n\n--- \n(named = name)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nNamed parameters are handy to distinguish different constructor parameters of the same type.\n\n\n  T(int value1, int value2);\n\n\n\n\nIn order to inject proper values into \nvalue1\n and \nvalue2\n they have to be differentiate somehow.\n[Boost].DI solution for this problem are annotations.\n\n\n \nNote\n\nAnnotations might be set only when constructor is marked using \nBOOST_DI_INJECT\n or \nBOOST_DI_INJECT_TRAITS\n.\n\n\n\nSemantics\n\n\nauto Name = []{}; // just an object\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = Name) type type_name [= default_value], ...);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nName\n\n\n-\n\n\nObject representing named type\n\n\n-\n\n\n\n\n\n\n\n\nExample\n\n\nBOOST_DI_INJECT(T, (named = value_1) int value1, (named = value_2) int value2);\n\n\n\n \nNote\n\nImplementation of constructor doesn't require annotations, only constructor definition requires them.\n\n\n\nTest\n\n\n\nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = int1) int a, (named = int2) int b) : a(a), b(b) {}\n  int a = 0;\n  int b = 0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(int1).to(42)\n  , di::bind\nint\n().named(int2).to(87)\n  );\n  {\n    auto object = injector.create\nT\n();\n    assert(42 == object.a);\n    assert(87 == object.b);\n  }\n  {\n    auto object = T(42, 87);\n    assert(42 == object.a);\n    assert(87 == object.b);\n  }\n}\n\n\n\n\n\nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = int1) int a, (named = int2) int b);\n  int a = 0;\n  int b = 0;\n};\n\nT::T(int a, int b) : a(a), b(b) {}\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(int1).to(42)\n  , di::bind\nint\n().named(int2).to(87)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87 == object.b);\n}\n\n\n\n\n\nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  T(int a, int b) : a(a), b(b) {}\n  int a = 0;\n  int b = 0;\n};\n\nnamespace boost {\nnamespace di {\ntemplate \n\nstruct ctor_traits\nT\n {\n  BOOST_DI_INJECT_TRAITS((named = int1) int, (named = int2) int);\n};\n}  // namespace di\n}  // namespace boost\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(int1).to(42)\n  , di::bind\nint\n().named(int2).to(87)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.a);\n  assert(87 == object.b);\n}\n\n\n\n\n\nauto n1 = [] {};\nauto n2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = n1) int i1\n                   , (named = n1) int i2\n                   , (named = n2) int i3\n                   , int i4\n                   , (named = n1)std::string s)\n    : i1(i1), i2(i2), i3(i3), i4(i4), s(s) {}\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n  int i4 = 0;\n  std::string s;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(n1).to(42)\n  , di::bind\nint\n().named(n2).to(87)\n  , di::bind\nstd::string\n().named(n1).to(\nstr\n)\n  );\n  auto object = injector.create\nT\n();\n  assert(42 == object.i1);\n  assert(42 == object.i2);\n  assert(87 == object.i3);\n  assert(0 == object.i4);\n  assert(\nstr\n == object.s);\n}\n\n\n\n\nExample\n\n\n\n\n Annotations Example\n\n\n Named Parameters Extension\n\n\n Assisted Injection Extension\n\n\n\n\n\n\nScopes\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScopes are responsible for creating and maintaining life time of dependencies.\nIf no scope will be given, \ndeduce\n scope will be assumed.\n\n\nSemantics\n\n\ntemplate \nclass TExpected, class TGiven\n\nstruct scope {\n  template \nclass T\n\n  using is_referable;\n\n  template \nclass T, class TName, class TProvider\n\n  static auto try_create(const TProvider\n);\n\n  template \nclass T, class TName, class TProvider\n\n  auto create(const TProvider\n);\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType/Scope\n\n\nunique\n\n\nsingleton\n\n\ninstance\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT* (transfer ownership)\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n\u2714\n\n\n-\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\u2714\n\n\n- / \u2714 converted to\n\n\n\n\n\n\n\n\nTest\n\n\n\nstruct custom_scope {\n  template \nclass TExpected, class\n\n  struct scope {\n    template \nclass...\n\n    using is_referable = std::false_type;\n\n    template \nclass T, class, class TProvider\n\n    static auto try_create(const TProvider\n provider) -\n decltype(std::shared_ptr\nTExpected\n{provider.get()});\n\n    template \nclass T, class, class TProvider\n\n    auto create(const TProvider\n provider) {\n      return std::shared_ptr\nTExpected\n{provider.get()};\n    }\n  };\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1\n().in(custom_scope{}).to\nimpl1\n()\n  );\n  assert(injector.create\nstd::shared_ptr\ni1\n() != injector.create\nstd::shared_ptr\ni1\n());\n}\n\n\n\n\nExample\n\n\n\n\n Custom Scope Example\n\n\n Scoped Scope Extension\n\n\n Session Scope Extension\n\n\n Shared Scope Extension\n\n\n\n\n\n\n\n--- \ndi::deduce (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nDefault scope which will be converted to one of the scopes depending on the type.\n\n\n\n\n\n\n\n\nType\n\n\nScope\n\n\n\n\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nT\n\n\nsingleton\n\n\n\n\n\n\nconst T\n\n\nunique\n (temporary) / \nsingleton\n\n\n\n\n\n\nT*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nconst T*\n\n\nunique\n (ownership transfer)\n\n\n\n\n\n\nT\n\n\nunique\n\n\n\n\n\n\nstd::unique_ptr\n\n\nunique\n\n\n\n\n\n\nstd::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nboost::shared_ptr\n\n\nsingleton\n\n\n\n\n\n\nstd::weak_ptr\n\n\nsingleton\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct deduce {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::deduce deduce;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\nstruct T {\n  T(const std::shared_ptr\ni1\n sp, std::unique_ptr\ni2\n up, int\n i, double d) : sp(sp), up(std::move(up)), i(i), d(d) {}\n\n  std::shared_ptr\ni1\n sp; /*singleton*/\n  std::unique_ptr\ni2\n up; /*unique*/\n  int\n i;                 /*instance*/\n  double d;               /*unique*/\n};\n\nint main() {\n  auto i = 42;\n  auto injector = di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  , di::bind\ni2\n().to\nimpl2\n()\n  , di::bind\nint\n().to(i)\n  , di::bind\ndouble\n().to(87.0)\n  );\n  auto object1 = injector.create\nstd::unique_ptr\nT\n();\n  auto object2 = injector.create\nstd::unique_ptr\nT\n();\n  assert(object1-\nsp == object2-\nsp);\n  assert(object1-\nup != object2-\nup);\n  assert(42 == object1-\ni);\n  assert(\ni == \nobject1-\ni);\n  assert(42 == object2-\ni);\n  assert(\ni == \nobject2-\ni);\n  assert(87.0 == object1-\nd);\n  assert(87.0 == object2-\nd);\n  i = 12;\n  assert(i == object2-\ni);\n  assert(\ni == \nobject2-\ni);\n}\n\n\n\n\nExample\n\n\n\n\n Deduce Scope Example\n\n\n Scopes Example\n\n\n\n\n\n\n\n--- \ndi::instance (di::bind\n.to(value))\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing values - passed externally. The life time of the object depends on the user.\n[Boost].DI is not maintaining the life time of these objects, however, values and strings will be copied and managed by the library.\n\n\n\n\n\n\n\n\nType\n\n\ninstance[in] (\nbind\n.to(in)\n)\n\n\ninstance[out] (\ninjector.create\nout\n()\n)\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nT*\n\n\n-\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n-\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n-\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\u2714\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct instance {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\nint main() {\n  auto l = 42l;\n  auto b = false;\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(0)\n  , di::bind\nint\n().to(42)[di::override]\n  , di::bind\ni1\n().to(std::make_shared\nimpl\n())\n  , di::bind\nlong\n().to(l)\n  , di::bind\nshort\n().to([] { return 87; })\n  , di::bind\ni2\n().to([\n](const auto\n injector) -\n std::shared_ptr\ni2\n {\n      return b ? injector.template create\nstd::shared_ptr\nimpl2\n() : nullptr; })\n  );\n\n  assert(42 == injector.create\nint\n());\n  assert(injector.create\nstd::shared_ptr\ni1\n() == injector.create\nstd::shared_ptr\ni1\n());\n  assert(l == injector.create\nlong\n());\n  assert(\nl == \ninjector.create\nlong\n());\n  assert(87 == injector.create\nshort\n());\n  {\n    auto object = injector.create\nstd::shared_ptr\ni2\n();\n    assert(nullptr == object);\n  }\n  {\n    b = true;\n    auto object = injector.create\nstd::shared_ptr\ni2\n();\n    assert(dynamic_cast\nimpl2*\n(object.get()));\n  }\n}\n\n\n\n\nExample\n\n\n\n\n Scopes Example\n\n\n Bindings Example\n\n\n\n\n\n\n\n--- \ndi::singleton\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing shared value between all instances as well as threads.\nSingleton scope will be deduced in case of reference, \nstd::shared_ptr\n, \nboost::shared_ptr\n or \nstd::weak_ptr\n.\n\n\n \nNote\n\nSingleton scope will convert automatically between \nstd::shared_ptr\n and \nboost::shared_ptr\n if required.\n\n\n\n\n\n\n\n\n\nType\n\n\nsingleton\n\n\n\n\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nconst T\n\n\n\u2714\n\n\n\n\n\n\nT*\n\n\n-\n\n\n\n\n\n\nconst T*\n\n\n-\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nstd::unique_ptr\n\n\n-\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nstd::weak_ptr\n\n\n\u2714\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct singleton {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::singleton singleton;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1\n().in(di::singleton).to\nimpl1\n()\n  );\n\n  assert(injector.create\nstd::shared_ptr\ni1\n() == injector.create\nstd::shared_ptr\ni1\n());\n}\n\n\n\n\nExample\n\n\n\n\n Scopes Example\n\n\n Eager Singletons Example\n\n\n\n\n\n\n\n--- \ndi::unique\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope representing unique/per request value. A new instance will be provided each time type will be requested.\n\n\n\n\n\n\n\n\nType\n\n\nunique\n\n\n\n\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nT\n\n\n-\n\n\n\n\n\n\nconst T\n\n\n\u2714 (temporary)\n\n\n\n\n\n\nT*\n\n\n\u2714 (ownership transfer)\n\n\n\n\n\n\nconst T*\n\n\n\u2714 (ownership transfer)\n\n\n\n\n\n\nT\n\n\n\u2714\n\n\n\n\n\n\nstd::unique_ptr\n\n\n\u2714\n\n\n\n\n\n\nstd::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nboost::shared_ptr\n\n\n\u2714\n\n\n\n\n\n\nstd::weak_ptr\n\n\n-\n\n\n\n\n\n\n\n\nSemantics\n\n\nnamespace scopes {\n  struct unique {\n    template \nclass TExpected, class TGiven\n\n    struct scope {\n      template \nclass T\n\n      using is_referable;\n\n      template \nclass T, class TName, class TProvider\n\n      static auto try_create(const TProvider\n);\n\n      template \nclass T, class TName, class TProvider\n\n      auto create(const TProvider\n);\n    };\n  };\n}\n\nscopes::unique unique;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTExpected\n\n\n-\n\n\n'Interface' type\n\n\n-\n\n\n\n\n\n\nTGiven\n\n\n-\n\n\n'Implementation' type\n\n\n-\n\n\n\n\n\n\nis_referable\nT\n\n\n-\n\n\nVerifies whether scope value might be converted to a reference\n\n\ntrue_type/false_type\n\n\n\n\n\n\ntry_create\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nVerifies whether type \nT\n might be created\n\n\ntrue_type/false_type\n\n\n\n\n\n\ncreate\nT, TName, TProvider\n\n\nprovidable\nTProvider>\n\n\nCreates type \nT\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind\ni1\n().in(di::unique).to\nimpl1\n()\n  );\n\n  assert(injector.create\nstd::shared_ptr\ni1\n() != injector.create\nstd::shared_ptr\ni1\n());\n}\n\n\n\n\nExample\n\n\n\n\n Scopes Example\n\n\n\n\n\n\nModules\n\n\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nModules allow to split \nbindings\n configuration into smaller \ninjectors\n.\nModule might be installed by passing it into \nmake_injector\n.\n\n\nSemantics\n\n\nauto module = di::make_injector(...);\ndi::injector\nTs...\n module = di::make_injector(...);\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nauto module = di::make_injector(...)\n\n\nAll types are exposed from \nmodule\n\n\nmodule.create\nT\n()\n is allowed for any \nT\n\n\n\n\n\n\ndi::injector\nTs...\n module = di::make_injector(...)\n\n\nOnly \nTs...\n types are exposed from \nmodule\n\n\nmodule.create\nT\n()\n is allowed only for \nT\n \n= \nTs...\n\n\n\n\n\n\n\n\nTest\n\n\n\nstruct T {\n  T(std::unique_ptr\ni1\n i1, std::unique_ptr\ni2\n i2, int i) : i1_(std::move(i1)), i2_(std::move(i2)), i(i) {}\n\n  std::unique_ptr\ni1\n i1_;\n  std::unique_ptr\ni2\n i2_;\n  int i = 0;\n};\n\nauto module1 = [] {\n  return di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  , di::bind\nint\n().to(42)\n  );\n};\n\nauto module2 = [] {\n  return di::make_injector(\n    di::bind\ni2\n().to\nimpl2\n()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module1(), module2());\n  auto object = injector.create\nstd::unique_ptr\nT\n();\n  assert(dynamic_cast\nimpl1*\n(object-\ni1_.get()));\n  assert(dynamic_cast\nimpl2*\n(object-\ni2_.get()));\n  assert(42 == object-\ni);\n  auto up1 = injector.create\nstd::unique_ptr\ni1\n();\n  assert(dynamic_cast\nimpl1*\n(up1.get()));\n  auto up2 = injector.create\nstd::unique_ptr\ni2\n();\n  assert(dynamic_cast\nimpl2*\n(up2.get()));\n}\n\n\n\n\n\nstruct T {\n  T(std::shared_ptr\ni1\n i1, std::shared_ptr\ni2\n i2, int i) : i1_(i1), i2_(i2), i(i) {}\n\n  std::shared_ptr\ni1\n i1_;\n  std::shared_ptr\ni2\n i2_;\n  int i;\n};\n\ndi::injector\nT\n module(const int\n i) noexcept {\n  return di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  , di::bind\ni2\n().to\nimpl2\n()\n  , di::bind\nint\n().to(i)\n  );\n}\n\nint main() {\n  auto injector = di::make_injector(module(42));\n  auto object = injector.create\nT\n();\n  assert(dynamic_cast\nimpl1*\n(object.i1_.get()));\n  assert(dynamic_cast\nimpl2*\n(object.i2_.get()));\n  assert(42 == object.i);\n  // injector.create\nstd::unique_ptr\ni1\n(); // compile error\n  // injector.create\nstd::unique_ptr\ni2\n(); // compile error\n}\n\n\n\n\n\nauto module = []() -\n di::injector\nstd::unique_ptr\ni1\n, std::unique_ptr\ni2\n {\n  return di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  , di::bind\ni2\n().to\nimpl2\n()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  auto up1 = injector.create\nstd::unique_ptr\ni1\n();\n  assert(dynamic_cast\nimpl1*\n(up1.get()));\n  auto up2 = injector.create\nstd::unique_ptr\ni2\n();\n  assert(dynamic_cast\nimpl2*\n(up2.get()));\n}\n\n\n\n\nExample\n\n\n\n\n Modules Example\n\n\n\n\n\n\n\n--- \nBOOST_DI_EXPOSE\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBOOST_DI_EXPOSE is a macro definition allowing to expose \nnamed\n parameters via module/\ninjector\n.\n\n\nSemantics\n\n\ndi::injector\nBOOST_DI_EXPOSE((named = Name) T), ...\n;\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nName\n\n\n-\n\n\nNamed object\n\n\n-\n\n\n\n\n\n\n...\n\n\n-\n\n\nMore types to be exposed\n\n\n-\n\n\n\n\n\n\n\n\nTest\n\n\n\nauto my_name = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = my_name) std::unique_ptr\ni1\n up) : up(std::move(up)) {}\n  std::unique_ptr\ni1\n up;\n};\n\nauto module = []() -\n di::injector\nBOOST_DI_EXPOSE((named = my_name) std::unique_ptr\ni1\n)\n {\n  return di::make_injector(\n    di::bind\ni1\n().named(my_name).to\nimpl1\n()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  auto object = injector.create\nstd::unique_ptr\nT\n();\n  assert(dynamic_cast\nimpl1*\n(object-\nup.get()));\n}\n\n\n\n\n\nstruct T {\n  T(std::shared_ptr\ni1\n i1, std::shared_ptr\ni2\n i2, int i) : i1_(i1), i2_(i2), i(i) {}\n\n  std::shared_ptr\ni1\n i1_;\n  std::shared_ptr\ni2\n i2_;\n  int i;\n};\n\n__BOOST_DI_UNUSED auto name = [] {};\n\ndi::injector\nT, std::unique_ptr\nT\n, BOOST_DI_EXPOSE((named = name) T)\n module(const int\n i) noexcept {\n  return di::make_injector(\n    di::bind\ni1\n().to\nimpl1\n()\n  , di::bind\ni2\n().to\nimpl2\n()\n  , di::bind\nint\n().to(i)\n  );\n}\n\nint main() {\n  auto injector = di::make_injector(module(42));\n  {\n    auto object = injector.create\nT\n();\n    assert(dynamic_cast\nimpl1*\n(object.i1_.get()));\n    assert(dynamic_cast\nimpl2*\n(object.i2_.get()));\n    assert(42 == object.i);\n  }\n  {\n    auto object = injector.create\nstd::unique_ptr\nT\n();\n    assert(dynamic_cast\nimpl1*\n(object-\ni1_.get()));\n    assert(dynamic_cast\nimpl2*\n(object-\ni2_.get()));\n    assert(42 == object-\ni);\n  }\n  {\n    struct example {\n      BOOST_DI_INJECT(example, (named = name) T object) : object(object) {}\n      T object;\n    };\n\n    auto object = injector.create\nexample\n().object;\n    assert(dynamic_cast\nimpl1*\n(object.i1_.get()));\n    assert(dynamic_cast\nimpl2*\n(object.i2_.get()));\n    assert(42 == object.i);\n  }\n}\n\n\n\n\nExample\n\n\n\n\n Modules Example\n\n\n\n\n\n\nProviders\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nProviders are responsible for creating objects using given \nConfiguration\n.\n\n\nSemantics\n\n\nnamespace type_traits {\n  struct direct; // T(...)\n  struct uniform; // T{...}\n  struct heap; // new T\n  struct stack; // T\n}\n\nnamespace providers {\n  class provider {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\nstruct config : di::config {\n  template\nclass TInjector\n\n  static auto provider(const TInjector\n) noexcept { return providers::stack_over_heap{}; }\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTInjector\n\n\n-\n\n\ninjector\n\n\n-\n\n\n\n\n\n\nis_creatable\nT, TArgs...\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\ntrue_type/false_type\n\n\n\n\n\n\nget(const TInit\n, const TMemory\n, TArgs\n...)\n\n\nTInit\n -\n direct/uniform, \nTMemory\n -\n heap/stack\n\n\nCreates type \nT\n with \nTArgs...\n\n\nT\n\n\n\n\n\n\n\n\n \nNote\n\nProvider used by \ninjector\n might changed locally via \nmake_injector\n or globally via \nBOOST_DI_CFG\n.\n\n\n\nTest\n\n\n\nclass heap_no_throw {\n public:\n  template \nclass...\n\n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template \nclass T         // implementation\n          , class TInit     // direct()/uniform{}\n          , class TMemory   // heap/stack\n          , class... TArgs\n\n  auto get(const TInit\n, const TMemory\n, TArgs\n... args) const noexcept {\n    return new (std::nothrow) T{std::forward\nTArgs\n(args)...};\n  }\n};\n\nclass my_provider : public di::config {\n public:\n  static auto provider(...) noexcept { return heap_no_throw{}; }\n};\n\nint main() {\n  auto injector = di::make_injector\nmy_provider\n();\n  assert(0 == injector.create\nint\n());\n}\n\n\n\n\nExample\n\n\n\n\n Custom Provider Example\n\n\n Pool Provider Example\n\n\n\n\n\n\n\n--- \ndi::providers::stack_over_heap (default)\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nCreates objects on the stack whenever possible, otherwise on the heap.\n\n\nSemantics\n\n\nnamespace providers {\n  class stack_over_heap {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_creatable\nT, TArgs...\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\ntrue_type/false_type\n\n\n\n\n\n\nget(const TInit\n, const TMemory\n, TArgs\n...)\n\n\nTInit\n -\n direct/uniform, \nTMemory\n -\n heap/stack\n\n\nCreates type \nT\n with \nTArgs...\n\n\nT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\n\n\nTMemory\n\n\n\n\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nconst T\n\n\nstack\n\n\n\n\n\n\nT\n\n\nstack\n\n\n\n\n\n\nT*\n\n\nheap\n\n\n\n\n\n\nconst T*\n\n\nheap\n\n\n\n\n\n\nstd::unique_ptr\n\n\nheap\n\n\n\n\n\n\nstd::shared_ptr\n\n\nheap\n\n\n\n\n\n\nstd::weak_ptr\n\n\nheap\n\n\n\n\n\n\nboost::shared_ptr\n\n\nheap\n\n\n\n\n\n\nis_polymorphic\nT\n\n\nheap\n\n\n\n\n\n\n\n\nTest\n\n\n\nclass my_provider : public di::config {\n public:\n  // this is default in di::config\n  static auto provider(...) noexcept { return di::providers::stack_over_heap{}; }\n};\n\nint main() {\n  auto injector = di::make_injector\nmy_provider\n();\n  injector.create\nint\n();                           // stack\n  std::unique_ptr\nint\n i{injector.create\nint*\n()};  // heap\n  (void)i;\n}\n\n\n\n\nExample\n\n\n\n\n Custom Provider Example\n\n\n Pool Provider Example\n\n\n\n\n\n\n\n--- \ndi::providers::heap\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBasic provider creates objects on the heap (always).\n\n\nSemantics\n\n\nnamespace providers {\n  class heap {\n    public:\n      template \nclass T, class... TArgs\n\n      struct is_creatable;\n\n      template \n\n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n      \n auto get(const TInit\n, const TMemory\n, TArgs\n... args) const;\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_creatable\nT, TArgs...\n\n\ncreatable\nTArgs...>\n\n\nVerify whether \nT\n is creatable with \nTArgs...\n\n\ntrue_type/false_type\n\n\n\n\n\n\nget(const TInit\n, const TMemory\n, TArgs\n...)\n\n\nTInit\n -\n direct/uniform, \nTMemory\n -\n heap/stack\n\n\nCreates type \nT\n with \nTArgs...\n\n\nT\n\n\n\n\n\n\n\n\nTest\n\n\n\nclass heap_no_throw {\n public:\n  template \nclass...\n\n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template \nclass T         // implementation\n          , class TInit     // direct()/uniform{}\n          , class TMemory   // heap/stack\n          , class... TArgs\n\n  auto get(const TInit\n, const TMemory\n, TArgs\n... args) const noexcept {\n    return new (std::nothrow) T{std::forward\nTArgs\n(args)...};\n  }\n};\n\nclass my_provider : public di::config {\n public:\n  static auto provider(...) noexcept { return heap_no_throw{}; }\n};\n\nint main() {\n  auto injector = di::make_injector\nmy_provider\n();\n  assert(0 == injector.create\nint\n());\n}\n\n\n\n\nExample\n\n\n\n\n Custom Provider Example\n\n\n Pool Provider Example\n\n\n Mocks Provider Extension\n\n\n\n\n\n\nPolicies\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nPolicies operates on dependencies in order to limit allowed behaviour or visit created types during run-time.\nPolicies are set up via \nConfiguration\n.\n\n\n \nNote\n\nBy default [Boost].DI has NO policies enabled.\n\n\n\nSemantics\n\n\ntemplate \nclass... TPolicies\n requires callable\nTPolicies...\n\nauto make_policies(TPolicies...) noexcept;\n\nstruct config : di::config {\n  template\nclass TInjector\n\n  static auto policies(const TInjector\n) noexcept { return make_policies(...); }\n};                                                                        |\n                                                                          |\n// policy                                                                 /\ntemplate\nclass T\n   \n-----------------------------------------------------\nvoid operator()(const T\n);\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTInjector\n\n\n-\n\n\ninjector\n\n\n-\n\n\n\n\n\n\nmake_policies\nTPolicies...\n\n\ncallable\nTPolicies...>\n\n\nCreates policies\n\n\ncallable\n list\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nT::type\n\n\nType to be created\n\n\nstd::shared_ptr\nint\n\n\n\n\n\n\nT::expected\n\n\nDecayed 'Interface' type\n\n\ninterface\n\n\n\n\n\n\nT::given\n\n\nDecayed 'Given' type\n\n\nimplementatoin\n\n\n\n\n\n\nT::name\n\n\nAnnotation name\n\n\nmy_name\n\n\n\n\n\n\nT::arity\n\n\nNumber of constructor arguments\n\n\nintegral_constant\nint, 3\n\n\n\n\n\n\nT::scope\n\n\nscope\n\n\nsingleton\n\n\n\n\n\n\nT::is_root\n\n\nIs the root object (a type \ncreate\n was called with)\n\n\ntrue_type\n/\nfalse_type\n\n\n\n\n\n\n\n\n \nNote\n\nIn order for injector to verify policies they have to be created using \nconfig\n and passed via \nTConfig\n in \nmake_injector\n\nor set it globally via \nBOOST_DI_CFG\n.\n\n\n\nTest\n\n\n\nclass print_types_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    return di::make_policies([](auto type) {\n      using arg = typename decltype(type)::type;\n      std::cout \n typeid(arg).name() \n std::endl;\n    });\n  }\n};\n\nint main() {\n  auto injector = di::make_injector\nprint_types_policy\n();\n  injector.create\nint\n();  // output: int\n}\n\n\n\n\n\nclass print_types_info_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    return di::make_policies([](auto arg) {\n      using T = decltype(arg);\n      using type = typename T::type;\n      using name = typename T::name;\n      using expected = typename T::expected;\n      using given = typename T::given;\n      using scope = typename T::scope;\n      auto ctor_size = T::arity::value;\n\n      std::cout \n ctor_size \n std::endl\n                \n typeid(type).name() \n std::endl\n                \n typeid(expected).name() \n std::endl\n                \n typeid(given).name() \n std::endl\n                \n typeid(name).name() \n std::endl\n                \n typeid(scope).name() \n std::endl;\n    });\n  }\n};\n\nint main() {\n  auto injector = di::make_injector\nprint_types_info_policy\n(\n    di::bind\ni1\n().to\nimpl1\n()\n  );\n  injector.create\nstd::unique_ptr\ni1\n();\n}\n\n\n\n\nExample\n\n\n\n\n Custom Policy Example\n\n\n Types Dumper Extension\n\n\n UML Dumper Extension\n\n\n\n\n\n\n\n--- \ndi::policies::constructible\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nConstructible policy limits constructor parameters to explicitly allowed.\n\n\n \nNote\n\nBy default constructible policy disables creation of any constructor parameters.\n\n\n\nSemantics\n\n\nnamespace policies {\n  struct _ { }; // placeholder\n\n  constexpr auto include_root = true;\n\n  template\nclass T\n\n  struct is_root; // true when is the root type (`create\nRooType\n()`)\n\n  template\nclass T\n\n  struct is_bound; // true when type is bound with 'di::bind\nT\n'\n\n  template \nclass T\n\n  struct is_injected; // true when type is injected using 'BOOST_DI_INJECT' or is 'fundamental'\n\n  template\nbool IncludeRoot = false, class T\n\n  auto constructible(const T\n) noexcept;\n}\n\nnamespace operators {\n  template\nclass X\n\n  inline auto operator!(const X\n)\n\n  template\nclass X, class Y\n\n  inline auto operator\n(const X\n, const Y\n);\n\n  template\nclass X, class Y\n\n  inline auto operator||(const X\n, const Y\n);\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nis_root\nT\n\n\n-\n\n\nVerify whether type \nT\n is a root type\n\n\ntrue_type/false_type\n\n\n\n\n\n\nis_bound\nT\n\n\n-\n\n\nVerify whether type \nT\n is bound\n\n\ntrue_type/false_type\n\n\n\n\n\n\nis_injected\nT\n\n\n-\n\n\nVerify whether type \nT\n is injected via \nBOOST_DI_INJECT\n\n\ntrue_type/false_type\n\n\n\n\n\n\n\n\n \nNote\n\nIn order to allow logic operators using namespace \nboost::di::policies::operators\n has to be used.\n\n\n\nTest\n\n\n#include \nboost/di.hpp\n\n\n\nclass injected_and_bound : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(\n      constructible(is_injected\ndi::_\n{} \n is_bound\ndi::_\n{})\n    );\n  }\n};\n\nstruct T {\n  BOOST_DI_INJECT(T, int, double) {}\n};\n\nint main() {\n  auto injector = di::make_injector\ninjected_and_bound\n(\n    di::bind\n().to(42)\n  , di::bind\n().to(87.0)\n  );\n\n  injector.create\nT\n();\n}\n\n\n\n\nclass all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include \nboost/di.hpp\n\n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same\ndi::_, int\n{} || is_bound\ndi::_\n{}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create\nint\n());\n  // di::make_injector().create\ndouble\n(); // compile error\n  assert(42.0 == make_injector(di::bind\ndouble\n().to(42.0)).create\ndouble\n());\n}\n\n\n\n\n \nNote\n\nSTL type traits are supported and might be combined with [Boost].DI traits in order to limit constructor types\nFor example, \nstd::is_same\n_, int\n{} || std::is_constructible\n_, int, int\n{} || std::is_base_of\nint, _\n{}\n, etc...\n\n\n\nExample\n\n\n\n\n Custom Policy Example\n\n\n Types Dumper Extension\n\n\n UML Dumper Extension\n\n\n\n\n\n\nConcepts\n\n\nConcepts are types constraints which ensure that only given types which are satisfied by the constraint will be allowed.\nIf type doesn't satisfy the concept short and descriptive error message is provided.\n\n\n\n--- \ndi::concepts::boundable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nBindings\n type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass TExpected, class TGiven\n\nconcept bool boundable() {\n  return is_complete\nTExpected\n()\n      \n is_complete\nTGiven\n()\n      \n (is_base_of\nTExpected, TGiven\n() || is_convertible\nTGiven, TExpected\n());\n}\n\ntemplate \nclass... Ts\n\nconcept bool boundable() {\n  return is_supported\nTs\n()...\n      \n is_movable\nTs\n()...\n      \n (is_base_of\ninjector, Ts\n()... || is_base_of\ndependency, Ts\n()...);\n}\n\n\n\nSemantics\n\n\nboundable\nT\n\nboundable\nTs...\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTs...\n\n\nBindings to be verified\n\n\ntrue_type if constraint is satisfied, \nError\n otherwise\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_disallowed_qualifiers\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has disallowed qualifiers\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind\nint*\n().to(42) /** type\nint*\n::has_disallowed_qualifiers **/\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_has_disallowed_qualifiers.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_abstract\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is abstract\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0, 1 -\n no additional info, 2 -\n info about why type \nT\n is abstract\n\n\n\n\n\n\n\n\n#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 2\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct i {\n  virtual ~i() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct impl : i {};\n\nint main() {\n  di::make_injector(\n    di::bind\ni\n().to\nimpl\n() /** type\nimpl\n::is_abstract **/\n    /** unimplemented pure virtual method 'dummy' in 'impl' **/\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_abstract.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_not_related_to\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is not related to type \nU\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind\nint\n().to\ndouble\n() /** type\ndouble\n::is_not_related_to\nint\n **/\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_not_related_to.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_bound_more_than_once\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is bound more than once\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind\nint\n.to(42) /** type\nint\n::is_bound_more_than_once **/\n  , di::bind\nint\n.to(87) // [di::override]\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_bound_more_than_once.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::is_neither_a_dependency_nor_an_injector\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n is neither a dependency nor an injector\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct dummy {};\n  di::make_injector(\n    dummy{} /** type\ndummy\n::is_neither_a_dependency_nor_an_injector **/\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_neither_a_dependency_nor_an_injector.cpp\n\n\n\n\n\n\n\n--- \ndi::concepts::callable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nPolicy\n type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool callable() {\n  return requires(T object) {\n    { object(...) };\n  }\n}\n\n\n\nSemantics\n\n\ncallable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\npolicy\nTPolicy\n::requires_\ncall_operator\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\npolicy \nTPolicy\n requires a call operator\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config : di::config {\n    struct dummy {};\n    static auto policies(...) { return di::make_policies(dummy{}); }\n  };\n\n  di::make_injector\ntest_config\n();\n  /** policy\ntest_config::dummy\n::requires_\ncall_operator\n **/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/callable_requires_call_operator.cpp\n\n\n\n\n\n\n\n--- \ndi::concepts::configurable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nConfiguration\n type requirement.\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool configurable() {\n  return requires(T object) {\n    return providable\ndecltype(T::provider(...))\n \n callable\ndecltype(T::policies(...))\n();\n  }\n}\n\n\n\nSemantics\n\n\nconfigurable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nconfig\nTConfig\n::requires_\nprovider\nprovidable_type (...)\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nconfig \nT\n requires only providable and callable types\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config /*: di::config*/ {\n    static auto policies(...) { return di::make_policies(); }\n  };\n\n  di::make_injector\ntest_config\n();\n  /** config\ntest_config\n::requires_\nprovider\nprovidable_type (...)\n **/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/configurable_requires_callable_and_providable.cpp\n\n\n\n\n\n\n\n--- \ndi::concepts::creatable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nRequirement for type \nT\n which is going to be created via \ninjector\n.create\nT\n()\n\n\nSynopsis\n\n\nnamespace type_traits {\n  template\nclass T\n\n  using ctor_traits; // returns list of constructor parameters\n}\n\ntemplate \nclass T, class... TArgs\n\nconcept bool creatable() {\n  return is_constructible\nT, TArgs...\n() \n\n         is_constructible\nTArgs, type_traits::ctor_traits\nTArgs\n...\n();\n}\n\n\n\nSemantics\n\n\ncreatable\nT, TArgs...\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nabstract_type\nT\n::is_not_bound\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nabstract type \nT\n is not bound\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'type is not bound, did you forget to add: 'di::bind\n.to\n()'?'\n\n\n\n\n\n\n\n\n#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr\ninterface\n) {}\n};\n\nint main() {\n  di::make_injector().create\nexample\n(); /** creatable constraint not satisfied **/\n  /** abstract_type\ninterface\n::is_not_bound\n   *  type is not bound, did you forget to add: \n   *   'di::bind\ninterface\n.to\nimplementation\n()'?\n   */\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_abstract_type_is_not_bound.cpp\n\n\n\n\n#define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr\ninterface\n) {}\n};\n\nint main() {\n  di::injector\nexample\n injector = di::make_injector(); /** creatable constraint not satisfied **/\n  /** abstract_type\ninterface\n::is_not_bound\n   *  type is not bound, did you forget to add: 'di::bind\ninterface\n.to\nimplementation\n()'?\n   */\n  (void)injector;\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_expose_abstract_type_is_not_bound.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_ambiguous_number_of_constructor_parameters::given\nGiven\n::expected\nExpected\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has ambiguous number of constructor parameters where \nGiven\n were provided but \nExpected\n were expected\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'verify BOOST_DI_INJECT_TRAITS or di::ctor_traits'\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    BOOST_DI_INJECT_TRAITS(int, int);  // 2 parameters\n    T(int, int, int, int) {}           // 4 parameters\n  };\n\n  auto injector = di::make_injector();\n  injector.create\nT\n(); /** creatable constraint not satisfied **/\n  /** type\nT\n::has_ambiguous_number_of_constructor_parameters::given\n2\n::expected\n4\n\n   * verify BOOST_DI_INJECT_TRAITS or di::ctor_traits\n   */\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_ambiguous_number_of_constructor_parameters.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\ntype\nT\n::has_to_many_constructor_parameters::max\nMax\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ntype \nT\n has to many constructor parameter where maximum number is \nMax\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters'\n\n\n\n\n\n\n\n\n#define BOOST_DI_CFG_CTOR_LIMIT_SIZE 2  // specify max number of constructor parameters\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int, int, int) {}  // 3 parameters\n  };\n\n  auto injector = di::make_injector();\n  injector.create\nT\n(); /** creatable constraint not satisfied **/\n  /** type\nT\n::has_to_many_constructor_parameters::max\n2\n\n   *  increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters\n   */\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_to_many_constructor_parameters.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\nscoped\nTScope\n::is_not_convertible_to\nT\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nscope \nTScope\n is not convertible to type \nT\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind\n.in(scope)'?'\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int*) {}\n  };\n  auto injector = di::make_injector(\n    di::bind\nint\n().in(di::singleton)\n  );\n\n  injector.create\nT\n(); /** creatable constraint not satisfied **/\n  /** scoped\nsingleton\n::is_not_convertible_to\nint *\n\n   *  scoped object is not convertible to the requested type,\n   *    did you mistake the scope: 'di::bind\nT\n.in(scope)'?\n   */\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_scoped_is_not_convertible_to.cpp\n\n\n\n\n\n\n\n\n\n\nError\n\n\nscoped\ninstance\n::is_not_convertible_to\nT\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\ninstance is not convertible to type \nT\n\n\n\n\n\n\nBOOST_DI_CFG_DIAGNOSTICS_LEVEL\n\n\n0 -\n 'constraint not satisfied', 1 -\n (0) + abstract type is not bound, 2 -\n (1) + creation tree\n\n\n\n\n\n\nSuggestion\n\n\n'instance is not convertible to the requested type, verify binding: 'di::bind\n.to(value)'?'\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int\n) {}\n  };\n  auto injector = di::make_injector(\n    di::bind\n().to(42)\n  );\n\n  injector.create\nT\n(); /** creatable constraint not satisfied **/\n  /** scoped\ninstance\n::is_not_convertible_to\nint \n\n   *  instance is not convertible to the requested type,\n   *    verify binding: 'di::bind\nT\n.to(value)'?\n   */\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_instance_is_not_convertible_to.cpp\n\n\n\n\n \nNote\n\nSuggestions are not supported/displayed by MSVC-2015.\n\n\n\n\n\n\n--- \ndi::concepts::providable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nProvider\n type requirement.\n\n\nSynopsis\n\n\nnamespace type_traits {\n  struct direct;\n  struct uniform;\n  struct stack;\n  struct heap;\n}\n\ntemplate \nclass T\n\nconcept bool providable() {\n  return requires(T object) {\n    { object.template get\n_\n(type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n    { object.template is_creatable\n_\n(type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n  }\n}\n\n\n\nSemantics\n\n\nprovidable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nprovider\nTProvider\n::requires_\nget\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nprovider \nTProvider\n requires \nget\n method\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config : di::config {\n    struct dummy {};\n    static auto provider(...) { return dummy{}; }\n  };\n  di::make_injector\ntest_config\n(); /** provider\ntest_config::dummy\n::requires_\nget\n **/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/providable_requires_get.cpp\n\n\n\n\n\n\n\n--- \ndi::concepts::scopable\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nScope\n type requirement.\n\n\nSynopsis\n\n\nstruct _ {}; // any type\n\ntemplate \nclass T\n\nconcept bool scopable() {\n  return requires(T) {\n    typename scope\n_, _\n::is_referable;\n    { T::scope\n_, _\n{}.try_create() };\n    { T::scope\n_, _\n{}.create() };\n  }\n}\n\n\n\nSemantics\n\n\nscopable\nT\n\n\n\n\nExample\n\n\n\n\n\n\n\n\nError\n\n\nscope\nTScope\n::requires_\ncreate\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nscope \nTScope\n requires \ncreate\n method\n\n\n\n\n\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n  struct dummy {};\n  di::make_injector(\n    di::bind\nint\n().in(dummy{})); /** scope\ndummy\n::requires_\ncreate\n **/\n  );\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/scopable_requires_create.cpp\n\n\n\n\n\n\nConfiguration\n\n\n\n--- \ndi::config\n ---\n\n\nHeader\n\n\n#include \nboost/di.hpp\n\n\n\n\nDescription\n\n\nInjector\n configuration.\n\n\nSynopsis\n\n\nstruct config {\n  static auto provider(...) noexcept;\n  static auto policies(...) noexcept;\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nprovider()\n\n\nprovidable\n\n\nCreates provider\n\n\nprovidable\n\n\n\n\n\n\npolicies()\n\n\ncallable\n\n\nCreates policies\n\n\ncallable\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBOOST_DI_CFG\n\n\nGlobal configuration allows to customize provider and policies\n\n\n\n\n\n\n\n\nSemantics\n\n\ndi::make_injector\nconfig\n(...)\n// or\n#define BOOST_DI_CFG config // change default\ndi::make_injector(...)\n\n\n\nTest\n\n\nclass all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include \nboost/di.hpp\n\n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same\ndi::_, int\n{} || is_bound\ndi::_\n{}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create\nint\n());\n  // di::make_injector().create\ndouble\n(); // compile error\n  assert(42.0 == make_injector(di::bind\ndouble\n().to(42.0)).create\ndouble\n());\n}\n\n\n\n\nExample\n\n\n\n\n Configuration Example\n\n\n Custom Policy Example\n\n\n Custom Provider Example", 
            "title": "User Guide"
        }, 
        {
            "location": "/user_guide/index.html#injector", 
            "text": "Injector is a core component providing types creation functionality using  bindings .  ---  di::make_injector  ---  Header  #include  boost/di.hpp   Description  Creates  injector  type.  Semantics  template class... TDeps  requires boundable TDeps... \nclass injector {\npublic:\n  using deps; // list of dependencies\n  using config; // configuration\n\n  injector(injector ) = default;\n  template  class... Ts  // no requirements\n  injector(core::injector Ts... ) noexcept;\n  explicit injector(const TDeps ...) noexcept;\n\n  template  class T \n  injector  operator=(T  other) noexcept;\n\n  template class T  requires creatable T \n  T create() const;\n};     Expression  Requirement  Description  Returns      TDeps...  boundable TDeps...>  Bindings  to be used as configuration  -    create T ()  creatable T>  Creates type  T  T        Type  T  Is allowed?  Note      T  \u2714  -    T*  \u2714  Ownership transfer!    const T*  \u2714  Ownership transfer!    T  \u2714  -    const T  \u2714  Reference with  singleton  / Temporary with  unique    T  \u2714  -    std::unique_ptr T  \u2714  -    std::shared_ptr T  \u2714  -    std::weak_ptr T  \u2714  -    boost_shared_ptr T  \u2714  -     template \n  class TConfig = di::config\n, class... TBindings  requires configurable TConfig    boundable TBindings... \nauto make_injector(TBindings...) noexcept;     Expression  Requirement  Description  Returns      TConfig  configurable TConfig>  Configuration  per  injector  -    make_injector(TBindings...)  boundable TBindings...>  Creates  injector  with given  Bindings  injector     Test  \nint main() {\n  auto injector = di::make_injector();\n\n  assert(0 == injector.create int ());\n}  Example    Hello World Example   Create Objects Tree Example    Injection in a nutshell  (implementation detail)  The main interface of the injector is a  create  method.\nWhen  create  method is called for type  T  the magic happens.\nFirstly, policies are verified (for example, whether the type  T  is allowed to be created).\nThen, the constructor traits are deduced ( ctor_traits  ) for type  T  and dependencies of the constructor\nparameters are resolved ( binder ).  wrapper  is used to convert internal representation\nof the dependency into a required type (ex.  shared_ptr T ). Whole process is repeated\nrecursively for all required parameters of  T  constructor.  struct direct; // T(...)\nstruct uniform; // T{...}\n\ntemplate class T, class... TArgs  is_braces_constructible; // type T is constructible using T{...}\ntemplate class T, class... TArgs  is_constructible; // Type T is constructible using T(...)\n\ntemplate class T  is_injectable; // Type T uses BOOST_DI_INJECT or BOOST_DI_INJECT_TRAITS\n\ntemplate class TConfig, class... TBindings  // For Example, TBindings = { di::bind Interface .to Implementation  }\nstruct core::injector : TBindings... {\n  using config = TConfig;\n  using deps = TBindings...;\n\n  template class T  // For example, T = Interface\n  auto create() const noexcept {\n    TConfig::policies T ()...; // verify policies\n    using Type = core::binder TBindings... ().resolve T (*this); // Type = Implementation\n    return core::wrapper T {dependency.create(provider TInjector {*this}.get Type ())};\n  }\n};\n\ntemplate class TInjector, class TConfig \nstruct provider {\n  template class T  auto get() const noexcept {\n    using pair TInitialization, TCtor...  = decltype(ctor_traits TInjector, T ());\n    return TConfig::provider().get(TInitialization{}, TCtor...);\n  }\n  const TInjector  injector;\n};\n\ntemplate class TInjector \nstruct any_type {\n  template class T \n  operator T() const {\n    return injector.templte create T ();\n  }\n  const TInjector  injector;\n};\n\ntemplate class TInjector, class T \nauto ctor_traits() {\n  if (is_injectable T () {\n    return pair direct, typename T::boost_di_inject__ {}; // BOOST_DI_INJECT(T, args...) -  T(args...)\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i  = 0; --i) {\n    if (is_constructible T, any_type TInjector ... ()) { // ... -  i times\n      return pair direct, any_type TInjector ... {}; // T(any_type...)\n    }\n  }\n\n  for (auto i = BOOST_DI_CFG_CTOR_LIMIT_SIZE; i  = 0; --i) {\n    if (is_braces_constructible T, any_type TInjector ... ()) { // ... -  i times\n      return pair uniform, any_type TInjector ... {}; // T{any_type...}\n    }\n  }\n\n  return error(...);\n};    Note  Automatic injection  depends on template implicit conversion operator and therefore\nconversion constructors  template class I  T(I)  are not supported and have to be injected using  BOOST_DI_INJECT ,  BOOST_DI_INJECT_TRAITS ,  di::inject  or  di::ctor_traits .", 
            "title": "Injector"
        }, 
        {
            "location": "/user_guide/index.html#bindings", 
            "text": "Bindings define dependencies configuration describing what types will be created\nand what values will be passed into them.  \n---  di::bind  ---  Header  #include  boost/di.hpp   Description  Allows to bind interface to implementation and associate value with it.  Semantics  struct override; // overrides given configuration\n\nnamespace detail {\n  template class I, class... Is/*any_of*/  requires boundable I, Is... \n  struct bind {\n    bind(bind ) noexcept = default;\n\n    template  class T  requires !is_array I    boundable I, T \n    auto to() noexcept;\n\n    template  class... Ts  requires is_array I    boundable Ts... \n    auto to() noexcept;\n\n    template class T  requires boundable I, T \n    auto to(T ) noexcept;\n\n    template class TScope  requires scopable TScope \n    auto in(const TScope  = di::deduce) noexcept;\n\n    template class TName  // no requirements\n    auto named(const TName  = {}) noexcept;\n\n    auto operator[](const override ) noexcept;\n  };\n} // detail\n\ntemplate class... Ts  requires boundable Ts... \ndetail::bind Ts...  bind{};     Expression  Requirement  Description  Returns      I ,  Is...  boundable I, Is...>  'Interface' types  -    to T  boundable T>  Binds  I, Is...  to  T  type  boundable    to Ts...  boundable Ts...>  Binds  I, Is...  to  Ts...  type  boundable    to(T )  boundable T>  Binds  I, Is...  to  T  object  boundable    in(const TScope )  scopable TScope>  Binds  I, Is...  in TScope`  boundable    named(const TName )  -  Binds  I, Is...  using  named  annotation  boundable    operator[](const override )  -  Overrides given binding  boundable       Note \nCheck out also  instance  scope to read more about binding to values:  di::bind .to(value) .     Expression  Description      Multiple Interfaces     di::bind Interface1, Interface2, ... .to Implementation ()  Binds  Interface1, Interface2, ...  to  Implementation  using one object    Multiple Bindings  (std::array, std::vector, std::set)     di::bind int[] .to({1, 2, ...})  Binds  int  to values  1, 2, ...    di::bind Interface*[] .to Implementation1, Implementation2, ... ()  Binds  Interface  to  Implementation1, Implementation2, ...    Dynamic Bindings     di::bind Interface .to([](const auto  injector) { return injector.template create Implementation ()})  Allows to bind  Interface  depending on a run-time condition     Test  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1 ().to impl1 ()\n  );\n\n  auto object = injector.create std::unique_ptr i1 ();\n  assert(dynamic_cast impl1* (object.get()));\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  );\n\n  assert(42 == injector.create int ());\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind ().to(42)\n  );\n\n  assert(42 == injector.create int ());\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to std::integral_constant int, 42 ()\n  );\n\n  assert(42 == injector.create int ());\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1, i2 ().to impl ()\n  );\n\n  auto object1 = injector.create std::shared_ptr i1 ();\n  auto object2 = injector.create std::shared_ptr i2 ();\n  assert(dynamic_cast impl* (object1.get()));\n  assert(dynamic_cast impl* (object2.get()));\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1 ().to([ ](const auto  injector) -  i1  {\n      if (true)\n        return injector.template create impl1 ();\n      else\n        return injector.template create impl ();\n    })\n  );\n\n  auto  object = injector.create i1 ();\n  assert(dynamic_cast impl1* ( object));\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1*[] ().to impl, impl1 ()\n  );\n\n  auto v = injector.create std::vector std::unique_ptr i1 ();\n  assert(2 == v.size());\n  assert(dynamic_cast impl* (v[0].get()));\n  assert(dynamic_cast impl1* (v[1].get()));\n}  \nint main() {\n  auto il = {1, 2, 3};\n  auto injector = di::make_injector(\n    di::bind int[] ().to(il) // or di::bind int*[] .to(il)\n  );\n\n  auto v = injector.create std::vector int ();\n  assert(3 == v.size());\n  assert(1 == v[0]);\n  assert(2 == v[1]);\n  assert(3 == v[2]);\n}  \nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind int ().to(123) [di::override]\n  );\n\n  assert(123 == injector.create int ());\n}  \nint main() {\n  auto injector = di::make_injector(\n#if defined(__cpp_variable_templates)\n      di::bind i1 .to impl1 ()\n#else\n      di::bind i1 ().to impl1 ()  // no variable templates\n#endif\n          );\n\n  auto object = injector.create std::unique_ptr i1 ();\n  assert(dynamic_cast impl1* (object.get()));\n}  Example    Bindings Example   Forward Bindings Example   Dynamic Bindings Example   Multiple Bindings Example   Constructor Bindings Extension", 
            "title": "Bindings"
        }, 
        {
            "location": "/user_guide/index.html#injections", 
            "text": "Constructor Injection  is the most powerful of available injections.\nIt guarantees initialized state of data members. [Boost].DI constructor injection is achieved without any additional work from the user.  \n---  automatic (default)  ---  Header  #include  boost/di.hpp   Description  [Boost].DI will deduce the best available constructor to be used for injection - unique constructor with the longest parameter list.\nIf the default behavior should be changed constructor has to be explicitly marked with BOOST_DI_INJECT  or  BOOST_DI_INJECT_TRAITS  or di::ctor_traits] or  di::inject .    Note \nAutomatic constructor parameters deduction is limited to  BOOST_DI_CFG_CTOR_LIMIT_SIZE , which by default is set to 10.  Semantics  class T {\npublic:\n  T(auto parameter1, auto parameter2, ..., auto parameterN);\n};     Expression  Requirement  Description  Returns      parameter1-parameterN  -  N  constructor parameter  -       Note \n[Boost].DI is not able to automatically distinguish between ambiguous constructors with the same (longest) number of parameters.\nUse  BOOST_DI_INJECT  or  BOOST_DI_INJECT_TRAITS  or  di::ctor_traits  or  di::inject  to explicitly mark constructor to be injected.  Test  \nstruct T {\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  \nstruct T {\n  int a;     // = 0;\n  double d;  // = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  \nstruct T {\n  T();\n  T(int a) : a(a) {}\n  T(int a, double d) : a(a), d(d) {}  // longest will be chosen\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  \nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d, ...) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  Example    Automatic Injection Example   Constructor Signature Example   Lazy Extension   XML Injection Extension    \n---  BOOST_DI_INJECT  ---  Header  #include  boost/di.hpp   Description  BOOST_DI_INJECT is a macro definition used to explicitly say [Boost].DI which constructor should be used as well as to annotate types - see  annotations  for further reding.\nWhen class has more than one constructor [Boost].DI will by default choose the one with the longest parameter list.\nIn case of constructors ambiguity, [Boost].DI is not able to choose the best one.\nThen BOOST_DI_INJECT becomes handy to point which constructor should be used.  Semantics  struct T {\n    BOOST_DI_INJECT(T, ...) { }\n};     Expression  Requirement  Description  Returns      T  -  Class/Struct name  -    ...  -  T  constructor parameters  -       Note \nBOOST_DI_INJECT constructor parameters is limited to  BOOST_DI_CFG_CTOR_LIMIT_SIZE , which by default is set to 10.  Test  \nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  BOOST_DI_INJECT(T, int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  Example    Constructor Injection Example   Concepts Extension    \n---  BOOST_DI_INJECT_TRAITS  ---  Header  #include  boost/di.hpp   Description  BOOST_DI_INJECT_TRAITS is a macro definition used to define constructor traits.  Semantics  struct T {\n  BOOST_DI_INJECT_TRAITS(...) { }\n  T(...) { }\n};     Expression  Requirement  Description  Returns      ...  -  T  constructor parameters  -       Note \nBOOST_DI_INJECT_TRAITS constructor parameters is limited to  BOOST_DI_CFG_CTOR_LIMIT_SIZE , which by default is set to 10.  Test  \nstruct T {\n  BOOST_DI_INJECT_TRAITS(int, double);\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  \nclass example {\n public:\n  BOOST_DI_INJECT_TRAITS(int);\n  explicit example(int i, double d = 42.0) : i(i), d(d) {}\n\n  int i = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector();\n  auto object = injector.create example ();\n  assert(0 == object.i);\n  assert(42.0 == object.d);\n}  Example    Constructor Injection Example    \n---  di::inject  ---  Header  #include  boost/di.hpp   Description  di::inject  informs [Boost].DI about constructor parameters.\nIt's useful for generated/generic classes as it doesn't have constructor parameters size limitations.  Semantics  struct T {\n  using boost_di_inject__ = di::inject ... ;\n  T(...) {}\n};     Expression  Requirement  Description  Returns      ...  -  T  constructor parameters  -       Note  di::inject  has no limitations if it comes to constructor parameters, however,  named  parameters are not allowed.\nMoreover, you can replace  di::inject  with any variadic type list type to remove dependency to [Boost].DI.\nFor example,  template class...  struct type_list{};   using boost_di_inject__ = type_list ... ;   Test  \nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n  using boost_di_inject__ = di::inject int, double ;\n\n  int a = 0;\n  double d = 0.0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  \nstruct T {\n  using boost_di_inject__ = di::inject \n    int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int ;\n\n  T(int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int\n  , int, int, int, int, int, int, int, int, int, int) { }\n};\n\nint main() {\n  auto injector = di::make_injector();\n  injector.create T ();  // compile clean\n}  Example    Constructor Injection Example    \n---  di::ctor_traits  ---  Header  #include  boost/di.hpp   Description  di::ctor_traits  is a trait in which constructor parameters for type  T  might be specified.\nIt's useful for third party classes you don't have access to and which can't be created using  automatic  injection.  Semantics  namespace boost {\nnamespace di {\n  template  \n  struct ctor_traits T  {\n    BOOST_DI_INJECT_TRAITS(...); // or using type = di::inject ... ;\n  };\n}}  Test  \nstruct T {\n  T(double d, int a) : a(a), d(d) {}\n  T(int a, double d) : a(a), d(d) {}\n\n  int a = 0;\n  double d = 0.0;\n};\n\nnamespace boost {\nnamespace di {\ntemplate  \nstruct ctor_traits T  {\n  BOOST_DI_INJECT_TRAITS(int, double);\n};\n}  // namespace di\n}  // namespace boost\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87.0 == object.d);\n}  Example    Constructor Injection Example", 
            "title": "Injections"
        }, 
        {
            "location": "/user_guide/index.html#annotations", 
            "text": "Annotations are type properties specified in order to refer to a type by the name instead of the type it self.\nThey are useful when constructor has more than one parameter of the same type.\nFor example,  T(int, int) .  \n---  (named = name)  ---  Header  #include  boost/di.hpp   Description  Named parameters are handy to distinguish different constructor parameters of the same type.    T(int value1, int value2);  In order to inject proper values into  value1  and  value2  they have to be differentiate somehow.\n[Boost].DI solution for this problem are annotations.    Note \nAnnotations might be set only when constructor is marked using  BOOST_DI_INJECT  or  BOOST_DI_INJECT_TRAITS .  Semantics  auto Name = []{}; // just an object\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = Name) type type_name [= default_value], ...);\n};     Expression  Requirement  Description  Returns      Name  -  Object representing named type  -     Example  BOOST_DI_INJECT(T, (named = value_1) int value1, (named = value_2) int value2);    Note \nImplementation of constructor doesn't require annotations, only constructor definition requires them.  Test  \nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = int1) int a, (named = int2) int b) : a(a), b(b) {}\n  int a = 0;\n  int b = 0;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().named(int1).to(42)\n  , di::bind int ().named(int2).to(87)\n  );\n  {\n    auto object = injector.create T ();\n    assert(42 == object.a);\n    assert(87 == object.b);\n  }\n  {\n    auto object = T(42, 87);\n    assert(42 == object.a);\n    assert(87 == object.b);\n  }\n}  \nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = int1) int a, (named = int2) int b);\n  int a = 0;\n  int b = 0;\n};\n\nT::T(int a, int b) : a(a), b(b) {}\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().named(int1).to(42)\n  , di::bind int ().named(int2).to(87)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87 == object.b);\n}  \nauto int1 = [] {};\nauto int2 = [] {};\n\nstruct T {\n  T(int a, int b) : a(a), b(b) {}\n  int a = 0;\n  int b = 0;\n};\n\nnamespace boost {\nnamespace di {\ntemplate  \nstruct ctor_traits T  {\n  BOOST_DI_INJECT_TRAITS((named = int1) int, (named = int2) int);\n};\n}  // namespace di\n}  // namespace boost\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().named(int1).to(42)\n  , di::bind int ().named(int2).to(87)\n  );\n  auto object = injector.create T ();\n  assert(42 == object.a);\n  assert(87 == object.b);\n}  \nauto n1 = [] {};\nauto n2 = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = n1) int i1\n                   , (named = n1) int i2\n                   , (named = n2) int i3\n                   , int i4\n                   , (named = n1)std::string s)\n    : i1(i1), i2(i2), i3(i3), i4(i4), s(s) {}\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n  int i4 = 0;\n  std::string s;\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind int ().named(n1).to(42)\n  , di::bind int ().named(n2).to(87)\n  , di::bind std::string ().named(n1).to( str )\n  );\n  auto object = injector.create T ();\n  assert(42 == object.i1);\n  assert(42 == object.i2);\n  assert(87 == object.i3);\n  assert(0 == object.i4);\n  assert( str  == object.s);\n}  Example    Annotations Example   Named Parameters Extension   Assisted Injection Extension", 
            "title": "Annotations"
        }, 
        {
            "location": "/user_guide/index.html#scopes", 
            "text": "Header  #include  boost/di.hpp   Description  Scopes are responsible for creating and maintaining life time of dependencies.\nIf no scope will be given,  deduce  scope will be assumed.  Semantics  template  class TExpected, class TGiven \nstruct scope {\n  template  class T \n  using is_referable;\n\n  template  class T, class TName, class TProvider \n  static auto try_create(const TProvider );\n\n  template  class T, class TName, class TProvider \n  auto create(const TProvider );\n};     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T        Type/Scope  unique  singleton  instance      T  \u2714  -  \u2714    T  -  \u2714  \u2714    const T  \u2714 (temporary)  \u2714  \u2714    T* (transfer ownership)  \u2714  -  -    const T*  \u2714  -  -    T  \u2714  -  \u2714    std::unique_ptr  \u2714  -  -    std::shared_ptr  \u2714  \u2714  \u2714    boost::shared_ptr  \u2714  \u2714  - / \u2714 converted to    std::weak_ptr  -  \u2714  - / \u2714 converted to     Test  \nstruct custom_scope {\n  template  class TExpected, class \n  struct scope {\n    template  class... \n    using is_referable = std::false_type;\n\n    template  class T, class, class TProvider \n    static auto try_create(const TProvider  provider) -  decltype(std::shared_ptr TExpected {provider.get()});\n\n    template  class T, class, class TProvider \n    auto create(const TProvider  provider) {\n      return std::shared_ptr TExpected {provider.get()};\n    }\n  };\n};\n\nint main() {\n  auto injector = di::make_injector(\n    di::bind i1 ().in(custom_scope{}).to impl1 ()\n  );\n  assert(injector.create std::shared_ptr i1 () != injector.create std::shared_ptr i1 ());\n}  Example    Custom Scope Example   Scoped Scope Extension   Session Scope Extension   Shared Scope Extension    \n---  di::deduce (default)  ---  Header  #include  boost/di.hpp   Description  Default scope which will be converted to one of the scopes depending on the type.     Type  Scope      T  unique    T  singleton    const T  unique  (temporary) /  singleton    T*  unique  (ownership transfer)    const T*  unique  (ownership transfer)    T  unique    std::unique_ptr  unique    std::shared_ptr  singleton    boost::shared_ptr  singleton    std::weak_ptr  singleton     Semantics  namespace scopes {\n  struct deduce {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}\n\nscopes::deduce deduce;     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test  \nstruct T {\n  T(const std::shared_ptr i1  sp, std::unique_ptr i2  up, int  i, double d) : sp(sp), up(std::move(up)), i(i), d(d) {}\n\n  std::shared_ptr i1  sp; /*singleton*/\n  std::unique_ptr i2  up; /*unique*/\n  int  i;                 /*instance*/\n  double d;               /*unique*/\n};\n\nint main() {\n  auto i = 42;\n  auto injector = di::make_injector(\n    di::bind i1 ().to impl1 ()\n  , di::bind i2 ().to impl2 ()\n  , di::bind int ().to(i)\n  , di::bind double ().to(87.0)\n  );\n  auto object1 = injector.create std::unique_ptr T ();\n  auto object2 = injector.create std::unique_ptr T ();\n  assert(object1- sp == object2- sp);\n  assert(object1- up != object2- up);\n  assert(42 == object1- i);\n  assert( i ==  object1- i);\n  assert(42 == object2- i);\n  assert( i ==  object2- i);\n  assert(87.0 == object1- d);\n  assert(87.0 == object2- d);\n  i = 12;\n  assert(i == object2- i);\n  assert( i ==  object2- i);\n}  Example    Deduce Scope Example   Scopes Example    \n---  di::instance (di::bind .to(value))  ---  Header  #include  boost/di.hpp   Description  Scope representing values - passed externally. The life time of the object depends on the user.\n[Boost].DI is not maintaining the life time of these objects, however, values and strings will be copied and managed by the library.     Type  instance[in] ( bind .to(in) )  instance[out] ( injector.create out () )      T  \u2714  \u2714    T  \u2714  \u2714    const T  \u2714  \u2714    T*  -  -    const T*  -  -    T  \u2714  \u2714    std::unique_ptr  -  -    std::shared_ptr  \u2714  \u2714    boost::shared_ptr  -  \u2714    std::weak_ptr  -  \u2714     Semantics  namespace scopes {\n  struct instance {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test  \nint main() {\n  auto l = 42l;\n  auto b = false;\n  auto injector = di::make_injector(\n    di::bind int ().to(0)\n  , di::bind int ().to(42)[di::override]\n  , di::bind i1 ().to(std::make_shared impl ())\n  , di::bind long ().to(l)\n  , di::bind short ().to([] { return 87; })\n  , di::bind i2 ().to([ ](const auto  injector) -  std::shared_ptr i2  {\n      return b ? injector.template create std::shared_ptr impl2 () : nullptr; })\n  );\n\n  assert(42 == injector.create int ());\n  assert(injector.create std::shared_ptr i1 () == injector.create std::shared_ptr i1 ());\n  assert(l == injector.create long ());\n  assert( l ==  injector.create long ());\n  assert(87 == injector.create short ());\n  {\n    auto object = injector.create std::shared_ptr i2 ();\n    assert(nullptr == object);\n  }\n  {\n    b = true;\n    auto object = injector.create std::shared_ptr i2 ();\n    assert(dynamic_cast impl2* (object.get()));\n  }\n}  Example    Scopes Example   Bindings Example    \n---  di::singleton  ---  Header  #include  boost/di.hpp   Description  Scope representing shared value between all instances as well as threads.\nSingleton scope will be deduced in case of reference,  std::shared_ptr ,  boost::shared_ptr  or  std::weak_ptr .    Note \nSingleton scope will convert automatically between  std::shared_ptr  and  boost::shared_ptr  if required.     Type  singleton      T  -    T  \u2714    const T  \u2714    T*  -    const T*  -    T  -    std::unique_ptr  -    std::shared_ptr  \u2714    boost::shared_ptr  \u2714    std::weak_ptr  \u2714     Semantics  namespace scopes {\n  struct singleton {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}\n\nscopes::singleton singleton;     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1 ().in(di::singleton).to impl1 ()\n  );\n\n  assert(injector.create std::shared_ptr i1 () == injector.create std::shared_ptr i1 ());\n}  Example    Scopes Example   Eager Singletons Example    \n---  di::unique  ---  Header  #include  boost/di.hpp   Description  Scope representing unique/per request value. A new instance will be provided each time type will be requested.     Type  unique      T  \u2714    T  -    const T  \u2714 (temporary)    T*  \u2714 (ownership transfer)    const T*  \u2714 (ownership transfer)    T  \u2714    std::unique_ptr  \u2714    std::shared_ptr  \u2714    boost::shared_ptr  \u2714    std::weak_ptr  -     Semantics  namespace scopes {\n  struct unique {\n    template  class TExpected, class TGiven \n    struct scope {\n      template  class T \n      using is_referable;\n\n      template  class T, class TName, class TProvider \n      static auto try_create(const TProvider );\n\n      template  class T, class TName, class TProvider \n      auto create(const TProvider );\n    };\n  };\n}\n\nscopes::unique unique;     Expression  Requirement  Description  Returns      TExpected  -  'Interface' type  -    TGiven  -  'Implementation' type  -    is_referable T  -  Verifies whether scope value might be converted to a reference  true_type/false_type    try_create T, TName, TProvider  providable TProvider>  Verifies whether type  T  might be created  true_type/false_type    create T, TName, TProvider  providable TProvider>  Creates type  T  T     Test  \nint main() {\n  auto injector = di::make_injector(\n    di::bind i1 ().in(di::unique).to impl1 ()\n  );\n\n  assert(injector.create std::shared_ptr i1 () != injector.create std::shared_ptr i1 ());\n}  Example    Scopes Example", 
            "title": "Scopes"
        }, 
        {
            "location": "/user_guide/index.html#modules", 
            "text": "Header  #include  boost/di.hpp   Description  Modules allow to split  bindings  configuration into smaller  injectors .\nModule might be installed by passing it into  make_injector .  Semantics  auto module = di::make_injector(...);\ndi::injector Ts...  module = di::make_injector(...);     Expression  Description  Note      auto module = di::make_injector(...)  All types are exposed from  module  module.create T ()  is allowed for any  T    di::injector Ts...  module = di::make_injector(...)  Only  Ts...  types are exposed from  module  module.create T ()  is allowed only for  T   =  Ts...     Test  \nstruct T {\n  T(std::unique_ptr i1  i1, std::unique_ptr i2  i2, int i) : i1_(std::move(i1)), i2_(std::move(i2)), i(i) {}\n\n  std::unique_ptr i1  i1_;\n  std::unique_ptr i2  i2_;\n  int i = 0;\n};\n\nauto module1 = [] {\n  return di::make_injector(\n    di::bind i1 ().to impl1 ()\n  , di::bind int ().to(42)\n  );\n};\n\nauto module2 = [] {\n  return di::make_injector(\n    di::bind i2 ().to impl2 ()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module1(), module2());\n  auto object = injector.create std::unique_ptr T ();\n  assert(dynamic_cast impl1* (object- i1_.get()));\n  assert(dynamic_cast impl2* (object- i2_.get()));\n  assert(42 == object- i);\n  auto up1 = injector.create std::unique_ptr i1 ();\n  assert(dynamic_cast impl1* (up1.get()));\n  auto up2 = injector.create std::unique_ptr i2 ();\n  assert(dynamic_cast impl2* (up2.get()));\n}  \nstruct T {\n  T(std::shared_ptr i1  i1, std::shared_ptr i2  i2, int i) : i1_(i1), i2_(i2), i(i) {}\n\n  std::shared_ptr i1  i1_;\n  std::shared_ptr i2  i2_;\n  int i;\n};\n\ndi::injector T  module(const int  i) noexcept {\n  return di::make_injector(\n    di::bind i1 ().to impl1 ()\n  , di::bind i2 ().to impl2 ()\n  , di::bind int ().to(i)\n  );\n}\n\nint main() {\n  auto injector = di::make_injector(module(42));\n  auto object = injector.create T ();\n  assert(dynamic_cast impl1* (object.i1_.get()));\n  assert(dynamic_cast impl2* (object.i2_.get()));\n  assert(42 == object.i);\n  // injector.create std::unique_ptr i1 (); // compile error\n  // injector.create std::unique_ptr i2 (); // compile error\n}  \nauto module = []() -  di::injector std::unique_ptr i1 , std::unique_ptr i2  {\n  return di::make_injector(\n    di::bind i1 ().to impl1 ()\n  , di::bind i2 ().to impl2 ()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  auto up1 = injector.create std::unique_ptr i1 ();\n  assert(dynamic_cast impl1* (up1.get()));\n  auto up2 = injector.create std::unique_ptr i2 ();\n  assert(dynamic_cast impl2* (up2.get()));\n}  Example    Modules Example    \n---  BOOST_DI_EXPOSE  ---  Header  #include  boost/di.hpp   Description  BOOST_DI_EXPOSE is a macro definition allowing to expose  named  parameters via module/ injector .  Semantics  di::injector BOOST_DI_EXPOSE((named = Name) T), ... ;     Expression  Requirement  Description  Returns      Name  -  Named object  -    ...  -  More types to be exposed  -     Test  \nauto my_name = [] {};\n\nstruct T {\n  BOOST_DI_INJECT(T, (named = my_name) std::unique_ptr i1  up) : up(std::move(up)) {}\n  std::unique_ptr i1  up;\n};\n\nauto module = []() -  di::injector BOOST_DI_EXPOSE((named = my_name) std::unique_ptr i1 )  {\n  return di::make_injector(\n    di::bind i1 ().named(my_name).to impl1 ()\n  );\n};\n\nint main() {\n  auto injector = di::make_injector(module());\n  auto object = injector.create std::unique_ptr T ();\n  assert(dynamic_cast impl1* (object- up.get()));\n}  \nstruct T {\n  T(std::shared_ptr i1  i1, std::shared_ptr i2  i2, int i) : i1_(i1), i2_(i2), i(i) {}\n\n  std::shared_ptr i1  i1_;\n  std::shared_ptr i2  i2_;\n  int i;\n};\n\n__BOOST_DI_UNUSED auto name = [] {};\n\ndi::injector T, std::unique_ptr T , BOOST_DI_EXPOSE((named = name) T)  module(const int  i) noexcept {\n  return di::make_injector(\n    di::bind i1 ().to impl1 ()\n  , di::bind i2 ().to impl2 ()\n  , di::bind int ().to(i)\n  );\n}\n\nint main() {\n  auto injector = di::make_injector(module(42));\n  {\n    auto object = injector.create T ();\n    assert(dynamic_cast impl1* (object.i1_.get()));\n    assert(dynamic_cast impl2* (object.i2_.get()));\n    assert(42 == object.i);\n  }\n  {\n    auto object = injector.create std::unique_ptr T ();\n    assert(dynamic_cast impl1* (object- i1_.get()));\n    assert(dynamic_cast impl2* (object- i2_.get()));\n    assert(42 == object- i);\n  }\n  {\n    struct example {\n      BOOST_DI_INJECT(example, (named = name) T object) : object(object) {}\n      T object;\n    };\n\n    auto object = injector.create example ().object;\n    assert(dynamic_cast impl1* (object.i1_.get()));\n    assert(dynamic_cast impl2* (object.i2_.get()));\n    assert(42 == object.i);\n  }\n}  Example    Modules Example", 
            "title": "Modules"
        }, 
        {
            "location": "/user_guide/index.html#providers", 
            "text": "Header  #include  boost/di.hpp   Description  Providers are responsible for creating objects using given  Configuration .  Semantics  namespace type_traits {\n  struct direct; // T(...)\n  struct uniform; // T{...}\n  struct heap; // new T\n  struct stack; // T\n}\n\nnamespace providers {\n  class provider {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}\n\nstruct config : di::config {\n  template class TInjector \n  static auto provider(const TInjector ) noexcept { return providers::stack_over_heap{}; }\n};     Expression  Requirement  Description  Returns      TInjector  -  injector  -    is_creatable T, TArgs...  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  true_type/false_type    get(const TInit , const TMemory , TArgs ...)  TInit  -  direct/uniform,  TMemory  -  heap/stack  Creates type  T  with  TArgs...  T       Note \nProvider used by  injector  might changed locally via  make_injector  or globally via  BOOST_DI_CFG .  Test  \nclass heap_no_throw {\n public:\n  template  class... \n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template  class T         // implementation\n          , class TInit     // direct()/uniform{}\n          , class TMemory   // heap/stack\n          , class... TArgs \n  auto get(const TInit , const TMemory , TArgs ... args) const noexcept {\n    return new (std::nothrow) T{std::forward TArgs (args)...};\n  }\n};\n\nclass my_provider : public di::config {\n public:\n  static auto provider(...) noexcept { return heap_no_throw{}; }\n};\n\nint main() {\n  auto injector = di::make_injector my_provider ();\n  assert(0 == injector.create int ());\n}  Example    Custom Provider Example   Pool Provider Example    \n---  di::providers::stack_over_heap (default)  ---  Header  #include  boost/di.hpp   Description  Creates objects on the stack whenever possible, otherwise on the heap.  Semantics  namespace providers {\n  class stack_over_heap {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}     Expression  Requirement  Description  Returns      is_creatable T, TArgs...  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  true_type/false_type    get(const TInit , const TMemory , TArgs ...)  TInit  -  direct/uniform,  TMemory  -  heap/stack  Creates type  T  with  TArgs...  T        Type  TMemory      T  stack    T  stack    const T  stack    T  stack    T*  heap    const T*  heap    std::unique_ptr  heap    std::shared_ptr  heap    std::weak_ptr  heap    boost::shared_ptr  heap    is_polymorphic T  heap     Test  \nclass my_provider : public di::config {\n public:\n  // this is default in di::config\n  static auto provider(...) noexcept { return di::providers::stack_over_heap{}; }\n};\n\nint main() {\n  auto injector = di::make_injector my_provider ();\n  injector.create int ();                           // stack\n  std::unique_ptr int  i{injector.create int* ()};  // heap\n  (void)i;\n}  Example    Custom Provider Example   Pool Provider Example    \n---  di::providers::heap  ---  Header  #include  boost/di.hpp   Description  Basic provider creates objects on the heap (always).  Semantics  namespace providers {\n  class heap {\n    public:\n      template  class T, class... TArgs \n      struct is_creatable;\n\n      template  \n        class T\n      , class TInit // type_traits::direct/type_traits::uniform\n      , class TMemory // type_traits::heap/type_traits::stack\n      , class... TArgs\n        auto get(const TInit , const TMemory , TArgs ... args) const;\n  };\n}     Expression  Requirement  Description  Returns      is_creatable T, TArgs...  creatable TArgs...>  Verify whether  T  is creatable with  TArgs...  true_type/false_type    get(const TInit , const TMemory , TArgs ...)  TInit  -  direct/uniform,  TMemory  -  heap/stack  Creates type  T  with  TArgs...  T     Test  \nclass heap_no_throw {\n public:\n  template  class... \n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template  class T         // implementation\n          , class TInit     // direct()/uniform{}\n          , class TMemory   // heap/stack\n          , class... TArgs \n  auto get(const TInit , const TMemory , TArgs ... args) const noexcept {\n    return new (std::nothrow) T{std::forward TArgs (args)...};\n  }\n};\n\nclass my_provider : public di::config {\n public:\n  static auto provider(...) noexcept { return heap_no_throw{}; }\n};\n\nint main() {\n  auto injector = di::make_injector my_provider ();\n  assert(0 == injector.create int ());\n}  Example    Custom Provider Example   Pool Provider Example   Mocks Provider Extension", 
            "title": "Providers"
        }, 
        {
            "location": "/user_guide/index.html#policies", 
            "text": "Header  #include  boost/di.hpp   Description  Policies operates on dependencies in order to limit allowed behaviour or visit created types during run-time.\nPolicies are set up via  Configuration .    Note \nBy default [Boost].DI has NO policies enabled.  Semantics  template  class... TPolicies  requires callable TPolicies... \nauto make_policies(TPolicies...) noexcept;\n\nstruct config : di::config {\n  template class TInjector \n  static auto policies(const TInjector ) noexcept { return make_policies(...); }\n};                                                                        |\n                                                                          |\n// policy                                                                 /\ntemplate class T     -----------------------------------------------------\nvoid operator()(const T );     Expression  Requirement  Description  Returns      TInjector  -  injector  -    make_policies TPolicies...  callable TPolicies...>  Creates policies  callable  list        T  Description  Example      T::type  Type to be created  std::shared_ptr int    T::expected  Decayed 'Interface' type  interface    T::given  Decayed 'Given' type  implementatoin    T::name  Annotation name  my_name    T::arity  Number of constructor arguments  integral_constant int, 3    T::scope  scope  singleton    T::is_root  Is the root object (a type  create  was called with)  true_type / false_type       Note \nIn order for injector to verify policies they have to be created using  config  and passed via  TConfig  in  make_injector \nor set it globally via  BOOST_DI_CFG .  Test  \nclass print_types_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    return di::make_policies([](auto type) {\n      using arg = typename decltype(type)::type;\n      std::cout   typeid(arg).name()   std::endl;\n    });\n  }\n};\n\nint main() {\n  auto injector = di::make_injector print_types_policy ();\n  injector.create int ();  // output: int\n}  \nclass print_types_info_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    return di::make_policies([](auto arg) {\n      using T = decltype(arg);\n      using type = typename T::type;\n      using name = typename T::name;\n      using expected = typename T::expected;\n      using given = typename T::given;\n      using scope = typename T::scope;\n      auto ctor_size = T::arity::value;\n\n      std::cout   ctor_size   std::endl\n                  typeid(type).name()   std::endl\n                  typeid(expected).name()   std::endl\n                  typeid(given).name()   std::endl\n                  typeid(name).name()   std::endl\n                  typeid(scope).name()   std::endl;\n    });\n  }\n};\n\nint main() {\n  auto injector = di::make_injector print_types_info_policy (\n    di::bind i1 ().to impl1 ()\n  );\n  injector.create std::unique_ptr i1 ();\n}  Example    Custom Policy Example   Types Dumper Extension   UML Dumper Extension    \n---  di::policies::constructible  ---  Header  #include  boost/di.hpp   Description  Constructible policy limits constructor parameters to explicitly allowed.    Note \nBy default constructible policy disables creation of any constructor parameters.  Semantics  namespace policies {\n  struct _ { }; // placeholder\n\n  constexpr auto include_root = true;\n\n  template class T \n  struct is_root; // true when is the root type (`create RooType ()`)\n\n  template class T \n  struct is_bound; // true when type is bound with 'di::bind T '\n\n  template  class T \n  struct is_injected; // true when type is injected using 'BOOST_DI_INJECT' or is 'fundamental'\n\n  template bool IncludeRoot = false, class T \n  auto constructible(const T ) noexcept;\n}\n\nnamespace operators {\n  template class X \n  inline auto operator!(const X )\n\n  template class X, class Y \n  inline auto operator (const X , const Y );\n\n  template class X, class Y \n  inline auto operator||(const X , const Y );\n}     Expression  Requirement  Description  Returns      is_root T  -  Verify whether type  T  is a root type  true_type/false_type    is_bound T  -  Verify whether type  T  is bound  true_type/false_type    is_injected T  -  Verify whether type  T  is injected via  BOOST_DI_INJECT  true_type/false_type       Note \nIn order to allow logic operators using namespace  boost::di::policies::operators  has to be used.  Test  #include  boost/di.hpp \n\n\nclass injected_and_bound : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(\n      constructible(is_injected di::_ {}   is_bound di::_ {})\n    );\n  }\n};\n\nstruct T {\n  BOOST_DI_INJECT(T, int, double) {}\n};\n\nint main() {\n  auto injector = di::make_injector injected_and_bound (\n    di::bind ().to(42)\n  , di::bind ().to(87.0)\n  );\n\n  injector.create T ();\n}  class all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include  boost/di.hpp \n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same di::_, int {} || is_bound di::_ {}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create int ());\n  // di::make_injector().create double (); // compile error\n  assert(42.0 == make_injector(di::bind double ().to(42.0)).create double ());\n}    Note \nSTL type traits are supported and might be combined with [Boost].DI traits in order to limit constructor types\nFor example,  std::is_same _, int {} || std::is_constructible _, int, int {} || std::is_base_of int, _ {} , etc...  Example    Custom Policy Example   Types Dumper Extension   UML Dumper Extension", 
            "title": "Policies"
        }, 
        {
            "location": "/user_guide/index.html#concepts", 
            "text": "Concepts are types constraints which ensure that only given types which are satisfied by the constraint will be allowed.\nIf type doesn't satisfy the concept short and descriptive error message is provided.  \n---  di::concepts::boundable  ---  Header  #include  boost/di.hpp   Description  Bindings  type requirement.  Synopsis  template  class TExpected, class TGiven \nconcept bool boundable() {\n  return is_complete TExpected ()\n        is_complete TGiven ()\n        (is_base_of TExpected, TGiven () || is_convertible TGiven, TExpected ());\n}\n\ntemplate  class... Ts \nconcept bool boundable() {\n  return is_supported Ts ()...\n        is_movable Ts ()...\n        (is_base_of injector, Ts ()... || is_base_of dependency, Ts ()...);\n}  Semantics  boundable T \nboundable Ts...      Expression  Description  Returns      Ts...  Bindings to be verified  true_type if constraint is satisfied,  Error  otherwise     Example     Error  type T ::has_disallowed_qualifiers      Description  type  T  has disallowed qualifiers     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind int* ().to(42) /** type int* ::has_disallowed_qualifiers **/\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_has_disallowed_qualifiers.cpp      Error  type T ::is_abstract      Description  type  T  is abstract    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0, 1 -  no additional info, 2 -  info about why type  T  is abstract     #define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 2\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct i {\n  virtual ~i() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct impl : i {};\n\nint main() {\n  di::make_injector(\n    di::bind i ().to impl () /** type impl ::is_abstract **/\n    /** unimplemented pure virtual method 'dummy' in 'impl' **/\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_abstract.cpp      Error  type T ::is_not_related_to      Description  type  T  is not related to type  U     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind int ().to double () /** type double ::is_not_related_to int  **/\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_not_related_to.cpp      Error  type T ::is_bound_more_than_once      Description  type  T  is bound more than once     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  di::make_injector(\n    di::bind int .to(42) /** type int ::is_bound_more_than_once **/\n  , di::bind int .to(87) // [di::override]\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_bound_more_than_once.cpp      Error  type T ::is_neither_a_dependency_nor_an_injector      Description  type  T  is neither a dependency nor an injector     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct dummy {};\n  di::make_injector(\n    dummy{} /** type dummy ::is_neither_a_dependency_nor_an_injector **/\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/boundable_type_is_neither_a_dependency_nor_an_injector.cpp    \n---  di::concepts::callable  ---  Header  #include  boost/di.hpp   Description  Policy  type requirement.  Synopsis  template  class T \nconcept bool callable() {\n  return requires(T object) {\n    { object(...) };\n  }\n}  Semantics  callable T   Example     Error  policy TPolicy ::requires_ call_operator      Description  policy  TPolicy  requires a call operator     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config : di::config {\n    struct dummy {};\n    static auto policies(...) { return di::make_policies(dummy{}); }\n  };\n\n  di::make_injector test_config ();\n  /** policy test_config::dummy ::requires_ call_operator  **/\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/callable_requires_call_operator.cpp    \n---  di::concepts::configurable  ---  Header  #include  boost/di.hpp   Description  Configuration  type requirement.  Synopsis  template  class T \nconcept bool configurable() {\n  return requires(T object) {\n    return providable decltype(T::provider(...))    callable decltype(T::policies(...)) ();\n  }\n}  Semantics  configurable T   Example     Error  config TConfig ::requires_ provider providable_type (...)      Description  config  T  requires only providable and callable types     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config /*: di::config*/ {\n    static auto policies(...) { return di::make_policies(); }\n  };\n\n  di::make_injector test_config ();\n  /** config test_config ::requires_ provider providable_type (...)  **/\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/configurable_requires_callable_and_providable.cpp    \n---  di::concepts::creatable  ---  Header  #include  boost/di.hpp   Description  Requirement for type  T  which is going to be created via  injector .create T ()  Synopsis  namespace type_traits {\n  template class T \n  using ctor_traits; // returns list of constructor parameters\n}\n\ntemplate  class T, class... TArgs \nconcept bool creatable() {\n  return is_constructible T, TArgs... ()  \n         is_constructible TArgs, type_traits::ctor_traits TArgs ... ();\n}  Semantics  creatable T, TArgs...   Example     Error  abstract_type T ::is_not_bound      Description  abstract type  T  is not bound    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'type is not bound, did you forget to add: 'di::bind .to ()'?'     #define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr interface ) {}\n};\n\nint main() {\n  di::make_injector().create example (); /** creatable constraint not satisfied **/\n  /** abstract_type interface ::is_not_bound\n   *  type is not bound, did you forget to add: \n   *   'di::bind interface .to implementation ()'?\n   */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_abstract_type_is_not_bound.cpp   #define BOOST_DI_CFG_DIAGNOSTICS_LEVEL 1\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct example {\n  explicit example(std::unique_ptr interface ) {}\n};\n\nint main() {\n  di::injector example  injector = di::make_injector(); /** creatable constraint not satisfied **/\n  /** abstract_type interface ::is_not_bound\n   *  type is not bound, did you forget to add: 'di::bind interface .to implementation ()'?\n   */\n  (void)injector;\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_expose_abstract_type_is_not_bound.cpp      Error  type T ::has_ambiguous_number_of_constructor_parameters::given Given ::expected Expected      Description  type  T  has ambiguous number of constructor parameters where  Given  were provided but  Expected  were expected    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'verify BOOST_DI_INJECT_TRAITS or di::ctor_traits'     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    BOOST_DI_INJECT_TRAITS(int, int);  // 2 parameters\n    T(int, int, int, int) {}           // 4 parameters\n  };\n\n  auto injector = di::make_injector();\n  injector.create T (); /** creatable constraint not satisfied **/\n  /** type T ::has_ambiguous_number_of_constructor_parameters::given 2 ::expected 4 \n   * verify BOOST_DI_INJECT_TRAITS or di::ctor_traits\n   */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_ambiguous_number_of_constructor_parameters.cpp      Error  type T ::has_to_many_constructor_parameters::max Max      Description  type  T  has to many constructor parameter where maximum number is  Max    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters'     #define BOOST_DI_CFG_CTOR_LIMIT_SIZE 2  // specify max number of constructor parameters\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int, int, int) {}  // 3 parameters\n  };\n\n  auto injector = di::make_injector();\n  injector.create T (); /** creatable constraint not satisfied **/\n  /** type T ::has_to_many_constructor_parameters::max 2 \n   *  increase BOOST_DI_CFG_CTOR_LIMIT_SIZE value or reduce number of constructor parameters\n   */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_type_has_to_many_constructor_parameters.cpp      Error  scoped TScope ::is_not_convertible_to T      Description  scope  TScope  is not convertible to type  T    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind .in(scope)'?'     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int*) {}\n  };\n  auto injector = di::make_injector(\n    di::bind int ().in(di::singleton)\n  );\n\n  injector.create T (); /** creatable constraint not satisfied **/\n  /** scoped singleton ::is_not_convertible_to int * \n   *  scoped object is not convertible to the requested type,\n   *    did you mistake the scope: 'di::bind T .in(scope)'?\n   */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_scoped_is_not_convertible_to.cpp      Error  scoped instance ::is_not_convertible_to T      Description  instance is not convertible to type  T    BOOST_DI_CFG_DIAGNOSTICS_LEVEL  0 -  'constraint not satisfied', 1 -  (0) + abstract type is not bound, 2 -  (1) + creation tree    Suggestion  'instance is not convertible to the requested type, verify binding: 'di::bind .to(value)'?'     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct T {\n    T(int ) {}\n  };\n  auto injector = di::make_injector(\n    di::bind ().to(42)\n  );\n\n  injector.create T (); /** creatable constraint not satisfied **/\n  /** scoped instance ::is_not_convertible_to int  \n   *  instance is not convertible to the requested type,\n   *    verify binding: 'di::bind T .to(value)'?\n   */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/creatable_instance_is_not_convertible_to.cpp     Note \nSuggestions are not supported/displayed by MSVC-2015.   \n---  di::concepts::providable  ---  Header  #include  boost/di.hpp   Description  Provider  type requirement.  Synopsis  namespace type_traits {\n  struct direct;\n  struct uniform;\n  struct stack;\n  struct heap;\n}\n\ntemplate  class T \nconcept bool providable() {\n  return requires(T object) {\n    { object.template get _ (type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n    { object.template is_creatable _ (type_traits::direct/type_traits::uniform{}, type_traits::stack/type_traits::heap{}, ...) };\n  }\n}  Semantics  providable T   Example     Error  provider TProvider ::requires_ get      Description  provider  TProvider  requires  get  method     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct test_config : di::config {\n    struct dummy {};\n    static auto provider(...) { return dummy{}; }\n  };\n  di::make_injector test_config (); /** provider test_config::dummy ::requires_ get  **/\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/providable_requires_get.cpp    \n---  di::concepts::scopable  ---  Header  #include  boost/di.hpp   Description  Scope  type requirement.  Synopsis  struct _ {}; // any type\n\ntemplate  class T \nconcept bool scopable() {\n  return requires(T) {\n    typename scope _, _ ::is_referable;\n    { T::scope _, _ {}.try_create() };\n    { T::scope _, _ {}.create() };\n  }\n}  Semantics  scopable T   Example     Error  scope TScope ::requires_ create      Description  scope  TScope  requires  create  method     #include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n  struct dummy {};\n  di::make_injector(\n    di::bind int ().in(dummy{})); /** scope dummy ::requires_ create  **/\n  );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/errors/scopable_requires_create.cpp", 
            "title": "Concepts"
        }, 
        {
            "location": "/user_guide/index.html#configuration", 
            "text": "---  di::config  ---  Header  #include  boost/di.hpp   Description  Injector  configuration.  Synopsis  struct config {\n  static auto provider(...) noexcept;\n  static auto policies(...) noexcept;\n};     Expression  Requirement  Description  Returns      provider()  providable  Creates provider  providable    policies()  callable  Creates policies  callable        Expression  Description      BOOST_DI_CFG  Global configuration allows to customize provider and policies     Semantics  di::make_injector config (...)\n// or\n#define BOOST_DI_CFG config // change default\ndi::make_injector(...)  Test  class all_must_be_bound_unless_int;\n#define BOOST_DI_CFG all_must_be_bound_unless_int\n#include  boost/di.hpp \n\n\nclass all_must_be_bound_unless_int : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(std::is_same di::_, int {} || is_bound di::_ {}));\n  }\n};\n\nint main() {\n  assert(0 == di::make_injector().create int ());\n  // di::make_injector().create double (); // compile error\n  assert(42.0 == make_injector(di::bind double ().to(42.0)).create double ());\n}  Example    Configuration Example   Custom Policy Example   Custom Provider Example", 
            "title": "Configuration"
        }, 
        {
            "location": "/examples/index.html", 
            "text": "Hello World\n\n\nBindings\n\n\nDynamic Bindings\n\n\nForward Bindings\n\n\nIs Creatable\n\n\nMultiple Bindings\n\n\nBinding Non-owning Pointer\n\n\nBinding Templates\n\n\nBinding To Constructor\n\n\nAutomatic Injection\n\n\nConstructor Signature\n\n\nConstructor Injection\n\n\nMultiple Interface\n\n\nAnnotations\n\n\nDeduce Scope\n\n\nCustom Scope\n\n\nEager Singletons\n\n\nModules\n\n\nModules (hpp/cpp)\n\n\nCustom Policy\n\n\nCustom Provider\n\n\nPool Provider\n\n\nConfiguration\n\n\nPolymorphism\n\n\nInheritance\n\n\nType-Erasure\n\n\nFunction\n\n\nVariant\n\n\nTemplates\n\n\nConcepts\n\n\n\n\n\n\n\n\n\n\nHello World\n\n\n#include \nboost/di.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace di = boost::di;\n\n\nstruct iworld {\n  virtual ~iworld() noexcept = default;\n};\n\nstruct world : iworld {\n  world() { std::cout \n \n world!\n \n std::endl; }\n};\n\nstruct hello {\n  explicit hello(int i) {\n    assert(42 == i);\n    std::cout \n \nhello\n;\n  }\n};\n\ntemplate \nclass T = class Greater\n\nstruct example {\n  T h;\n  iworld\n w;\n};\n\nint main() {\n  const auto injector = di::make_injector(\n     di::bind\niworld\n().to\nworld\n()    // bind interface to implementation\n   , di::bind\n().to(42)               // bind int to value 42\n   , di::bind\nclass Greater\n().to\nhello\n()   // bind template to type\n  );\n\n  /*\ncreate `example`\n*/\n  injector.create\nexample\n(); // or di::create\nexample\n(injector)\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/try_it.cpp\n\n\n\n\nBindings\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct service {\n  BOOST_DI_INJECT(service, const std::shared_ptr\ninterface1\n sp, bool b, int i, std::function\nint()\n f,\n                  (named = int_name) const int ni)\n      : sp(sp) {\n    assert(dynamic_cast\nimplementation1_2*\n(sp.get()));  // overridden\n    assert(!b);                                          // default initialization\n    assert(i == 42);\n    assert(f() == 87);\n    assert(ni == 123);\n  }\n\n  std::shared_ptr\ninterface1\n sp;\n};\n\nstruct app {\n  BOOST_DI_INJECT(app, service copy, std::shared_ptr\ninterface1\n sp, std::unique_ptr\ninterface2\n ap, int i,\n                  (named = some_name) const std::string\n s, float\n f, const double\n d)\n      : str(s), f(f), d(d) {\n    assert(dynamic_cast\nimplementation2*\n(ap.get()));\n    assert(dynamic_cast\nimplementation1_2*\n(sp.get()));  // overridden\n    assert(copy.sp.get() == sp.get());\n    assert(i == 42);\n    assert(str == \nmy_text\n);\n    assert(f == 0.f);\n    assert(d == 0.f);\n  }\n\n  app\n operator=(const app\n) = delete;\n\n  std::string str;\n  float\n f;\n  const double\n d;\n};\n\nint main() {\n  float f = 0.f;\n  double d = 0.0;\n\n  /*\ncreate injector with `interface` binding to `implementation1`\n*/\n  auto config = [] { return di::make_injector(di::bind\ninterface1\n().to\nimplementation1\n()); };\n\n  /*\ncreate injector with configuration\n*/\n  auto injector = di::make_injector(\n    di::bind\ninterface2\n().to\nimplementation2\n()\n  , di::bind\nint\n().to(42)\n  , di::bind\nstd::string\n().named(some_name).to(\nmy_text\n)\n  , di::bind\n().to(f)\n  , di::bind\n().to(d)\n  , di::bind\nstd::function\nint()\n().to([] { return 87; })\n  , di::bind\n().named(int_name).to(123)\n  , config()\n  , di::bind\ninterface1\n().to(std::make_shared\nimplementation1_2\n())[di::override]\n  );\n\n  /*\ncreate `service_app`\n*/\n  auto service_app = injector.create\napp\n();\n\n  /*\nverify parameter `f` affection by `service_app`\n*/\n  service_app.f = 42.f;\n  assert(f == 42.f);\n\n  d = 42.f;\n  assert(service_app.d == 42.f);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bindings.cpp\n\n\n\n\nDynamic Bindings\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\nmodule configuration\n*/\nauto dynamic_bindings = [](eid\n id) {\n  return di::make_injector(\n      /*\nbind `interface` to lazy lambda expression\n*/\n      di::bind\ninterface\n().to([\n](const auto\n injector) -\n std::shared_ptr\ninterface\n {\n        switch (id) {\n          default:\n            return nullptr;\n          case e1:\n            return injector.template create\nstd::shared_ptr\nimplementation1\n();\n          case e2:\n            return injector.template create\nstd::shared_ptr\nimplementation2\n();\n        }\n\n        return nullptr;\n      }));\n};\n\nint main() {\n  auto id = e1;\n\n  /*\ncreate interface with `id = e1`\n*/\n  auto injector = di::make_injector(dynamic_bindings(id));\n  assert(dynamic_cast\nimplementation1*\n(injector.create\nstd::shared_ptr\ninterface\n().get()));\n\n  id = e2;\n  /*\ncreate interface with `id = e2`\n*/\n  assert(dynamic_cast\nimplementation2*\n(injector.create\nstd::shared_ptr\ninterface\n().get()));\n  (void)id;\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/dynamic_bindings.cpp\n\n\n\n\nForward Bindings\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nclass interface;\nclass implementation;\n\nauto configuration = [] {\n  return di::make_injector(\n    /*\nbinding using fwd declarations, no checking whether types are related*/\n    di::bind\ninterface\n().to\nimplementation\n()\n  );\n};\n\n/*\nbinding using fwd declarations, no checking whether types are related*/\nclass interface {\n public:\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\nclass implementation : public interface {\n public:\n  void dummy() override {}\n};\n\nint main() {\n  /*\nmake injector configuration\n*/\n  auto injector = configuration();\n  assert(dynamic_cast\nimplementation*\n(injector.create\nstd::unique_ptr\ninterface\n().get()));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/fwd_bindings.cpp\n\n\n\n\nIs Creatable\n\n\n#include \nboost/di.hpp\n\n#include \ncassert\n\n\nnamespace di = boost::di;\n\nstruct iworld {\n  virtual ~iworld() noexcept = default;\n  virtual void f() = 0;\n};\n\nstruct world : iworld {\n  void f() override {}\n};\n\nstruct hello {\n  explicit hello(iworld\n) {}\n};\n\nint main() {\n  {\n    const auto injector = di::make_injector(di::bind\niworld\n().to\nworld\n());\n    static_assert(di::is_creatable\nhello\n(injector), \n);\n  }\n\n  {\n    const auto injector = di::make_injector();\n    static_assert(!di::is_creatable\nhello\n(injector), \niworld is not abstract!\n);\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/is_creatable.cpp\n\n\n\n\nMultiple Bindings\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct example {\n  example(std::vector\nstd::unique_ptr\ninterface\n v, std::vector\nint\n i) {\n    assert(v.size() == 4);\n    assert(dynamic_cast\nimplementation1*\n(v[0].get()));\n    assert(dynamic_cast\nimplementation2*\n(v[1].get()));\n    assert(dynamic_cast\nimplementation1*\n(v[2].get()));\n    assert(dynamic_cast\nimplementation2*\n(v[3].get()));\n\n    assert(i.size() == 7);\n    assert(i[0] == 1);\n    assert(i[1] == 2);\n    assert(i[2] == 3);\n    assert(i[3] == 5);\n    assert(i[4] == 8);\n    assert(i[5] == 13);\n    assert(i[6] == 21);\n  }\n};\n\nint main() {\n  auto il = {1, 2, 3, 5, 8, 13, 21};\n  auto injector = di::make_injector(\n    di::bind\nint[]\n().to(il)\n  , di::bind\ninterface* []\n().to\nimplementation1, implementation2, interface, di::named\nclass Implementation2\n()\n  , di::bind\ninterface\n().to\nimplementation1\n()  // \n------------------/                         |\n  , di::bind\ninterface\n().named\nclass Implementation2\n().to\nimplementation2\n()  // \n-------------/\n  );\n\n  injector.create\nexample\n();\n\n  assert(injector.create\nstd::vector\nint\n().size() == 7);\n  assert(injector.create\nstd::set\nint\n().size() == 7);\n\n  assert(injector.create\nstd::vector\nstd::shared_ptr\ninterface\n().size() == 4);\n  assert(injector.create\nstd::set\nstd::shared_ptr\ninterface\n().size() == 2);  // unique instances\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_bindings.cpp\n\n\n\n\nBinding Non-owning Pointer\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nusing Pointer = int;\n\nauto module(Pointer* ptr) { return di::bind\nPointer\n().to(*ptr); }\n\nstruct app {\n  app(Pointer\n ptr) { assert(42 == ptr); }\n};\n\nint main() {\n  di::aux::owner\nPointer*\n ptr{new Pointer{42}};\n\n  auto injector = di::make_injector(module(ptr));\n  injector.create\napp\n();\n\n  delete ptr;\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bind_non_owning_ptr.cpp\n\n\n\n\nBinding Templates\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\ntemplate \nclass T = class Type, class TNumber = class Number\n\nstruct hello {\n  using type = T;\n  explicit hello(const TNumber\n number) : number{number} {}\n  TNumber number;\n};\n\ntemplate \nclass T = int\n\nstruct world {\n  using type = T;\n};\n\nint main() {\n  auto i = 42;\n\n  const auto injector = di::make_injector(\n     di::bind\nclass Type\n().to\nworld\n()\n   , di::bind\nclass Number\n().to\nint\n(i)\n  );\n\n  {\n    const auto hw = injector.create\nhello\n();\n\n    static_assert(std::is_same\nint, decltype(hw)::type::type\n{}, \nType != int\n);\n    assert(42 == hw.number);\n  }\n\n  {\n    const auto hw = injector.create\nstd::shared_ptr\ndecltype(injector.create\nhello\n())\n();\n\n    static_assert(std::is_same\nint, decltype(hw)::element_type::type::type\n{}, \nType != int\n);\n    assert(42 == hw-\nnumber);\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bind_templates.cpp\n\n\n\n\nBinding To Constructor\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nstruct example {\n  example(float, short) {}                  // ambiguous\n  example(int i, double d) : d{d}, i{i} {}  // constructors \n- pick this one\n\n  double d{};\n  int i{};\n};\n\nstruct app {\n  example\n ex;\n};\n\nint main() {\n  {\n    const auto injector = di::make_injector(\n      di::bind\nexample\n()(42, 87.0) // or di::bind\nexample\n().to\nexample\n(42, 87.0)\n    );\n\n    auto object = di::create\napp\n(injector);\n\n    assert(42 == object.ex.i);\n    assert(87.0 == object.ex.d);\n  }\n\n#if defined(__cpp_variable_templates)\n  {\n    const auto injector = di::make_injector(\n      di::bind\nexample\n(42, 87.0)\n    );\n\n    auto object = di::create\napp\n(injector);\n\n    assert(42 == object.ex.i);\n    assert(87.0 == object.ex.d);\n  }\n#endif\n\n  {\n    const auto injector = di::make_injector(\n      di::bind\nexample\n()(42, di::placeholders::_), // inject second argument\n      di::bind\n().to(87.0)\n    );\n\n    auto object = di::create\napp\n(injector);\n\n    assert(42 == object.ex.i);\n    assert(87.0 == object.ex.d);\n  }\n\n  {\n    const auto injector = di::make_injector(\n      di::bind\nexample\n()(di::placeholders::_, 87.0), // inject first argument\n      di::bind\n().to(42)\n    );\n\n    auto object = di::create\napp\n(injector);\n\n    assert(42 == object.ex.i);\n    assert(87.0 == object.ex.d);\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bind_to_constructor.cpp\n\n\n\n\nAutomatic Injection\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n/*\nambiguous constructor with 2 parameters\n*/\nstruct example1 {\n  /*\nambiguous `example1` constructor taking 2 parameters\n*/\n  example1(double, int) { assert(false); }\n\n  /*\nambiguous `example1` constructor taking 2 parameters - marked to be injected by `...`\n*/\n  example1(int i, double d, ...) {\n    assert(i == 42);\n    assert(d == 87.0);\n  }\n};\n\nstruct example2 {\n  /*\nconstructor with 1 parameter marked to be injected by `...`\n*/\n  explicit example2(int i, ...) { assert(i == 42); }\n\n  /*\nconstructor with 3 parameters, but still constructor with 1 and `...` will be chosen\n*/\n  example2(int, double, float) { assert(false); }\n};\n\nint main() {\n  /*\nmake injector and bind named parameters\n*/\n  auto injector = di::make_injector(\n    di::bind\nint\n().to(42)\n  , di::bind\ndouble\n().to(87.0)\n  );\n\n  /*\ncreate `example1`\n*/\n  injector.create\nexample1\n();\n\n  /*\ncreate `example2`\n*/\n  injector.create\nexample2\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/automatic_injection.cpp\n\n\n\n\nConstructor Signature\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\ndefine `example` class as usual\n*/\nclass example {\n public:\n  example(std::unique_ptr\ninterface1\n up, std::shared_ptr\ninterface2\n sp, int i) {\n    assert(dynamic_cast\nimplementation1*\n(up.get()));\n    assert(dynamic_cast\nimplementation2*\n(sp.get()));\n    assert(42 == i);\n  }\n};\n\n/*\ndefine `example` class with different parameters order - won't require any changes in injector configuration\n*/\nclass example_with_different_parameters_order {\n public:\n  example_with_different_parameters_order(std::shared_ptr\ninterface2\n sp, int i, std::unique_ptr\ninterface1\n up) {\n    assert(dynamic_cast\nimplementation1*\n(up.get()));\n    assert(dynamic_cast\nimplementation2*\n(sp.get()));\n    assert(42 == i);\n  }\n};\n\n/*\ndefine `example` class with different parameters order and different types - won't require any changes in injector\n * configuration\n*/\nclass example_with_different_parameters_order_and_types {\n public:\n  example_with_different_parameters_order_and_types(std::unique_ptr\ninterface2\n sp, const int\n i, interface1* up) : up_(up) {\n    assert(dynamic_cast\nimplementation1*\n(up));\n    assert(dynamic_cast\nimplementation2*\n(sp.get()));\n    assert(42 == i);\n  }\n\n  // in order to delete pointer - Boost.DI always transfer ownership to user in case of pointers\n  std::shared_ptr\ninterface1\n up_;\n};\n\nint main() {\n  /*\nmake injector\n*/\n  auto injector = di::make_injector(\n    di::bind\ninterface1\n().to\nimplementation1\n()\n  , di::bind\ninterface2\n().to\nimplementation2\n()\n  , di::bind\nint\n().to(42)\n  );\n\n  /*\ncreate different examples using the same injector configuration\n*/\n  injector.create\nexample\n();\n  injector.create\nexample_with_different_parameters_order\n();\n  injector.create\nexample_with_different_parameters_order_and_types\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_signature.cpp\n\n\n\n\nConstructor Injection\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto name = [] {};\n\nstruct ctor_inject {\n  /*\nconstructor with intrusive named parameter explicitly selected\n*/\n  BOOST_DI_INJECT(ctor_inject, int i1, (named = name) int i2) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nstruct ctor_inject_traits {\n  /*\nconstructor with less intrusive named parameter using traits\n*/\n  BOOST_DI_INJECT_TRAITS(int, (named = name) int);\n  explicit ctor_inject_traits(int i1, int i2 = 0) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nstruct ctor_di_traits {\n  /*\nclass without any changes\n*/\n  explicit ctor_di_traits(int i1, int i2 = 0) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nnamespace boost {\nnamespace di {\n\ntemplate \n\nstruct ctor_traits\nctor_di_traits\n {\n  /*\nno intrusive way of defining named parameters\n*/\n  BOOST_DI_INJECT_TRAITS(int, (named = name) int);\n};\n\n}  // namespace di\n}  // namespace boost\n\nstruct ctor_inject_traits_no_limits {\n  /*\nconstructor with 20 parameters\n*/\n  using boost_di_inject__ =\n      di::inject\nint, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int\n;\n\n  ctor_inject_traits_no_limits(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int,\n                               int) {}\n};\n\nint main() {\n  /*\nmake injector\n*/\n  auto injector = di::make_injector(\n    di::bind\nint\n().named(name).to(42)\n  );\n\n  /*\ncreate dependencies\n*/\n  injector.create\nctor_inject\n();\n  injector.create\nctor_inject_traits\n();\n  injector.create\nctor_di_traits\n();\n\n  injector.create\nctor_inject_traits_no_limits\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp\n\n\n\n\nMultiple Interface\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nclass multiple_interfaces {\n public:\n  multiple_interfaces(const std::shared_ptr\ninterface1\n interface1_, const std::shared_ptr\ninterface2\n interface2_) {\n    assert(dynamic_cast\nimplementation*\n(interface1_.get()));\n    assert(dynamic_cast\nimplementation*\n(interface2_.get()));\n    assert(static_cast\nimplementation*\n(interface1_.get()) == static_cast\nimplementation*\n(interface2_.get()));\n  }\n};\n\nint main() {\n  /*\ncreate injector with binding `implementation` to `interface1` and `interface2` using `di::any_of`\n*/\n  auto injector = di::make_injector(\n    di::bind\ninterface1, interface2\n().to\nimplementation\n()\n  );\n\n  injector.create\nmultiple_interfaces\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_interfaces.cpp\n\n\n\n\nAnnotations\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nauto int_1 = [] {};\nstruct int_2_t {\n} int_2;\n\nclass annotations1 {\n public:\n  /*\nConstructor with named parameters of the same `int` type\n*/\n  BOOST_DI_INJECT(annotations1, (named = int_1) int i1, (named = int_2) int i2, int i3) : i1(i1), i2(i2), i3(i3) {\n    assert(i1 == 42);\n    assert(i2 == 87);\n    assert(i3 == 123);\n  }\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nclass annotations2 {\n public:\n  /*\nConstructor with named parameters of the same `int` type\n*/\n  BOOST_DI_INJECT(annotations2, (named = int_1) int i1, (named = int_2) int i2, int i3);\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nannotations2::annotations2(int i1, int i2, int i3) {\n  assert(i1 == 42);\n  assert(i2 == 87);\n  assert(i3 == 123);\n}\n\n\nclass annotations3 {\n public:\n  /*\nConstructor with named parameters of the same `int` type\n*/\n  BOOST_DI_INJECT(annotations3, (named = \nint1\n_s) int i1, (named = \nint2\n_s) int i2, int i3) : i1(i1), i2(i2), i3(i3) {\n    assert(i1 == 42);\n    assert(i2 == 87);\n    assert(i3 == 123);\n  }\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nint main() {\n  {\n    /*\nmake injector and bind named parameters\n*/\n    auto injector = di::make_injector(\n      di::bind\nint\n().named(int_1).to(42)\n    , di::bind\nint\n().named(int_2).to(87)\n    , di::bind\nint\n().to(123)\n    );\n\n    /*\ncreate `annotations`\n*/\n    injector.create\nannotations1\n();\n    injector.create\nannotations2\n();\n  }\n\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/annotations.cpp\n\n\n\n\nDeduce Scope\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct dependency1 {\n  dependency1(std::shared_ptr\ninterface\n spi /*shared*/\n              ,\n              const std::shared_ptr\ninterface\n spi_ /*shared*/)\n      : spi_(spi), spi__(spi_) {\n    assert(spi.get() == spi_.get());\n  }\n\n  std::shared_ptr\ninterface\n spi_;\n  std::shared_ptr\ninterface\n spi__;\n};\n\nstruct dependency2 {\n  dependency2(std::shared_ptr\ninterface\n spi /*shared*/, int i /*unique*/) : spi_(spi) { assert(i == 0); }\n\n  std::shared_ptr\ninterface\n spi_;\n};\n\nstruct example {\n  example(std::unique_ptr\ndependency1\n dependency1_ /*unique*/\n          ,\n          const dependency2\n dependency2_ /*unique temporary*/) {\n    assert(dependency2_.spi_.get() == dependency1_-\nspi_.get());\n    assert(dependency2_.spi_.get() == dependency1_-\nspi__.get());\n  }\n};\n\nint main() {\n  /*\ncreate injector with deduced `interface`\n*/\n  auto injector = di::make_injector(\n    di::bind\ninterface\n().to\nimplementation\n()  // =\n di::bind\ninterface\n().to\nimplementation\n().in(di::deduce)\n  );\n\n  /*\ncreate `example`\n*/\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/deduce_scope.cpp\n\n\n\n\nCustom Scope\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n/*\ndefine scope class\n*/\nclass custom_scope {\n public:\n  /*\ndefine `entry`, `exit` actions\n*/\n  class entry {};\n  class exit {};\n\n  template \nclass T, class\n\n  class scope {\n    /*\ndefine wrapper for shared_ptr conversion\n*/\n    class custom_wrapper {\n     public:\n      custom_wrapper(const std::shared_ptr\nT\n object)  // non explicit\n          : object_(object) {}\n\n      /*\nconversion operator to shared_ptr\n*/\n      inline operator std::shared_ptr\nT\n() const noexcept { return object_; }\n\n      std::shared_ptr\nT\n object_;\n    };\n\n   public:\n    template \nclass...\n\n    using is_referable = std::false_type;\n\n    template \nclass, class, class TProvider\n\n    static custom_wrapper try_create(const TProvider\n);\n\n    /*\ncreate shared_ptr when in scope out of provider pointer\n*/\n    template \nclass, class, class TProvider\n\n    custom_wrapper create(const TProvider\n provider) const noexcept {\n      return std::shared_ptr\nT\n{provider.get()};\n    }\n  };\n};\n\nstruct example {\n  explicit example(const std::shared_ptr\nint\n sp) : sp_(sp) {}\n  std::shared_ptr\nint\n sp_;\n};\n\nint main() {\n  /*\ncreate injector with `int` in `custom scope`\n*/\n  auto injector = di::make_injector(\n    di::bind\nint\n().in(custom_scope{})\n  );\n\n  assert(injector.create\nexample\n().sp_);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_scope.cpp\n\n\n\n\nEager Singletons\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nauto configuration = [] {\n  return di::make_injector(\n    di::bind\ninterface\n().to\nimplementation\n().in(di::singleton)\n  , di::bind\nint\n().to(42)\n  );\n};\n\nstruct example {\n  example(int i, std::shared_ptr\ninterface\n object) {\n    assert(42 == i);\n    assert(dynamic_cast\nimplementation*\n(object.get()));\n  }\n};\n\nint main() {\n  /*\nmake injector configuration\n*/\n  auto injector = di::make_injector(configuration());\n  assert(0 == implementation::ctor_calls());\n\n  /*\neagerly initialize singletons\n*/\n  eager_singletons(injector);\n  assert(1 == implementation::ctor_calls());\n\n  /*\ncreate `example` with already initialized singletons\n*/\n  injector.create\nexample\n();\n  assert(1 == implementation::ctor_calls());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/eager_singletons.cpp\n\n\n\n\nModules\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\nstruct data {\n  std::shared_ptr\ninterface\n sp;\n};\n\nstruct app {\n  app(std::unique_ptr\ninterface\n up, int i, double d, const data\n data) {\n    assert(dynamic_cast\nimplementation1*\n(up.get()));\n    assert(i == 42);\n    assert(d == 87.0);\n    assert(dynamic_cast\nimplementation2*\n(data.sp.get()));\n  }\n};\n\n/*\n`module1` configuration\n*/\nauto module1 = [] {\n  return di::make_injector(\n    di::bind\ninterface\n().to\nimplementation1\n()\n  );\n};\n\n/*\n`module2` configuration\n*/\nauto module2(const int\n i) {\n  return di::make_injector(\n    di::bind\nint\n().to(i)\n  );\n}\n\n/*\nmodule configuration with exposed `data`\n*/\nauto exposed_module = []() -\n di::injector\nconst data\n {\n  return di::make_injector(\n    di::bind\ninterface\n().to\nimplementation2\n()\n  );\n};\n\nint main() {\n  constexpr auto i = 42;\n  constexpr auto d = 87.0;\n\n  /*\nmodule configuration with movable injector\n*/\n  auto movable_injector = di::make_injector(\n    di::bind\ndouble\n().to(d)\n  );\n\n  /*\ncreate injector and pass `module1`, `module2` and `exposed_module`\n*/\n  auto injector = di::make_injector(\n    module1()\n  , module2(i)\n  , exposed_module()\n  , std::move(movable_injector)\n  );\n\n  /*\ncreate `app`\n*/\n  injector.create\napp\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/modules.cpp\n\n\n\n\nModules (hpp/cpp)\n\n\n\n\nSee \nhttps://github.com/boost-experimental/di/tree/cpp14/example/modules\n\n\n\n\nCustom Policy\n\n\nclass custom_policy;\n#define BOOST_DI_CFG custom_policy\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nclass custom_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(is_bound\ndi::_\n{}));\n  }\n};\n\nstruct example {\n  example(int, double) {}\n};\n\nint main() {\n  /*\ncreate shared_ptr `example` with per injector policy setting\n*/\n  {\n    auto injector = di::make_injector\ncustom_policy\n(\n      di::bind\nint\n().to(42)\n    , di::bind\ndouble\n().to(87.0)\n    );\n\n    injector.create\nexample\n();\n  }\n\n  /*\ncreate shared_ptr `example` with global policy setting\n*/\n  {\n    auto injector = di::make_injector(\n      di::bind\nint\n().to(42)\n    , di::bind\ndouble\n().to(87.0)\n    );\n\n    injector.create\nexample\n();\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp\n\n\n\n\nCustom Provider\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\ndefine `example` class as usual\n*/\nstruct example {\n  explicit example(int i, std::unique_ptr\ninterface\n up) {\n    assert(i == 42);\n    assert(dynamic_cast\nimplementation*\n(up.get()));\n  }\n};\n\n/*\ndefine `custom provider`\n*/\nstruct custom_provider {\n  template \nclass...\n\n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template \nclass T, class TMemory, class... TArgs\n\n  auto get(const di::type_traits::direct\n, const TMemory\n  // stack/heap\n           ,\n           TArgs\n... args) const {\n    return new T(std::forward\nTArgs\n(args)...);\n  }\n\n  template \nclass T, class TMemory, class... TArgs\n\n  auto get(const di::type_traits::uniform\n, const TMemory\n  // stack/heap\n           ,\n           TArgs\n... args) const {\n    return new T{std::forward\nTArgs\n(args)...};\n  }\n};\n\n/*\noverride `di` provider configuration\n*/\nclass config : public di::config {\n public:\n  static auto provider(...) noexcept { return custom_provider{}; }\n};\n\nint main() {\n  /*\nmake injector with simple configuration\n*/\n  auto injector = di::make_injector\nconfig\n(\n    di::bind\nint\n().to(42)\n  , di::bind\ninterface\n().to\nimplementation\n()\n  );\n\n  /*\ncreate `example` using `custom_provider`\n*/\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp\n\n\n\n\nPool Provider\n\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\n\n/*\ndefine `pool provider`\n*/\nstruct pool_provider {\n  template \nclass...\n\n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template \nclass T, class TInitialization, class TMemory, class... TArgs\n\n  auto get(const TInitialization\n  // direct/uniform\n           ,\n           const TMemory\n  // stack/heap\n           ,\n           TArgs\n... args) const {\n    auto memory = pool_allocator::allocate\nT\n();\n    return std::unique_ptr\nT, pool_deleter\n{new (memory) T(std::forward\nTArgs\n(args)...)};\n  }\n};\n\n/*\noverride `di` provider configuration\n*/\nclass config : public di::config {\n public:\n  static auto provider(...) noexcept { return pool_provider{}; }\n};\n\n/*\ndefine `example` class as usual\n*/\nstruct example {\n  explicit example(int i, std::unique_ptr\ninterface, pool_deleter\n up, std::shared_ptr\ninterface\n sp) {\n    assert(i == 42);\n    assert(dynamic_cast\nimplementation*\n(up.get()));\n    assert(dynamic_cast\nimplementation*\n(sp.get()));\n  }\n};\n\nint main() {\n  /*\nmake injector with simple configuration\n*/\n  auto injector = di::make_injector\nconfig\n(\n    di::bind\nint\n().to(42)\n  , di::bind\ninterface\n().to\nimplementation\n()\n  );\n\n  /*\ncreate `example` using configuration with `pool_provider`\n*/\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp\n\n\n\n\nConfiguration\n\n\n#include \nboost/di.hpp\n\n\nnamespace di = boost::di;\n\nint main() {\n#if (BOOST_DI_VERSION \n= 1'0'0)\n  std::cout \n \nstable\n;\n#else\n  std::cout \n \nunstable\n;\n#endif\n  std::cout \n \n version of boost.di [\n \n BOOST_DI_VERSION \n \n]\n \n std::endl;\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/configuration.cpp\n\n\n\n\nPolymorphism\n\n\n\n\nSee \nhttps://github.com/boost-experimental/di/tree/cpp14/example/polymorphism\n\n\n\n\nInheritance\n\n\n#include \ncassert\n\n#include \nmemory\n\n#include \nsstream\n\n\n#include \nexample/polymorphism/common/config.hpp\n\n\n/*\nDynamic polymorphism - inheritance\n*/\nclass Drawable {\n public:\n  virtual ~Drawable() noexcept = default;\n  virtual void draw(std::ostream\n) const = 0;\n};\n\nclass App {\n public:\n  explicit App(std::unique_ptr\nconst Drawable\n drawable) : drawable{std::move(drawable)} {}\n  void draw(std::ostream\n out) const { drawable-\ndraw(out); }\n\n private:\n  std::unique_ptr\nconst Drawable\n drawable;\n};\n\nstruct Square : Drawable {\n  void draw(std::ostream\n out) const override { out \n \nSquare\n; }\n};\n\nstruct Circle : Drawable {\n  void draw(std::ostream\n out) const override { out \n \nCircle\n; }\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create\nApp\n();\n  example.draw(str);\n  assert(\nSquare\n == str.str());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/inheritance.cpp\n\n\n\n\nType Erasure\n\n\n#include \ncassert\n\n#include \nfunctional\n\n#include \nmemory\n\n#include \nsstream\n\n#include \ntype_traits\n\n\n#include \nexample/polymorphism/common/config.hpp\n\n\n/*\nType erasure\n*/\nclass Drawable {\n  std::shared_ptr\nvoid\n ptr{};\n\n public:\n  template \nclass T, class = std::enable_if_t\n!std::is_convertible\nT, Drawable\n::value\n\n  Drawable(T t) : ptr{std::make_shared\nT\n(t)}, draw{[this](auto\n... args) { static_cast\nT*\n(ptr.get())-\ndraw(args...); }} {}\n\n  std::function\nvoid(std::ostream\n)\n draw;\n};\n\nclass App {\n public:\n  explicit App(const Drawable drawable) : drawable{drawable} {}\n  void draw(std::ostream\n out) const { drawable.draw(out); }\n\n private:\n  const Drawable drawable;\n};\n\nstruct Square {\n  void draw(std::ostream\n out) const { out \n \nSquare\n; }\n};\n\nstruct Circle {\n  void draw(std::ostream\n out) const { out \n \nCircle\n; }\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create\nApp\n();\n  example.draw(str);\n  assert(\nSquare\n == str.str());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/type_erasure.cpp\n\n\n\n\nFunction\n\n\n#include \ncassert\n\n#include \nfunctional\n\n#include \nmemory\n\n#include \nsstream\n\n#include \ntype_traits\n\n\n#include \nexample/polymorphism/common/config.hpp\n\n\n/*\nfunction\n*/\nclass Drawable : public std::function\nvoid(std::ostream\n)\n {\n public:\n  using std::function\nvoid(std::ostream\n)\n::function;\n};\n\nclass App {\n public:\n  explicit App(const Drawable drawable) : drawable{drawable} {}\n  void draw(std::ostream\n out) const { drawable(out); }\n\n private:\n  const Drawable drawable;\n};\n\nstruct Square {\n  void operator()(std::ostream\n out) const { out \n \nSquare\n; }\n};\n\nstruct Circle {\n  void operator()(std::ostream\n out) const { out \n \nCircle\n; }\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create\nApp\n();\n  example.draw(str);\n  assert(\nSquare\n == str.str());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/function.cpp\n\n\n\n\nVariant\n\n\n#if defined(__cpp_lib_variant)\n#include \ncassert\n\n#include \nsstream\n\n#include \nvariant\n\n\n#include \nexample/polymorphism/common/config.hpp\n\n\nstruct Square {\n  void draw(std::ostream\n out) const { out \n \nSquare\n; }\n};\n\nstruct Circle {\n  void draw(std::ostream\n out) const { out \n \nCircle\n; }\n};\n\nclass Drawable : public std::variant\nSquare, Circle\n {\n public:\n  using std::variant\nSquare, Circle\n::variant;\n};\n\n/*\nVariant\n*/\nclass App {\n public:\n  explicit App(const Drawable drawable) : drawable{drawable} {}\n\n  void draw(std::ostream\n out) const {\n    std::visit([\nout](const auto\n drawable) { drawable.draw(out); }, drawable);\n  }\n\n private:\n  const Drawable drawable;\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create\nApp\n();\n  example.draw(str);\n  assert(\nSquare\n == str.str());\n}\n\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/variant.cpp\n\n\n\n\nTemplates\n\n\n#include \ncassert\n\n#include \nsstream\n\n\n#include \nexample/polymorphism/common/config.hpp\n\n\n/*\nStatic polymorphism - templates\n*/\ntemplate \ntypename TDrawable = class Drawable\n\nclass App {\n public:\n  explicit App(const TDrawable drawable) : drawable(drawable) {}\n  void draw(std::ostream\n out) const { drawable.draw(out); }\n\n private:\n  const TDrawable drawable;\n};\n\nstruct Square {\n  void draw(std::ostream\n out) const { out \n \nSquare\n; }\n};\n\nstruct Circle {\n  void draw(std::ostream\n out) const { out \n \nCircle\n; }\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create\nApp\n();\n  example.draw(str);\n  assert(\nSquare\n == str.str());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/templates.cpp\n\n\n\n\nConcepts\n\n\n#include \ncassert\n\n#include \nsstream\n\n\n#include \nexample/polymorphism/common/config.hpp\n\n\n\ntemplate \nclass T\n\nconcept bool Drawable = not boost::di::aux::is_complete\nT\n::value or requires(T t, std::ostream\n out) {\n  t.draw(out);\n};\n\n/*\nStatic polymorphism - concepts\n*/\ntemplate \nDrawable TDrawable = class Drawable\n  // requires Drawable\nTDrawable\n\nclass App {\n public:\n  explicit App(const TDrawable drawable) : drawable{drawable} {}\n  void draw(std::ostream\n out) const { drawable.draw(out); }\n\n private:\n  const TDrawable drawable;\n};\n\nstruct Square {\n  void draw(std::ostream\n out) const { out \n \nSquare\n; }\n};\n\nstruct Circle {\n  void draw(std::ostream\n out) const { out \n \nCircle\n; }\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create\nApp\n();\n  example.draw(str);\n  assert(\nSquare\n == str.str());\n}\n\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/concepts.cpp", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/index.html#hello-world", 
            "text": "#include  boost/di.hpp \n#include  cassert \n#include  iostream \n\nnamespace di = boost::di;\n\n\nstruct iworld {\n  virtual ~iworld() noexcept = default;\n};\n\nstruct world : iworld {\n  world() { std::cout     world!    std::endl; }\n};\n\nstruct hello {\n  explicit hello(int i) {\n    assert(42 == i);\n    std::cout    hello ;\n  }\n};\n\ntemplate  class T = class Greater \nstruct example {\n  T h;\n  iworld  w;\n};\n\nint main() {\n  const auto injector = di::make_injector(\n     di::bind iworld ().to world ()    // bind interface to implementation\n   , di::bind ().to(42)               // bind int to value 42\n   , di::bind class Greater ().to hello ()   // bind template to type\n  );\n\n  /* create `example` */\n  injector.create example (); // or di::create example (injector)\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/try_it.cpp", 
            "title": "Hello World"
        }, 
        {
            "location": "/examples/index.html#bindings", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct service {\n  BOOST_DI_INJECT(service, const std::shared_ptr interface1  sp, bool b, int i, std::function int()  f,\n                  (named = int_name) const int ni)\n      : sp(sp) {\n    assert(dynamic_cast implementation1_2* (sp.get()));  // overridden\n    assert(!b);                                          // default initialization\n    assert(i == 42);\n    assert(f() == 87);\n    assert(ni == 123);\n  }\n\n  std::shared_ptr interface1  sp;\n};\n\nstruct app {\n  BOOST_DI_INJECT(app, service copy, std::shared_ptr interface1  sp, std::unique_ptr interface2  ap, int i,\n                  (named = some_name) const std::string  s, float  f, const double  d)\n      : str(s), f(f), d(d) {\n    assert(dynamic_cast implementation2* (ap.get()));\n    assert(dynamic_cast implementation1_2* (sp.get()));  // overridden\n    assert(copy.sp.get() == sp.get());\n    assert(i == 42);\n    assert(str ==  my_text );\n    assert(f == 0.f);\n    assert(d == 0.f);\n  }\n\n  app  operator=(const app ) = delete;\n\n  std::string str;\n  float  f;\n  const double  d;\n};\n\nint main() {\n  float f = 0.f;\n  double d = 0.0;\n\n  /* create injector with `interface` binding to `implementation1` */\n  auto config = [] { return di::make_injector(di::bind interface1 ().to implementation1 ()); };\n\n  /* create injector with configuration */\n  auto injector = di::make_injector(\n    di::bind interface2 ().to implementation2 ()\n  , di::bind int ().to(42)\n  , di::bind std::string ().named(some_name).to( my_text )\n  , di::bind ().to(f)\n  , di::bind ().to(d)\n  , di::bind std::function int() ().to([] { return 87; })\n  , di::bind ().named(int_name).to(123)\n  , config()\n  , di::bind interface1 ().to(std::make_shared implementation1_2 ())[di::override]\n  );\n\n  /* create `service_app` */\n  auto service_app = injector.create app ();\n\n  /* verify parameter `f` affection by `service_app` */\n  service_app.f = 42.f;\n  assert(f == 42.f);\n\n  d = 42.f;\n  assert(service_app.d == 42.f);\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bindings.cpp", 
            "title": "Bindings"
        }, 
        {
            "location": "/examples/index.html#dynamic-bindings", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* module configuration */\nauto dynamic_bindings = [](eid  id) {\n  return di::make_injector(\n      /* bind `interface` to lazy lambda expression */\n      di::bind interface ().to([ ](const auto  injector) -  std::shared_ptr interface  {\n        switch (id) {\n          default:\n            return nullptr;\n          case e1:\n            return injector.template create std::shared_ptr implementation1 ();\n          case e2:\n            return injector.template create std::shared_ptr implementation2 ();\n        }\n\n        return nullptr;\n      }));\n};\n\nint main() {\n  auto id = e1;\n\n  /* create interface with `id = e1` */\n  auto injector = di::make_injector(dynamic_bindings(id));\n  assert(dynamic_cast implementation1* (injector.create std::shared_ptr interface ().get()));\n\n  id = e2;\n  /* create interface with `id = e2` */\n  assert(dynamic_cast implementation2* (injector.create std::shared_ptr interface ().get()));\n  (void)id;\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/dynamic_bindings.cpp", 
            "title": "Dynamic Bindings"
        }, 
        {
            "location": "/examples/index.html#forward-bindings", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nclass interface;\nclass implementation;\n\nauto configuration = [] {\n  return di::make_injector(\n    /* binding using fwd declarations, no checking whether types are related*/\n    di::bind interface ().to implementation ()\n  );\n};\n\n/* binding using fwd declarations, no checking whether types are related*/\nclass interface {\n public:\n  virtual ~interface() noexcept = default;\n  virtual void dummy() = 0;\n};\nclass implementation : public interface {\n public:\n  void dummy() override {}\n};\n\nint main() {\n  /* make injector configuration */\n  auto injector = configuration();\n  assert(dynamic_cast implementation* (injector.create std::unique_ptr interface ().get()));\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/fwd_bindings.cpp", 
            "title": "Forward Bindings"
        }, 
        {
            "location": "/examples/index.html#is-creatable", 
            "text": "#include  boost/di.hpp \n#include  cassert \n\nnamespace di = boost::di;\n\nstruct iworld {\n  virtual ~iworld() noexcept = default;\n  virtual void f() = 0;\n};\n\nstruct world : iworld {\n  void f() override {}\n};\n\nstruct hello {\n  explicit hello(iworld ) {}\n};\n\nint main() {\n  {\n    const auto injector = di::make_injector(di::bind iworld ().to world ());\n    static_assert(di::is_creatable hello (injector),  );\n  }\n\n  {\n    const auto injector = di::make_injector();\n    static_assert(!di::is_creatable hello (injector),  iworld is not abstract! );\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/is_creatable.cpp", 
            "title": "Is Creatable"
        }, 
        {
            "location": "/examples/index.html#multiple-bindings", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct example {\n  example(std::vector std::unique_ptr interface  v, std::vector int  i) {\n    assert(v.size() == 4);\n    assert(dynamic_cast implementation1* (v[0].get()));\n    assert(dynamic_cast implementation2* (v[1].get()));\n    assert(dynamic_cast implementation1* (v[2].get()));\n    assert(dynamic_cast implementation2* (v[3].get()));\n\n    assert(i.size() == 7);\n    assert(i[0] == 1);\n    assert(i[1] == 2);\n    assert(i[2] == 3);\n    assert(i[3] == 5);\n    assert(i[4] == 8);\n    assert(i[5] == 13);\n    assert(i[6] == 21);\n  }\n};\n\nint main() {\n  auto il = {1, 2, 3, 5, 8, 13, 21};\n  auto injector = di::make_injector(\n    di::bind int[] ().to(il)\n  , di::bind interface* [] ().to implementation1, implementation2, interface, di::named class Implementation2 ()\n  , di::bind interface ().to implementation1 ()  //  ------------------/                         |\n  , di::bind interface ().named class Implementation2 ().to implementation2 ()  //  -------------/\n  );\n\n  injector.create example ();\n\n  assert(injector.create std::vector int ().size() == 7);\n  assert(injector.create std::set int ().size() == 7);\n\n  assert(injector.create std::vector std::shared_ptr interface ().size() == 4);\n  assert(injector.create std::set std::shared_ptr interface ().size() == 2);  // unique instances\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_bindings.cpp", 
            "title": "Multiple Bindings"
        }, 
        {
            "location": "/examples/index.html#binding-non-owning-pointer", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nusing Pointer = int;\n\nauto module(Pointer* ptr) { return di::bind Pointer ().to(*ptr); }\n\nstruct app {\n  app(Pointer  ptr) { assert(42 == ptr); }\n};\n\nint main() {\n  di::aux::owner Pointer*  ptr{new Pointer{42}};\n\n  auto injector = di::make_injector(module(ptr));\n  injector.create app ();\n\n  delete ptr;\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bind_non_owning_ptr.cpp", 
            "title": "Binding Non-owning Pointer"
        }, 
        {
            "location": "/examples/index.html#binding-templates", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\ntemplate  class T = class Type, class TNumber = class Number \nstruct hello {\n  using type = T;\n  explicit hello(const TNumber  number) : number{number} {}\n  TNumber number;\n};\n\ntemplate  class T = int \nstruct world {\n  using type = T;\n};\n\nint main() {\n  auto i = 42;\n\n  const auto injector = di::make_injector(\n     di::bind class Type ().to world ()\n   , di::bind class Number ().to int (i)\n  );\n\n  {\n    const auto hw = injector.create hello ();\n\n    static_assert(std::is_same int, decltype(hw)::type::type {},  Type != int );\n    assert(42 == hw.number);\n  }\n\n  {\n    const auto hw = injector.create std::shared_ptr decltype(injector.create hello ()) ();\n\n    static_assert(std::is_same int, decltype(hw)::element_type::type::type {},  Type != int );\n    assert(42 == hw- number);\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bind_templates.cpp", 
            "title": "Binding Templates"
        }, 
        {
            "location": "/examples/index.html#binding-to-constructor", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nstruct example {\n  example(float, short) {}                  // ambiguous\n  example(int i, double d) : d{d}, i{i} {}  // constructors  - pick this one\n\n  double d{};\n  int i{};\n};\n\nstruct app {\n  example  ex;\n};\n\nint main() {\n  {\n    const auto injector = di::make_injector(\n      di::bind example ()(42, 87.0) // or di::bind example ().to example (42, 87.0)\n    );\n\n    auto object = di::create app (injector);\n\n    assert(42 == object.ex.i);\n    assert(87.0 == object.ex.d);\n  }\n\n#if defined(__cpp_variable_templates)\n  {\n    const auto injector = di::make_injector(\n      di::bind example (42, 87.0)\n    );\n\n    auto object = di::create app (injector);\n\n    assert(42 == object.ex.i);\n    assert(87.0 == object.ex.d);\n  }\n#endif\n\n  {\n    const auto injector = di::make_injector(\n      di::bind example ()(42, di::placeholders::_), // inject second argument\n      di::bind ().to(87.0)\n    );\n\n    auto object = di::create app (injector);\n\n    assert(42 == object.ex.i);\n    assert(87.0 == object.ex.d);\n  }\n\n  {\n    const auto injector = di::make_injector(\n      di::bind example ()(di::placeholders::_, 87.0), // inject first argument\n      di::bind ().to(42)\n    );\n\n    auto object = di::create app (injector);\n\n    assert(42 == object.ex.i);\n    assert(87.0 == object.ex.d);\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bind_to_constructor.cpp", 
            "title": "Binding To Constructor"
        }, 
        {
            "location": "/examples/index.html#automatic-injection", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n/* ambiguous constructor with 2 parameters */\nstruct example1 {\n  /* ambiguous `example1` constructor taking 2 parameters */\n  example1(double, int) { assert(false); }\n\n  /* ambiguous `example1` constructor taking 2 parameters - marked to be injected by `...` */\n  example1(int i, double d, ...) {\n    assert(i == 42);\n    assert(d == 87.0);\n  }\n};\n\nstruct example2 {\n  /* constructor with 1 parameter marked to be injected by `...` */\n  explicit example2(int i, ...) { assert(i == 42); }\n\n  /* constructor with 3 parameters, but still constructor with 1 and `...` will be chosen */\n  example2(int, double, float) { assert(false); }\n};\n\nint main() {\n  /* make injector and bind named parameters */\n  auto injector = di::make_injector(\n    di::bind int ().to(42)\n  , di::bind double ().to(87.0)\n  );\n\n  /* create `example1` */\n  injector.create example1 ();\n\n  /* create `example2` */\n  injector.create example2 ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/automatic_injection.cpp", 
            "title": "Automatic Injection"
        }, 
        {
            "location": "/examples/index.html#constructor-signature", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* define `example` class as usual */\nclass example {\n public:\n  example(std::unique_ptr interface1  up, std::shared_ptr interface2  sp, int i) {\n    assert(dynamic_cast implementation1* (up.get()));\n    assert(dynamic_cast implementation2* (sp.get()));\n    assert(42 == i);\n  }\n};\n\n/* define `example` class with different parameters order - won't require any changes in injector configuration */\nclass example_with_different_parameters_order {\n public:\n  example_with_different_parameters_order(std::shared_ptr interface2  sp, int i, std::unique_ptr interface1  up) {\n    assert(dynamic_cast implementation1* (up.get()));\n    assert(dynamic_cast implementation2* (sp.get()));\n    assert(42 == i);\n  }\n};\n\n/* define `example` class with different parameters order and different types - won't require any changes in injector\n * configuration */\nclass example_with_different_parameters_order_and_types {\n public:\n  example_with_different_parameters_order_and_types(std::unique_ptr interface2  sp, const int  i, interface1* up) : up_(up) {\n    assert(dynamic_cast implementation1* (up));\n    assert(dynamic_cast implementation2* (sp.get()));\n    assert(42 == i);\n  }\n\n  // in order to delete pointer - Boost.DI always transfer ownership to user in case of pointers\n  std::shared_ptr interface1  up_;\n};\n\nint main() {\n  /* make injector */\n  auto injector = di::make_injector(\n    di::bind interface1 ().to implementation1 ()\n  , di::bind interface2 ().to implementation2 ()\n  , di::bind int ().to(42)\n  );\n\n  /* create different examples using the same injector configuration */\n  injector.create example ();\n  injector.create example_with_different_parameters_order ();\n  injector.create example_with_different_parameters_order_and_types ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_signature.cpp", 
            "title": "Constructor Signature"
        }, 
        {
            "location": "/examples/index.html#constructor-injection", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto name = [] {};\n\nstruct ctor_inject {\n  /* constructor with intrusive named parameter explicitly selected */\n  BOOST_DI_INJECT(ctor_inject, int i1, (named = name) int i2) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nstruct ctor_inject_traits {\n  /* constructor with less intrusive named parameter using traits */\n  BOOST_DI_INJECT_TRAITS(int, (named = name) int);\n  explicit ctor_inject_traits(int i1, int i2 = 0) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nstruct ctor_di_traits {\n  /* class without any changes */\n  explicit ctor_di_traits(int i1, int i2 = 0) {\n    assert(i1 == 0);\n    assert(i2 == 42);\n  }\n};\n\nnamespace boost {\nnamespace di {\n\ntemplate  \nstruct ctor_traits ctor_di_traits  {\n  /* no intrusive way of defining named parameters */\n  BOOST_DI_INJECT_TRAITS(int, (named = name) int);\n};\n\n}  // namespace di\n}  // namespace boost\n\nstruct ctor_inject_traits_no_limits {\n  /* constructor with 20 parameters */\n  using boost_di_inject__ =\n      di::inject int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int ;\n\n  ctor_inject_traits_no_limits(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int,\n                               int) {}\n};\n\nint main() {\n  /* make injector */\n  auto injector = di::make_injector(\n    di::bind int ().named(name).to(42)\n  );\n\n  /* create dependencies */\n  injector.create ctor_inject ();\n  injector.create ctor_inject_traits ();\n  injector.create ctor_di_traits ();\n\n  injector.create ctor_inject_traits_no_limits ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp", 
            "title": "Constructor Injection"
        }, 
        {
            "location": "/examples/index.html#multiple-interface", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nclass multiple_interfaces {\n public:\n  multiple_interfaces(const std::shared_ptr interface1  interface1_, const std::shared_ptr interface2  interface2_) {\n    assert(dynamic_cast implementation* (interface1_.get()));\n    assert(dynamic_cast implementation* (interface2_.get()));\n    assert(static_cast implementation* (interface1_.get()) == static_cast implementation* (interface2_.get()));\n  }\n};\n\nint main() {\n  /* create injector with binding `implementation` to `interface1` and `interface2` using `di::any_of` */\n  auto injector = di::make_injector(\n    di::bind interface1, interface2 ().to implementation ()\n  );\n\n  injector.create multiple_interfaces ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_interfaces.cpp", 
            "title": "Multiple Interface"
        }, 
        {
            "location": "/examples/index.html#annotations", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nauto int_1 = [] {};\nstruct int_2_t {\n} int_2;\n\nclass annotations1 {\n public:\n  /* Constructor with named parameters of the same `int` type */\n  BOOST_DI_INJECT(annotations1, (named = int_1) int i1, (named = int_2) int i2, int i3) : i1(i1), i2(i2), i3(i3) {\n    assert(i1 == 42);\n    assert(i2 == 87);\n    assert(i3 == 123);\n  }\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nclass annotations2 {\n public:\n  /* Constructor with named parameters of the same `int` type */\n  BOOST_DI_INJECT(annotations2, (named = int_1) int i1, (named = int_2) int i2, int i3);\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nannotations2::annotations2(int i1, int i2, int i3) {\n  assert(i1 == 42);\n  assert(i2 == 87);\n  assert(i3 == 123);\n}\n\n\nclass annotations3 {\n public:\n  /* Constructor with named parameters of the same `int` type */\n  BOOST_DI_INJECT(annotations3, (named =  int1 _s) int i1, (named =  int2 _s) int i2, int i3) : i1(i1), i2(i2), i3(i3) {\n    assert(i1 == 42);\n    assert(i2 == 87);\n    assert(i3 == 123);\n  }\n\n private:\n  int i1 = 0;\n  int i2 = 0;\n  int i3 = 0;\n};\n\nint main() {\n  {\n    /* make injector and bind named parameters */\n    auto injector = di::make_injector(\n      di::bind int ().named(int_1).to(42)\n    , di::bind int ().named(int_2).to(87)\n    , di::bind int ().to(123)\n    );\n\n    /* create `annotations` */\n    injector.create annotations1 ();\n    injector.create annotations2 ();\n  }   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/annotations.cpp", 
            "title": "Annotations"
        }, 
        {
            "location": "/examples/index.html#deduce-scope", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct dependency1 {\n  dependency1(std::shared_ptr interface  spi /*shared*/\n              ,\n              const std::shared_ptr interface  spi_ /*shared*/)\n      : spi_(spi), spi__(spi_) {\n    assert(spi.get() == spi_.get());\n  }\n\n  std::shared_ptr interface  spi_;\n  std::shared_ptr interface  spi__;\n};\n\nstruct dependency2 {\n  dependency2(std::shared_ptr interface  spi /*shared*/, int i /*unique*/) : spi_(spi) { assert(i == 0); }\n\n  std::shared_ptr interface  spi_;\n};\n\nstruct example {\n  example(std::unique_ptr dependency1  dependency1_ /*unique*/\n          ,\n          const dependency2  dependency2_ /*unique temporary*/) {\n    assert(dependency2_.spi_.get() == dependency1_- spi_.get());\n    assert(dependency2_.spi_.get() == dependency1_- spi__.get());\n  }\n};\n\nint main() {\n  /* create injector with deduced `interface` */\n  auto injector = di::make_injector(\n    di::bind interface ().to implementation ()  // =  di::bind interface ().to implementation ().in(di::deduce)\n  );\n\n  /* create `example` */\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/deduce_scope.cpp", 
            "title": "Deduce Scope"
        }, 
        {
            "location": "/examples/index.html#custom-scope", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n/* define scope class */\nclass custom_scope {\n public:\n  /* define `entry`, `exit` actions */\n  class entry {};\n  class exit {};\n\n  template  class T, class \n  class scope {\n    /* define wrapper for shared_ptr conversion */\n    class custom_wrapper {\n     public:\n      custom_wrapper(const std::shared_ptr T  object)  // non explicit\n          : object_(object) {}\n\n      /* conversion operator to shared_ptr */\n      inline operator std::shared_ptr T () const noexcept { return object_; }\n\n      std::shared_ptr T  object_;\n    };\n\n   public:\n    template  class... \n    using is_referable = std::false_type;\n\n    template  class, class, class TProvider \n    static custom_wrapper try_create(const TProvider );\n\n    /* create shared_ptr when in scope out of provider pointer */\n    template  class, class, class TProvider \n    custom_wrapper create(const TProvider  provider) const noexcept {\n      return std::shared_ptr T {provider.get()};\n    }\n  };\n};\n\nstruct example {\n  explicit example(const std::shared_ptr int  sp) : sp_(sp) {}\n  std::shared_ptr int  sp_;\n};\n\nint main() {\n  /* create injector with `int` in `custom scope` */\n  auto injector = di::make_injector(\n    di::bind int ().in(custom_scope{})\n  );\n\n  assert(injector.create example ().sp_);\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_scope.cpp", 
            "title": "Custom Scope"
        }, 
        {
            "location": "/examples/index.html#eager-singletons", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nauto configuration = [] {\n  return di::make_injector(\n    di::bind interface ().to implementation ().in(di::singleton)\n  , di::bind int ().to(42)\n  );\n};\n\nstruct example {\n  example(int i, std::shared_ptr interface  object) {\n    assert(42 == i);\n    assert(dynamic_cast implementation* (object.get()));\n  }\n};\n\nint main() {\n  /* make injector configuration */\n  auto injector = di::make_injector(configuration());\n  assert(0 == implementation::ctor_calls());\n\n  /* eagerly initialize singletons */\n  eager_singletons(injector);\n  assert(1 == implementation::ctor_calls());\n\n  /* create `example` with already initialized singletons */\n  injector.create example ();\n  assert(1 == implementation::ctor_calls());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/eager_singletons.cpp", 
            "title": "Eager Singletons"
        }, 
        {
            "location": "/examples/index.html#modules", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\nstruct data {\n  std::shared_ptr interface  sp;\n};\n\nstruct app {\n  app(std::unique_ptr interface  up, int i, double d, const data  data) {\n    assert(dynamic_cast implementation1* (up.get()));\n    assert(i == 42);\n    assert(d == 87.0);\n    assert(dynamic_cast implementation2* (data.sp.get()));\n  }\n};\n\n/* `module1` configuration */\nauto module1 = [] {\n  return di::make_injector(\n    di::bind interface ().to implementation1 ()\n  );\n};\n\n/* `module2` configuration */\nauto module2(const int  i) {\n  return di::make_injector(\n    di::bind int ().to(i)\n  );\n}\n\n/* module configuration with exposed `data` */\nauto exposed_module = []() -  di::injector const data  {\n  return di::make_injector(\n    di::bind interface ().to implementation2 ()\n  );\n};\n\nint main() {\n  constexpr auto i = 42;\n  constexpr auto d = 87.0;\n\n  /* module configuration with movable injector */\n  auto movable_injector = di::make_injector(\n    di::bind double ().to(d)\n  );\n\n  /* create injector and pass `module1`, `module2` and `exposed_module` */\n  auto injector = di::make_injector(\n    module1()\n  , module2(i)\n  , exposed_module()\n  , std::move(movable_injector)\n  );\n\n  /* create `app` */\n  injector.create app ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/modules.cpp", 
            "title": "Modules"
        }, 
        {
            "location": "/examples/index.html#modules-hppcpp", 
            "text": "See  https://github.com/boost-experimental/di/tree/cpp14/example/modules", 
            "title": "Modules (hpp/cpp)"
        }, 
        {
            "location": "/examples/index.html#custom-policy", 
            "text": "class custom_policy;\n#define BOOST_DI_CFG custom_policy\n#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nclass custom_policy : public di::config {\n public:\n  static auto policies(...) noexcept {\n    using namespace di::policies;\n    using namespace di::policies::operators;\n    return di::make_policies(constructible(is_bound di::_ {}));\n  }\n};\n\nstruct example {\n  example(int, double) {}\n};\n\nint main() {\n  /* create shared_ptr `example` with per injector policy setting */\n  {\n    auto injector = di::make_injector custom_policy (\n      di::bind int ().to(42)\n    , di::bind double ().to(87.0)\n    );\n\n    injector.create example ();\n  }\n\n  /* create shared_ptr `example` with global policy setting */\n  {\n    auto injector = di::make_injector(\n      di::bind int ().to(42)\n    , di::bind double ().to(87.0)\n    );\n\n    injector.create example ();\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp", 
            "title": "Custom Policy"
        }, 
        {
            "location": "/examples/index.html#custom-provider", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* define `example` class as usual */\nstruct example {\n  explicit example(int i, std::unique_ptr interface  up) {\n    assert(i == 42);\n    assert(dynamic_cast implementation* (up.get()));\n  }\n};\n\n/* define `custom provider` */\nstruct custom_provider {\n  template  class... \n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template  class T, class TMemory, class... TArgs \n  auto get(const di::type_traits::direct , const TMemory   // stack/heap\n           ,\n           TArgs ... args) const {\n    return new T(std::forward TArgs (args)...);\n  }\n\n  template  class T, class TMemory, class... TArgs \n  auto get(const di::type_traits::uniform , const TMemory   // stack/heap\n           ,\n           TArgs ... args) const {\n    return new T{std::forward TArgs (args)...};\n  }\n};\n\n/* override `di` provider configuration */\nclass config : public di::config {\n public:\n  static auto provider(...) noexcept { return custom_provider{}; }\n};\n\nint main() {\n  /* make injector with simple configuration */\n  auto injector = di::make_injector config (\n    di::bind int ().to(42)\n  , di::bind interface ().to implementation ()\n  );\n\n  /* create `example` using `custom_provider` */\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp", 
            "title": "Custom Provider"
        }, 
        {
            "location": "/examples/index.html#pool-provider", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\n\n/* define `pool provider` */\nstruct pool_provider {\n  template  class... \n  struct is_creatable {\n    static constexpr auto value = true;\n  };\n\n  template  class T, class TInitialization, class TMemory, class... TArgs \n  auto get(const TInitialization   // direct/uniform\n           ,\n           const TMemory   // stack/heap\n           ,\n           TArgs ... args) const {\n    auto memory = pool_allocator::allocate T ();\n    return std::unique_ptr T, pool_deleter {new (memory) T(std::forward TArgs (args)...)};\n  }\n};\n\n/* override `di` provider configuration */\nclass config : public di::config {\n public:\n  static auto provider(...) noexcept { return pool_provider{}; }\n};\n\n/* define `example` class as usual */\nstruct example {\n  explicit example(int i, std::unique_ptr interface, pool_deleter  up, std::shared_ptr interface  sp) {\n    assert(i == 42);\n    assert(dynamic_cast implementation* (up.get()));\n    assert(dynamic_cast implementation* (sp.get()));\n  }\n};\n\nint main() {\n  /* make injector with simple configuration */\n  auto injector = di::make_injector config (\n    di::bind int ().to(42)\n  , di::bind interface ().to implementation ()\n  );\n\n  /* create `example` using configuration with `pool_provider` */\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp", 
            "title": "Pool Provider"
        }, 
        {
            "location": "/examples/index.html#configuration", 
            "text": "#include  boost/di.hpp \n\nnamespace di = boost::di;\n\nint main() {\n#if (BOOST_DI_VERSION  = 1'0'0)\n  std::cout    stable ;\n#else\n  std::cout    unstable ;\n#endif\n  std::cout     version of boost.di [    BOOST_DI_VERSION    ]    std::endl;\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/configuration.cpp", 
            "title": "Configuration"
        }, 
        {
            "location": "/examples/index.html#polymorphism", 
            "text": "See  https://github.com/boost-experimental/di/tree/cpp14/example/polymorphism", 
            "title": "Polymorphism"
        }, 
        {
            "location": "/examples/index.html#inheritance", 
            "text": "#include  cassert \n#include  memory \n#include  sstream \n\n#include  example/polymorphism/common/config.hpp \n\n/* Dynamic polymorphism - inheritance */\nclass Drawable {\n public:\n  virtual ~Drawable() noexcept = default;\n  virtual void draw(std::ostream ) const = 0;\n};\n\nclass App {\n public:\n  explicit App(std::unique_ptr const Drawable  drawable) : drawable{std::move(drawable)} {}\n  void draw(std::ostream  out) const { drawable- draw(out); }\n\n private:\n  std::unique_ptr const Drawable  drawable;\n};\n\nstruct Square : Drawable {\n  void draw(std::ostream  out) const override { out    Square ; }\n};\n\nstruct Circle : Drawable {\n  void draw(std::ostream  out) const override { out    Circle ; }\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create App ();\n  example.draw(str);\n  assert( Square  == str.str());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/inheritance.cpp", 
            "title": "Inheritance"
        }, 
        {
            "location": "/examples/index.html#type-erasure", 
            "text": "#include  cassert \n#include  functional \n#include  memory \n#include  sstream \n#include  type_traits \n\n#include  example/polymorphism/common/config.hpp \n\n/* Type erasure */\nclass Drawable {\n  std::shared_ptr void  ptr{};\n\n public:\n  template  class T, class = std::enable_if_t !std::is_convertible T, Drawable ::value \n  Drawable(T t) : ptr{std::make_shared T (t)}, draw{[this](auto ... args) { static_cast T* (ptr.get())- draw(args...); }} {}\n\n  std::function void(std::ostream )  draw;\n};\n\nclass App {\n public:\n  explicit App(const Drawable drawable) : drawable{drawable} {}\n  void draw(std::ostream  out) const { drawable.draw(out); }\n\n private:\n  const Drawable drawable;\n};\n\nstruct Square {\n  void draw(std::ostream  out) const { out    Square ; }\n};\n\nstruct Circle {\n  void draw(std::ostream  out) const { out    Circle ; }\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create App ();\n  example.draw(str);\n  assert( Square  == str.str());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/type_erasure.cpp", 
            "title": "Type Erasure"
        }, 
        {
            "location": "/examples/index.html#function", 
            "text": "#include  cassert \n#include  functional \n#include  memory \n#include  sstream \n#include  type_traits \n\n#include  example/polymorphism/common/config.hpp \n\n/* function */\nclass Drawable : public std::function void(std::ostream )  {\n public:\n  using std::function void(std::ostream ) ::function;\n};\n\nclass App {\n public:\n  explicit App(const Drawable drawable) : drawable{drawable} {}\n  void draw(std::ostream  out) const { drawable(out); }\n\n private:\n  const Drawable drawable;\n};\n\nstruct Square {\n  void operator()(std::ostream  out) const { out    Square ; }\n};\n\nstruct Circle {\n  void operator()(std::ostream  out) const { out    Circle ; }\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create App ();\n  example.draw(str);\n  assert( Square  == str.str());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/function.cpp", 
            "title": "Function"
        }, 
        {
            "location": "/examples/index.html#variant", 
            "text": "#if defined(__cpp_lib_variant)\n#include  cassert \n#include  sstream \n#include  variant \n\n#include  example/polymorphism/common/config.hpp \n\nstruct Square {\n  void draw(std::ostream  out) const { out    Square ; }\n};\n\nstruct Circle {\n  void draw(std::ostream  out) const { out    Circle ; }\n};\n\nclass Drawable : public std::variant Square, Circle  {\n public:\n  using std::variant Square, Circle ::variant;\n};\n\n/* Variant */\nclass App {\n public:\n  explicit App(const Drawable drawable) : drawable{drawable} {}\n\n  void draw(std::ostream  out) const {\n    std::visit([ out](const auto  drawable) { drawable.draw(out); }, drawable);\n  }\n\n private:\n  const Drawable drawable;\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create App ();\n  example.draw(str);\n  assert( Square  == str.str());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/variant.cpp", 
            "title": "Variant"
        }, 
        {
            "location": "/examples/index.html#templates", 
            "text": "#include  cassert \n#include  sstream \n\n#include  example/polymorphism/common/config.hpp \n\n/* Static polymorphism - templates */\ntemplate  typename TDrawable = class Drawable \nclass App {\n public:\n  explicit App(const TDrawable drawable) : drawable(drawable) {}\n  void draw(std::ostream  out) const { drawable.draw(out); }\n\n private:\n  const TDrawable drawable;\n};\n\nstruct Square {\n  void draw(std::ostream  out) const { out    Square ; }\n};\n\nstruct Circle {\n  void draw(std::ostream  out) const { out    Circle ; }\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create App ();\n  example.draw(str);\n  assert( Square  == str.str());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/templates.cpp", 
            "title": "Templates"
        }, 
        {
            "location": "/examples/index.html#concepts", 
            "text": "#include  cassert \n#include  sstream \n\n#include  example/polymorphism/common/config.hpp \n\n\ntemplate  class T \nconcept bool Drawable = not boost::di::aux::is_complete T ::value or requires(T t, std::ostream  out) {\n  t.draw(out);\n};\n\n/* Static polymorphism - concepts */\ntemplate  Drawable TDrawable = class Drawable   // requires Drawable TDrawable \nclass App {\n public:\n  explicit App(const TDrawable drawable) : drawable{drawable} {}\n  void draw(std::ostream  out) const { drawable.draw(out); }\n\n private:\n  const TDrawable drawable;\n};\n\nstruct Square {\n  void draw(std::ostream  out) const { out    Square ; }\n};\n\nstruct Circle {\n  void draw(std::ostream  out) const { out    Circle ; }\n};\n\nint main() {\n  std::stringstream str{};\n  auto example = config().create App ();\n  example.draw(str);\n  assert( Square  == str.str());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/polymorphism/concepts.cpp", 
            "title": "Concepts"
        }, 
        {
            "location": "/extensions/index.html", 
            "text": "Injector\n\n\nConstructor Bindings\n\n\nContextual Bindings\n\n\nAssisted Injection\n\n\nExtensible Injector\n\n\nConcepts\n\n\nFactory\n\n\nShared Factory\n\n\nLazy\n\n\nNamed Parameters\n\n\nXML Injection\n\n\nSerialize\n\n\nTypes Dumper\n\n\nUML Dumper\n\n\nHeap Provider\n\n\nMocks Provider\n\n\nRuntime Provider\n\n\nScoped Scope\n\n\nSession Scope\n\n\nShared Scope\n\n\n\n\n\n\nInjector\n\n\n#include \nboost/di/extension/injector.hpp\n\n\n#include \ncassert\n\n#include \nmemory\n\n\nnamespace di = boost::di;\n\nstruct i1 {\n  virtual ~i1() noexcept = default;\n  virtual int foo() const = 0;\n};\n\nstruct i2 {\n  virtual ~i2() noexcept = default;\n  virtual int bar() const = 0;\n};\n\nstruct impl2 : i2 {\n  int bar() const override { return 99; }\n};\n\nstruct impl1 : i1 {\n  explicit impl1(std::unique_ptr\ni2\n sp2) { assert(sp2-\nbar() == 99); }\n  int foo() const override { return 42; }\n};\n\nstruct app {\n  explicit app(std::shared_ptr\ni1\n sp1) { assert(sp1-\nfoo() == 42); }\n};\n\nint main() {\n  namespace di = boost::di;\n\n  /*\ncreates generic injector\n*/\n  {\n    auto injector = di::make_injector(\n      di::bind\ni1\n().to\nimpl1\n(), /// missing binding -\n compile error\n      di::bind\ni2\n().to\nimpl2\n()\n    );\n    di::create\napp\n(injector);\n    di::create\nstd::shared_ptr\ni1\n(injector); /// okay\n  }\n\n  /*\ncreates exposed injector\n*/\n  {\n    di::extension::injector\napp\n injector = di::make_injector(\n      di::bind\ni1\n().to\nimpl1\n(), /// missing binding -\n compile error\n      di::bind\ni2\n().to\nimpl2\n()\n    );\n    di::create\napp\n(injector);\n    //di::create\nstd::shared_ptr\ni1\n(injector); /// compile error, i1 is not exposed\n  }\n\n  /*\ncreates runtime injector\n*/\n  {\n    di::extension::injector\n injector{};\n    injector.install(di::bind\ni1\n().to\nimpl1\n()); /// missing binding -\n runtime error (Error policy)\n    injector.install(di::bind\ni2\n().to\nimpl2\n());\n\n    di::create\napp\n(injector);\n    di::create\nstd::shared_ptr\ni1\n(injector); /// okay\n  }\n\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injector.cpp\n\n\n\n\nConstructor Bindings\n\n\n#include \nboost/di/extension/bindings/constructor_bindings.hpp\n\n\n#include \ncassert\n\n#include \nmemory\n\n#include \nstring\n\n#include \ntuple\n\n\nnamespace di = boost::di;\n\n\n/*\nnormal constructor - to_constructor binding is not needed for it\n*/\nstruct ctor {\n  ctor(int i, std::string s, std::unique_ptr\ninterface\n impl) {\n    assert(i == 2);\n    assert(s == \nhello\n);\n    assert(dynamic_cast\nimplementation*\n(impl.get()));\n  }\n};\n\n/*\nambiguous constructor\n*/\nstruct ambiguous_ctor {\n  ambiguous_ctor(int i, std::string s) {\n    assert(i == 2);\n    assert(s == \nhello\n);\n  }\n\n  ambiguous_ctor(std::string s, int i) {\n    assert(s == \nhello\n);\n    assert(i == 2);\n  }\n};\n\n/*\nvariadic constructor - has to be `explicit`\n*/\nstruct variadic {\n  template \nclass... Ts\n\n  explicit variadic(Ts\n... args) {  // has to be explicit\n    assert(sizeof...(Ts) == 3);\n    std::tuple\nTs...\n ts{std::forward\nTs\n(args)...};\n    assert(std::get\n0\n(ts) == 2);\n    assert(std::get\n1\n(ts) == \nhello\n);\n    assert(dynamic_cast\nimplementation*\n(std::get\n2\n(ts).get()));\n  }\n};\n\nint main() {\n  /*\ndefine constructor types\n*/\n  auto injector = di::make_injector(\n      di::bind\nctor\n().to(di::extension::constructor\nint, std::string, std::unique_ptr\ninterface\n())\n    , di::bind\nambiguous_ctor\n().to(di::extension::constructor\nint, std::string\n())\n    , di::bind\nvariadic\n().to(di::extension::constructor\nint, std::string, std::unique_ptr\ninterface\n())\n\n    /*\nadditional bindings\n*/\n    , di::bind\ninterface\n().to\nimplementation\n()\n    , di::bind\nint\n().to(2), di::bind\nstd::string\n().to(\nhello\n)\n  );\n\n  /*\ncreate types using defined constructors\n*/\n  injector.create\nctor\n();\n  injector.create\nambiguous_ctor\n();\n  injector.create\nvariadic\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/bindings/constructor_bindings.cpp\n\n\n\n\nContextual Bindings\n\n\n#include \nboost/di/extension/bindings/contextual_bindings.hpp\n\n\n#include \ncassert\n\n\nnamespace di = boost::di;\n\nstruct more_data {\n  int i;\n};\n\nstruct data {\n  int i;\n  more_data md;\n};\n\nclass example {\n public:\n  example(data\n d, int i, float f) {\n    assert(87 == d.i);\n    assert(99 == d.md.i);\n    assert(42 == i);\n    assert(123.f == f);\n  }\n};\n\nint main() {\n  auto injector = di::make_injector\ndi::extension::contextual_bindings\n(\n      di::bind\n().to(123.f)\n    , di::bind\nint\n().to([](const auto\n injector) {\n        if (di::extension::context(injector) == \nexample-\ndata\n) return 87;\n        if (di::extension::context(injector) == \nexample-\ndata-\nmore_data\n) return 99;\n        return 42;\n      })\n  );\n\n  /*\ncreate `example`\n*/\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/bindings/contextual_bindings.cpp\n\n\n\n\nAssisted Injection\n\n\n#include \nboost/di/extension/injections/assisted_injection.hpp\n\n\n#include \ncassert\n\n#include \nfunctional\n\n#include \nmemory\n\n#include \nstring\n\n\nnamespace di = boost::di;\n\n\nint main() {\n  /*\nassisted_injection declaration using std function\n*/\n  using example_assisted_injection = std::function\nstd::unique_ptr\nexample\n(int, double, std::string)\n;\n\n  auto injector = di::make_injector(\n      di::bind\nint\n().to(87)\n    , di::bind\ninterface\n().to\nimplementation\n()\n      /*\nbind `example_assisted_injection` to assisted_injection creating `example`\n*/\n    , di::bind\nexample_assisted_injection\n().to(di::extension::assisted_injection\nexample\n())\n  );\n\n  auto f = injector.create\nexample_assisted_injection\n();\n  f(42, 123.0, \nstr\n);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/assisted_injection.cpp\n\n\n\n\nExtensible Injector\n\n\n#include \nboost/di/extension/injections/extensible_injector.hpp\n\n\n#include \ncassert\n\n#include \nmemory\n\n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual int num() = 0;\n};\n\nstruct any {\n  virtual ~any() noexcept = default;\n};\n\nstruct object : any {};\n\nstruct implementation1 : interface {\n  int num() override { return 1; }\n};\n\nstruct implementation2 : interface {\n  int num() override { return 2; }\n};\n\nstruct implementation3 : interface {\n  int num() override { return 3; }\n};\n\nstruct example {\n  example(std::unique_ptr\ninterface\n i, std::shared_ptr\nimplementation3\n im3) : i_(std::move(i)), im3_(im3) {}\n\n  std::shared_ptr\ninterface\n i_;\n  std::shared_ptr\ninterface\n im3_;\n};\n\nint main() {\n  //\ncreate instance object\n\n  auto im3_orig = std::make_shared\nimplementation3\n();\n\n  //\ndefine injector\n\n  auto orig_injector = di::make_injector(\n      //\nbind interface to implementation1\n\n      di::bind\ninterface\n().to\nimplementation1\n().in(di::unique)\n\n      //\nbind any to object\n\n    , di::bind\nany\n().to\nobject\n()\n\n      //\noverridden binding for any, object to object\n\n    , di::bind\nany, object\n().to\nobject\n()[di::override]\n\n      //\nbind implementation3 to shared instance\n\n    , di::bind\nimplementation3\n().to(im3_orig)\n  );\n\n  {\n    //\ndefine extended injector\n\n    auto extended_injector = di::make_injector(\n        //\nmake extensible injector from original injector\n\n        di::extension::make_extensible(orig_injector)\n\n        //\noverride bound interface to implementation2\n\n      , di::bind\ninterface\n().to\nimplementation2\n().in(di::unique)[di::override]\n    );\n\n    //\nboth injectors live together\n\n    auto orig_example = orig_injector.create\nexample\n();\n    assert(1 == orig_example.i_-\nnum());\n    assert(3 == orig_example.im3_-\nnum());\n\n    auto extended_example = extended_injector.create\nexample\n();\n    assert(2 == extended_example.i_-\nnum());\n    assert(3 == extended_example.im3_-\nnum());\n\n    //\nboth injectors share the same dependency\n\n    assert(extended_example.im3_ == orig_example.im3_);\n    assert(im3_orig == orig_example.im3_);\n\n    //\ninjector supports multiple bindings\n\n    assert(orig_injector.create\nstd::shared_ptr\nany\n() == orig_injector.create\nstd::shared_ptr\nobject\n());\n  }\n  //\nafter death of extended dependency original dependency is still alive\n\n  assert(im3_orig == orig_injector.create\nstd::shared_ptr\nimplementation3\n());\n\n  {\n    //\nmake_extensible can be called with empty injector\n\n    auto empty_injector = di::make_injector();\n    auto empty_extended_injector = di::make_injector(di::extension::make_extensible(empty_injector));\n    auto instance = empty_extended_injector.create\nimplementation1\n();\n    assert(1 == instance.num());\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/extensible_injector.cpp\n\n\n\n\nConcepts\n\n\n\n#include \nboost/di/extension/injections/concepts.hpp\n\n\n#include \ncassert\n\n\nnamespace di = boost::di;\n\ntemplate \ntypename T\n\nconcept bool Dummy() {\n  return requires(T a) { {a.dummy()}; };\n}\n\nstruct DummyImpl {\n  void dummy() {}\n};\n\nauto dummy_concept = [] {};\n\nstruct example {\n  BOOST_DI_INJECT(example, int i, auto t, (named = dummy_concept) Dummy d, (named = dummy_concept) std::unique_ptr\nDummy\n up) {\n    assert(42 == i);\n    static_assert(std::is_same\ndecltype(t), int\n::value, \n);\n    assert(87 == t);\n    static_assert(std::is_same\ndecltype(d), DummyImpl\n::value, \n);\n    static_assert(std::is_same\ndecltype(up), std::unique_ptr\nDummyImpl\n::value, \n);\n  }\n};\n\nint main() {\n  auto injector = di::make_injector\ndi::extension::concepts_provider_config\n(\n      di::bind\nint\n.to(42)\n    , di::bind\ndi::_\n.to(87)\n    , di::bind\ndi::_\n().named(dummy_concept).to\nDummyImpl\n()\n  );\n\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/concepts.cpp\n\n\n\n\nFactory\n\n\n#include \nboost/di/extension/injections/factory.hpp\n\n\n#include \ncassert\n\n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy1() = 0;\n};\n\nstruct implementation : interface {\n  void dummy1() override {}\n};\n\nstruct implementation_exception : interface {\n#if defined(__EXCEPTIONS)\n  implementation_exception() { throw 0; }\n#endif\n  void dummy1() override {}\n};\n\nstruct implementation_with_args : interface {\n  implementation_with_args(int i, double d) {\n    assert(42 == i);\n    assert(87.0 == d);\n  }\n  void dummy1() override {}\n};\n\nstruct implementation_with_injected_args : interface {\n  implementation_with_injected_args(int i, double d) {\n    assert(123 == i);\n    assert(87.0 == d);\n  }\n  void dummy1() override {}\n};\n\n/*\nexample `example` class\n*/\nclass example {\n public:\n  example(const di::extension::ifactory\ninterface\n f1, const di::extension::ifactory\ninterface, int, double\n f2,\n          const di::extension::ifactory\ninterface, double\n f3) {\n    assert(dynamic_cast\nimplementation*\n(f1.create().get()));\n    assert(dynamic_cast\nimplementation_with_args*\n(f2.create(42, 87.0).get()));\n    assert(dynamic_cast\nimplementation_with_injected_args*\n(f3.create(87.0).get()));\n  }\n};\n\nint main() {\n  //\ndefine injector\n\n  auto module = [] { return di::make_injector(di::bind\n().to(123)); };\n\n  auto injector = di::make_injector(module()\n  // \nbind instance just to make sure that factory doesn't affect injector\n\n  , di::bind\ninterface\n().to(std::make_shared\nimplementation\n())\n\n  // \nbind instance which throws exception to make sure that exception doesn't affect injector\n\n  , di::bind\ndi::extension::ifactory\nimplementation_exception\n().to(di::extension::factory\nimplementation_exception\n{})\n\n  //\nbind factory interface to implementation\n\n  , di::bind\ndi::extension::ifactory\ninterface\n().to(di::extension::factory\nimplementation\n{})\n\n  //\nbind factory interface with parameters to implementation_with_args\n\n  , di::bind\ndi::extension::ifactory\ninterface, int, double\n().to(di::extension::factory\nimplementation_with_args\n{})\n\n  //\nbind factory interface with some parameters injected to implementation_with_injected_args\n\n  , di::bind\ndi::extension::ifactory\ninterface, double\n().to(di::extension::factory\nimplementation_with_injected_args\n{})\n  );\n\n  /*\ncreate `example`\n*/\n  injector.create\nexample\n();\n\n/*\ncreate `implementation_exception`\n*/\n#if defined(__EXCEPTIONS)\n  auto exception_thrown = false;\n  try {\n    injector.create\nconst implementation_exception\n();\n  } catch (...) {\n    exception_thrown = true;\n  }\n  assert(exception_thrown);\n#endif\n\n  // Check whether injector is affected by factory\n  assert(injector.create\nstd::shared_ptr\ninterface\n());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/factory.cpp\n\n\n\n\nShared Factory\n\n\n#include \nboost/di/extension/injections/shared_factory.hpp\n\n\n#include \ncassert\n\n\nnamespace di = boost::di;\nnamespace ext = di::extension;\n\nstruct interface1 {\n  virtual ~interface1() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct interface2 {\n  virtual ~interface2() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct implementation : interface1, interface2 {\n  static auto\n ctor_calls() {\n    static auto calls = 0;\n    return calls;\n  }\n  static auto\n dtor_calls() {\n    static auto calls = 0;\n    return calls;\n  }\n  implementation() { ctor_calls()++; }\n  ~implementation() { dtor_calls()++; }\n  void dummy() override {}\n};\n\nstruct implementation_exception : interface1 {\n#if defined(__EXCEPTIONS)\n  implementation_exception() { throw 0; }\n#endif\n  void dummy() override {}\n};\n\nint main() {\n  assert(!implementation::ctor_calls());\n  assert(!implementation::dtor_calls());\n\n  {\n    //\ndefine injector\n\n    auto injector = di::make_injector(\n      di::bind\nimplementation_exception\n().to(ext::shared_factory\nimplementation_exception\n([\n](const auto\n inner_injector)\n      {\n        //\nthrows an exception here\n\n        return inner_injector.template create\nstd::shared_ptr\nimplementation_exception\n();\n      })),\n      //\nbind factory interface to implementation\n\n      di::bind\ninterface1, implementation\n().to(ext::shared_factory\nimplementation, ext::no_recursion\n([\n](const auto\n inner_injector)\n      {\n        static int calls = 0;\n        assert(1 == ++calls);\n        //\nshouldn't be recursive call here\n\n        return inner_injector.template create\nstd::shared_ptr\nimplementation\n();\n      })),\n      di::bind\ninterface2\n().to(ext::conditional_shared_factory\nimplementation\n([\n]()\n      {\n        static int calls = 0;\n        assert(1 == ++calls);\n        return true;\n      }))\n    );\n\n    //\ncreate `implementation` via `shared_factory`\n\n    auto i1 = injector.create\nstd::shared_ptr\ninterface1\n();\n    auto i2 = injector.create\nstd::shared_ptr\nimplementation\n();\n    assert(i1);\n    assert(i1 == i2);\n    assert(1 == implementation::ctor_calls());\n    assert(!implementation::dtor_calls());\n\n    //\ncreate `interface` via `conditional_shared_factory`\n\n    auto i3 = injector.create\nstd::shared_ptr\ninterface2\n();\n\n#if defined(__EXCEPTIONS)\n    auto exception_thrown = false;\n    try {\n      injector.create\nstd::shared_ptr\nimplementation_exception\n();\n    } catch (...) {\n      exception_thrown = true;\n    }\n    assert(exception_thrown);\n#endif\n\n    auto i4 = injector.create\nstd::shared_ptr\ninterface2\n();\n    assert(i3);\n    assert(i3 == i4);\n    assert(1 == implementation::ctor_calls());\n    assert(!implementation::dtor_calls());\n  }\n  //\nDestroyed with injector\n\n  assert(1 == implementation::dtor_calls());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/shared_factory.cpp\n\n\n\n\nLazy\n\n\n#include \nboost/di/extension/injections/lazy.hpp\n\n\n#include \ncassert\n\n#include \nmemory\n\n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy1() = 0;\n};\n\nstruct type_expensive_to_create : interface {\n  void dummy1() override {}\n};\n\n/*\nexample `example` class\n*/\nclass example {\n public:\n  explicit example(di::extension::lazy\nstd::unique_ptr\ninterface\n l) : l(l) {}\n\n  void initialize() {\n    auto object = l.get();\n    assert(dynamic_cast\ntype_expensive_to_create *\n(object.get()));\n  }\n\n private:\n  di::extension::lazy\nstd::unique_ptr\ninterface\n l;\n};\n\nint main() {\n  /*\ndefine injector\n*/\n  auto injector = di::make_injector(\n    di::bind\ninterface\n().to\ntype_expensive_to_create\n()\n  );\n\n  /*\ncreate `example`\n*/\n  auto object = injector.create\nexample\n();\n  object.initialize();\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/lazy.cpp\n\n\n\n\nNamed Parameters\n\n\n\n#include \nboost/di/extension/injections/named_parameters.hpp\n\n\n#include \ncassert\n\n#include \nmemory\n\n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() = default;\n  virtual void dummy() = 0;\n};\n\nstruct implementation : interface {\n  void dummy() override {}\n};\n\nstruct example {\n  /*\ninject constructor using automatic named parameters\n*/\n  $inject(example, int i, std::unique_ptr\ninterface\n up, [[named(\nmy_value\n)]] int value) {\n    assert(i == 42);\n    assert(dynamic_cast\nimplementation*\n(up.get()));\n    assert(value == 87);\n  }\n};\n\nint main() {\n  using namespace di::extension;\n\n  /*\nbind named parameters\n*/\n  auto injector = di::make_injector(\n      di::bind\nint\n.to(42)\n    , di::bind\ninterface\n.to\nimplementation\n()\n    , di::bind\nint\n.named(\nmy_value\n_s).to(87)\n  );\n\n  injector.create\nexample\n();\n}\n\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/named_parameters.cpp\n\n\n\n\nXML Injection\n\n\n#include \nboost/di/extension/injections/xml_injection.hpp\n\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace di = boost::di;\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind\ndi::extension::ixml_parser\n().to\nxml_parser_stub\n()\n  );\n};\n\nauto xml_module = [] {\n  return di::make_injector(\n    di::bind\ninterface\n().to(di::extension::xml\nimplementation1, implementation2\n())\n  );\n};\n\nint main() {\n  /*\nmake injector\n*/\n  auto injector = di::make_injector(module(), xml_module());\n\n  /*\ncreate `interface` from xml configuration\n*/\n  {\n    auto object = injector.create\nstd::shared_ptr\ninterface\n();\n    assert(object.get());\n    assert(dynamic_cast\nimplementation1*\n(object.get()));\n  }\n\n  /*\ncreate `interface` from different xml configuration\n*/\n  {\n    auto object = injector.create\nstd::shared_ptr\ninterface\n();\n    assert(object.get());\n    assert(dynamic_cast\nimplementation2*\n(object.get()));\n  }\n\n  /*\ncreate `interface` from different xml configuration\n*/\n  {\n    auto object = injector.create\nstd::shared_ptr\ninterface\n();\n    assert(!object.get());\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/xml_injection.cpp\n\n\n\n\nSerialize\n\n\n#define BOOST_DI_DISABLE_SHARED_PTR_DEDUCTION\n#include \nboost/di/extension/policies/serialize.hpp\n\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace di = boost::di;\n\nstruct data {\n  unsigned int ui;\n  long l;\n  float f;\n};\n\nstruct even_more_data {\n  double d;\n  bool b;\n  long long ll;\n};\n\nstruct more_data {\n  int i;\n  long double ld;\n  even_more_data d;\n  short s;\n};\n\nstruct example {\n  example(data\n d, more_data\n md) : d(d), md(md) {}\n\n  void update() {\n    d.ui = 13;\n    d.l = 23l;\n    d.f = .33f;\n    md.i = 44;\n    md.ld = 42.0;\n    md.d.d = 55.0;\n    md.d.b = true;\n    md.d.ll = 66ll;\n    md.s = 77;\n  }\n\n  void reset() {\n    d.ui = {};\n    d.l = {};\n    d.f = {};\n    md.i = {};\n    md.ld = {};\n    md.d.d = {};\n    md.d.b = {};\n    md.d.ll = {};\n    md.s = {};\n  }\n\n  data\n d;\n  more_data\n md;\n};\n\nint main() {\n  auto injector = di::make_injector\ndi::extension::serializable_policy\n(\n      di::bind\n().to(42)\n  );\n\n  /*\ncreate `example`\n*/\n  auto object = injector.create\nexample\n();\n  {\n    assert(0 == object.d.ui);\n    assert(0 == object.d.l);\n    assert(.0f == object.d.f);\n    assert(42 == object.md.i);  // bound\n    assert(0.0 == object.md.ld);\n    assert(0.0 == object.md.d.d);\n    assert(false == object.md.d.b);\n    assert(0 == object.md.d.ll);\n    assert(0 == object.md.s);\n  }\n\n  /*\nupdate internal data\n*/\n  object.update();\n  {\n    assert(13 == object.d.ui);\n    assert(23 == object.d.l);\n    assert(.33f == object.d.f);\n    assert(44 == object.md.i);\n    assert(42.0 == object.md.ld);\n    assert(55.0 == object.md.d.d);\n    assert(true == object.md.d.b);\n    assert(66 == object.md.d.ll);\n    assert(77 == object.md.s);\n  }\n\n  /*\nserialize internal data to the stream\n*/\n  std::stringstream str;\n  di::extension::serialize(injector, str);\n\n  /*\nreset internal data\n*/\n  object.reset();\n\n  /*\ndeserialize from the stream\n*/\n  di::extension::deserialize(injector, str);\n  {\n    assert(13 == object.d.ui);\n    assert(23 == object.d.l);\n    assert(.33f == object.d.f);\n    assert(44 == object.md.i);\n    assert(42.0 == object.md.ld);\n    assert(55.0 == object.md.d.d);\n    assert(true == object.md.d.b);\n    assert(66 == object.md.d.ll);\n    assert(77 == object.md.s);\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/serialize.cpp\n\n\n\n\nTypes Dumper\n\n\n#include \nboost/di/extension/policies/types_dumper.hpp\n\n\n#include \nmemory\n\n\nnamespace di = boost::di;\n\nauto int_1 = [] { return \nfirst int\n; };\nauto int_2 = [] { return \nsecond int\n; };\n\nstruct i0 {\n  virtual ~i0(){};\n};\nstruct c0 : i0 {};\nstruct c1 {\n  c1(std::shared_ptr\ni0\n, int) {}\n};\nstruct c2 {\n  BOOST_DI_INJECT(c2, (named = int_1) int, (named = int_2) int, char) {}\n};\nstruct c3 {\n  c3(std::shared_ptr\nc1\n, std::shared_ptr\nc2\n) {}\n};\n\nint main() {\n  /*\ndefine injector\n*/\n  auto injector = di::make_injector\ndi::extension::types_dumper\n(\n    di::bind\ni0\n().to\nc0\n()\n  , di::bind\nint\n().named(int_1).to(42)\n  , di::bind\nint\n().named(int_2).to(42)\n  );\n\n  /*\niterate through created objects with `types_dumper`\n*/\n  injector.create\nc3\n();\n\n  /*\n output [pre\n      (2c3 -\n 2c3)\n          (St10shared_ptrI2c1E -\n 2c1)\n              (St10shared_ptrI2i0E -\n 2c0)\n              (i -\n i)\n          (St10shared_ptrI2c2E -\n 2c2)\n              (i[first int] -\n i)\n              (i[second int] -\n i)\n              (c -\n c)\n  ]\n*/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/types_dumper.cpp\n\n\n\n\nUML Dumper\n\n\n#include \nboost/di/extension/policies/uml_dumper.hpp\n\n\n#include \nmemory\n\n\nnamespace di = boost::di;\n\n\nint main() {\n  /*\ndefine injector\n*/\n  auto injector = di::make_injector\ndi::extension::uml_dumper\n(\n    di::bind\ni0\n().to\nc0\n()\n  , di::bind\nint\n().named(int_1).to(42)\n  , di::bind\nint\n().named(int_2).to(42)\n  );\n\n  /*\niterate through created objects with `types_dumper`\n*/\n  injector.create\nc3\n();\n\n  /*\noutput [@images/uml_dumper.png [$images/uml_dumper.png [width 75%] [height 75%] ]]\n*/\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/uml_dumper.cpp\n\n\n\n\n\n\nHeap Provider\n\n\n#include \nboost/di/extension/providers/heap.hpp\n\n\n#include \ncassert\n\n#include \nmemory\n\n\nnamespace di = boost::di;\n\nclass new_call;\nclass del_call;\n\nstruct example {\n  template \nclass\n\n  static auto \ncalls() {\n    static auto i = 0;\n    return i;\n  }\n\n  void *operator new(size_t size) {\n    ++calls\nnew_call\n();\n    return ::operator new(size);\n  }\n\n  void operator delete(void *ptr) {\n    ++calls\ndel_call\n();\n    ::operator delete(ptr);\n  }\n};\n\nint main() {\n  struct heap_config : di::config {\n    auto provider(...) const noexcept { return di::extension::heap{}; }\n  };\n\n  auto injector = di::make_injector\nheap_config\n();\n\n  assert(0 == example::calls\nnew_call\n());\n  assert(0 == example::calls\ndel_call\n());\n  injector.create\nexample\n();\n  assert(1 == example::calls\nnew_call\n());\n  assert(1 == example::calls\ndel_call\n());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/heap.cpp\n\n\n\n\nMocks Provider\n\n\n#include \nboost/di/extension/providers/mocks_provider.hpp\n\n\n#include \ncassert\n\n\nnamespace di = boost::di;\n\nstruct i1 {\n  virtual ~i1() noexcept = default;\n  virtual int get() = 0;\n};\n\nstruct i2 {\n  virtual ~i2() noexcept = default;\n  virtual int get() = 0;\n};\n\nstruct c {\n  c(std::shared_ptr\ni1\n sp, std::unique_ptr\ni2\n up, int i) {\n    assert(sp-\nget() == 42);\n    assert(up-\nget() == 123);\n    assert(i == 87);\n  }\n};\n\nint main() {\n  /*\nunit test\n*/\n  {\n    /*\ncreate injector with `mocks_provider`\n*/\n    auto mi = di::extension::mocks_injector();\n\n    /*\nset expectations\n*/\n    expect(mi, \ni1::get).will_return(42);\n    expect(mi, \ni2::get).will_return(123);\n\n    /*\ncreate object to test with interfaces to be injected by di and int value passed directly to constructor\n*/\n    c object{mi, mi, 87};\n  }\n\n  /*\nintegration test\n*/\n  {\n    struct impl1 : i1 {\n      int get() override { return 42; }\n    };\n\n    /*\ncreate injector with `mocks_provider`\n*/\n      auto mi = di::extension::mocks_injector(\n        di::bind\nint\n().to(87) // custom value\n      , di::bind\ni1\n().to\nimpl1\n() // original implementation\n      );\n\n    /*\nset expectations\n*/\n    expect(mi, \ni2::get).will_return(123);  // fake\n\n    /*\ncreate object to test with mocked `i1` and original `i2` and injected int value\n*/\n    mi.create\nc\n();\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/mocks_provider.cpp\n\n\n\n\nRuntime Provider\n\n\n#include \nboost/di/extension/providers/runtime_provider.hpp\n\n\n#include \ncassert\n\n#include \nstring\n\n\nnamespace di = boost::di;\n\nstruct i1 {\n  virtual ~i1() noexcept = default;\n  virtual int foo() const = 0;\n};\n\nstruct i2 {\n  virtual ~i2() noexcept = default;\n  virtual int bar() const = 0;\n};\n\nstruct i3 {\n  virtual ~i3() noexcept = default;\n  virtual int f() const = 0;\n};\n\nstruct i4 {\n  virtual ~i4() noexcept = default;\n  virtual int foo() const = 0;\n};\n\nstruct impl3 : i3 {\n  explicit impl3(const int\n i) { assert(i == 87); }\n  int f() const override { return 1234; }\n};\n\nstruct impl2 : i2 {\n  explicit impl2(i3\n i, std::string str) {\n    assert(i.f() == 1234);\n    assert(str == \ntext\n);\n  }\n  int bar() const override { return 99; }\n};\n\nstruct impl1 : i1 {\n  explicit impl1(std::unique_ptr\ni2\n sp2) { assert(sp2-\nbar() == 99); }\n  int foo() const override { return 42; }\n};\n\nclass ctor;\nclass dtor;\n\nstruct impl4 : i4 {\n  template \nclass\n\n  static auto\n calls() {\n    static auto i = 0;\n    return i;\n  }\n\n  impl4() { ++calls\nctor\n(); }\n  ~impl4() { ++calls\ndtor\n(); }\n\n  int foo() const override { return 100; }\n};\n\nclass module_example {\n public:\n  explicit module_example(std::shared_ptr\ni4\n sp) : sp{sp} {}\n  auto get() const { return sp-\nfoo() * 2; }\n\n private:\n  std::shared_ptr\ni4\n sp{};\n};\n\nstruct example {\n  example(std::shared_ptr\ni1\n sp, int i, module_example\n me) {\n    assert(dynamic_cast\nimpl1*\n(sp.get()));\n    assert(sp-\nfoo() == 42);\n    assert(i == 87);\n    assert(me.get() == 2 * 100);\n  }\n};\n\nauto ct_module = [] { return di::make_injector(di::bind\ni4\n().to\nimpl4\n()); };\ndi::extension::runtime_injector rt_module() { return di::make_injector(di::bind\ni4\n().to\nimpl4\n()); }\n\nint main() {\n  namespace di = boost::di;\n\n  /*\ncreate runtime injector\n*/\n  di::extension::runtime_injector injector{};\n\n  /*\ninstall bindings\n*/\n  injector.install(\n    di::bind\ni1\n().to\nimpl1\n(),\n    di::bind\ni2\n().to\nimpl2\n()\n  );\n\n  /*\nmore bindings\n*/\n  injector.install(di::bind\nint\n().to(87));\n\n  /*\ninjector bindings\n*/\n  auto component = di::make_injector(\n    di::bind\ni3\n().to\nimpl3\n(),\n    di::bind\nstd::string\n().to(\ntext\n)\n  );\n  injector.install(component);\n\n  /*\nmodule bindings\n*/\n  injector.install(ct_module());\n\n  /*\ncreate example\n*/\n  injector.create\nexample\n();\n\n  // scoped injector\n  {\n    impl4::calls\nctor\n() = {};\n    impl4::calls\ndtor\n() = {};\n\n    di::extension::runtime_injector injector{};\n    injector.install(rt_module());\n    auto m = di::create\nmodule_example\n(injector);\n\n    assert(m.get() == 2 * 100);\n    assert(impl4::calls\nctor\n() == 1);\n    assert(impl4::calls\ndtor\n() == 0);\n  }\n  assert(impl4::calls\nctor\n() == 1);\n  assert(impl4::calls\ndtor\n() == 1);\n\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/runtime_provider.cpp\n\n\n\n\nScoped Scope\n\n\n#include \nboost/di/extension/scopes/scoped.hpp\n\n\n#include \ncassert\n\n\nnamespace di = boost::di;\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind\ninterface1\n().to\nimplementation1\n()\n  );\n};\n\nint main() {\n  assert(!implementation1::ctor_calls());\n  assert(!implementation1::dtor_calls());\n  assert(!implementation2::ctor_calls());\n  assert(!implementation2::dtor_calls());\n\n  auto parent_injector = module();\n  /*\ncreate `interface1` using deduced singleton scope\n*/\n  parent_injector.create\ninterface1 \n();\n  assert(1 == implementation1::ctor_calls());\n  {\n    /*\ncreate `child_injector` with `module` and binding using scoped singleton scope\n*/\n    auto child_injector = di::make_injector(\n        module()\n      , di::bind\ninterface2\n().to\nimplementation2\n().in(di::extension::scoped)\n    );\n    child_injector.create\ninterface2 \n();\n    assert(1 == implementation2::ctor_calls());\n  }  // end of scoped\n  assert(1 == implementation2::dtor_calls());\n\n  /*\ncreate `interface1` again in singleton scope\n*/\n  parent_injector.create\ninterface1 \n();\n  /*\nalready created\n*/\n  assert(1 == implementation1::ctor_calls());\n  /*\n`implementation1` will die with the app (static storage)\n*/\n  assert(0 == implementation1::dtor_calls());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/scoped.cpp\n\n\n\n\nSession Scope\n\n\n#include \nboost/di/extension/scopes/session.hpp\n\n\n#include \ncassert\n\n\nnamespace di = boost::di;\n\n\nauto my_session = [] {};\n\nint main() {\n  {\n    auto injector = di::make_injector(\n      di::bind\ninterface1\n().to\nimplementation1\n().in(di::extension::session(my_session))\n    );\n    assert(!injector.create\nstd::shared_ptr\ninterface1\n());\n\n    {\n      auto ms = di::extension::session(my_session)();\n      assert(injector.create\nstd::shared_ptr\ninterface1\n());\n    }  // end of my_session\n\n    assert(!injector.create\nstd::shared_ptr\ninterface1\n());\n  }\n\n  {\n    di::injector\nstd::shared_ptr\ninterface1\n injector =\n      di::make_injector(\n        di::bind\ninterface1\n().to\nimplementation1\n().in(di::extension::session(my_session))\n      );\n    assert(!injector.create\nstd::shared_ptr\ninterface1\n());\n\n    {\n      auto ms = di::extension::session(my_session)();\n      assert(injector.create\nstd::shared_ptr\ninterface1\n());\n    }  // end of my_session\n\n    assert(!injector.create\nstd::shared_ptr\ninterface1\n());\n  }\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/session.cpp\n\n\n\n\nShared Scope\n\n\n#include \nboost/di/extension/scopes/shared.hpp\n\n\n#include \ncassert\n\n\nnamespace di = boost::di;\n\n\nauto name = [] {};\n\nclass example {\n public:\n  BOOST_DI_INJECT(example, (named = name) std::shared_ptr\ninterface1\n sp1, (named = name) std::shared_ptr\ninterface1\n sp2,\n                  std::shared_ptr\ninterface1\n sp3) {\n    assert(sp1 == sp2);\n    assert(dynamic_cast\nimplementation2*\n(sp1.get()));\n    assert(dynamic_cast\nimplementation2*\n(sp2.get()));\n    assert(dynamic_cast\nimplementation1*\n(sp3.get()));\n  }\n};\n\nint main() {\n  {\n    auto injector = di::make_injector\ndi::extension::shared_config\n(\n      di::bind\ninterface1\n().to\nimplementation1\n().in(di::extension::shared)  // di::unique will fail (sp1 == sp2)\n    , di::bind\ninterface1\n().to\nimplementation2\n().named(name).in(di::extension::shared)\n    );\n    injector.create\nexample\n();\n  }\n\n  {\n    di::injector\nstd::shared_ptr\ninterface1\n injector =\n      di::make_injector\ndi::extension::shared_config\n(\n        di::bind\ninterface1\n().to\nimplementation1\n().in(di::extension::shared)\n    );\n\n    injector.create\nstd::shared_ptr\ninterface1\n();\n    // injector.create\nstd::unique_ptr\ninterface1\n(); // error, std::unique_ptr\ninterface1\n is not exposed\n  }\n\n  {\n    di::injector\nBOOST_DI_EXPOSE((named = name)std::shared_ptr\ninterface1\n), std::shared_ptr\ninterface1\n injector =\n        di::make_injector\ndi::extension::shared_config\n(\n        di::bind\ninterface1\n().to\nimplementation1\n().in(di::extension::shared).named(name)\n      , di::bind\ninterface1\n().to\nimplementation2\n().in(di::extension::shared).named(name)[di::override]\n      , di::bind\ninterface1\n().to\nimplementation1\n().in(di::extension::shared)\n    );\n\n    injector.create\nexample\n();\n  }\n\n  {\n    auto injector1 = di::make_injector\ndi::extension::shared_config\n(di::bind\ninterface1\n().to\nimplementation1\n().in(di::extension::shared));\n\n    auto i1 = injector1.create\nstd::shared_ptr\ninterface1\n();\n    auto injector2 = di::make_injector\ndi::extension::shared_config\n(std::move(injector1));\n    // check whether shared scope was successfully moved\n    assert(i1 == injector2.create\nstd::shared_ptr\ninterface1\n());\n  }\n\n  calls\nimplementation1, ctor\n() = 0;\n  calls\nimplementation1, dtor\n() = 0;\n  calls\nimplementation2, ctor\n() = 0;\n  calls\nimplementation2, dtor\n() = 0;\n  calls\nimplementation3, ctor\n() = 0;\n  calls\nimplementation3, dtor\n() = 0;\n  {\n    const auto injector = di::make_injector\ndi::extension::shared_config\n(\n       di::bind\nimplementation1\n().in(di::singleton)          /// explicit singleton scope\n     , di::bind\nimplementation2\n().in(di::extension::shared)  /// explicit shared scope\n     , di::bind\ninterface1\n().to\nimplementation3\n()           /// deduced shared scope\n    );\n\n    injector.create\nimplementation1\n();\n    injector.create\nimplementation2\n();\n    assert(dynamic_cast\ninterface1*\n(injector.create\nstd::shared_ptr\ninterface1\n().get()));\n\n    assert((calls\nimplementation1, ctor\n() == 2));\n    assert((calls\nimplementation1, dtor\n() == 1));\n\n    assert((calls\nimplementation2, ctor\n() == 2));\n    assert((calls\nimplementation2, dtor\n() == 1));\n\n    assert((calls\nimplementation3, ctor\n() == 1));\n    assert((calls\nimplementation3, dtor\n() == 0));\n\n  }  // injector dies\n  assert((calls\nimplementation1, ctor\n() == 2));\n  assert((calls\nimplementation1, dtor\n() == 1));  // not destroyed\n\n  assert((calls\nimplementation2, ctor\n() == 2));\n  assert((calls\nimplementation2, dtor\n() == 2));  // explicit scope destroyed with injector\n\n  assert((calls\nimplementation3, ctor\n() == 1));\n  assert((calls\nimplementation3, dtor\n() == 1));  // deduced scope destroyed with config/injector\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/shared.cpp", 
            "title": "Extensions"
        }, 
        {
            "location": "/extensions/index.html#injector", 
            "text": "#include  boost/di/extension/injector.hpp \n\n#include  cassert \n#include  memory \n\nnamespace di = boost::di;\n\nstruct i1 {\n  virtual ~i1() noexcept = default;\n  virtual int foo() const = 0;\n};\n\nstruct i2 {\n  virtual ~i2() noexcept = default;\n  virtual int bar() const = 0;\n};\n\nstruct impl2 : i2 {\n  int bar() const override { return 99; }\n};\n\nstruct impl1 : i1 {\n  explicit impl1(std::unique_ptr i2  sp2) { assert(sp2- bar() == 99); }\n  int foo() const override { return 42; }\n};\n\nstruct app {\n  explicit app(std::shared_ptr i1  sp1) { assert(sp1- foo() == 42); }\n};\n\nint main() {\n  namespace di = boost::di;\n\n  /* creates generic injector */\n  {\n    auto injector = di::make_injector(\n      di::bind i1 ().to impl1 (), /// missing binding -  compile error\n      di::bind i2 ().to impl2 ()\n    );\n    di::create app (injector);\n    di::create std::shared_ptr i1 (injector); /// okay\n  }\n\n  /* creates exposed injector */\n  {\n    di::extension::injector app  injector = di::make_injector(\n      di::bind i1 ().to impl1 (), /// missing binding -  compile error\n      di::bind i2 ().to impl2 ()\n    );\n    di::create app (injector);\n    //di::create std::shared_ptr i1 (injector); /// compile error, i1 is not exposed\n  }\n\n  /* creates runtime injector */\n  {\n    di::extension::injector  injector{};\n    injector.install(di::bind i1 ().to impl1 ()); /// missing binding -  runtime error (Error policy)\n    injector.install(di::bind i2 ().to impl2 ());\n\n    di::create app (injector);\n    di::create std::shared_ptr i1 (injector); /// okay\n  }\n\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injector.cpp", 
            "title": "Injector"
        }, 
        {
            "location": "/extensions/index.html#constructor-bindings", 
            "text": "#include  boost/di/extension/bindings/constructor_bindings.hpp \n\n#include  cassert \n#include  memory \n#include  string \n#include  tuple \n\nnamespace di = boost::di;\n\n\n/* normal constructor - to_constructor binding is not needed for it */\nstruct ctor {\n  ctor(int i, std::string s, std::unique_ptr interface  impl) {\n    assert(i == 2);\n    assert(s ==  hello );\n    assert(dynamic_cast implementation* (impl.get()));\n  }\n};\n\n/* ambiguous constructor */\nstruct ambiguous_ctor {\n  ambiguous_ctor(int i, std::string s) {\n    assert(i == 2);\n    assert(s ==  hello );\n  }\n\n  ambiguous_ctor(std::string s, int i) {\n    assert(s ==  hello );\n    assert(i == 2);\n  }\n};\n\n/* variadic constructor - has to be `explicit` */\nstruct variadic {\n  template  class... Ts \n  explicit variadic(Ts ... args) {  // has to be explicit\n    assert(sizeof...(Ts) == 3);\n    std::tuple Ts...  ts{std::forward Ts (args)...};\n    assert(std::get 0 (ts) == 2);\n    assert(std::get 1 (ts) ==  hello );\n    assert(dynamic_cast implementation* (std::get 2 (ts).get()));\n  }\n};\n\nint main() {\n  /* define constructor types */\n  auto injector = di::make_injector(\n      di::bind ctor ().to(di::extension::constructor int, std::string, std::unique_ptr interface ())\n    , di::bind ambiguous_ctor ().to(di::extension::constructor int, std::string ())\n    , di::bind variadic ().to(di::extension::constructor int, std::string, std::unique_ptr interface ())\n\n    /* additional bindings */\n    , di::bind interface ().to implementation ()\n    , di::bind int ().to(2), di::bind std::string ().to( hello )\n  );\n\n  /* create types using defined constructors */\n  injector.create ctor ();\n  injector.create ambiguous_ctor ();\n  injector.create variadic ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/bindings/constructor_bindings.cpp", 
            "title": "Constructor Bindings"
        }, 
        {
            "location": "/extensions/index.html#contextual-bindings", 
            "text": "#include  boost/di/extension/bindings/contextual_bindings.hpp \n\n#include  cassert \n\nnamespace di = boost::di;\n\nstruct more_data {\n  int i;\n};\n\nstruct data {\n  int i;\n  more_data md;\n};\n\nclass example {\n public:\n  example(data  d, int i, float f) {\n    assert(87 == d.i);\n    assert(99 == d.md.i);\n    assert(42 == i);\n    assert(123.f == f);\n  }\n};\n\nint main() {\n  auto injector = di::make_injector di::extension::contextual_bindings (\n      di::bind ().to(123.f)\n    , di::bind int ().to([](const auto  injector) {\n        if (di::extension::context(injector) ==  example- data ) return 87;\n        if (di::extension::context(injector) ==  example- data- more_data ) return 99;\n        return 42;\n      })\n  );\n\n  /* create `example` */\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/bindings/contextual_bindings.cpp", 
            "title": "Contextual Bindings"
        }, 
        {
            "location": "/extensions/index.html#assisted-injection", 
            "text": "#include  boost/di/extension/injections/assisted_injection.hpp \n\n#include  cassert \n#include  functional \n#include  memory \n#include  string \n\nnamespace di = boost::di;\n\n\nint main() {\n  /* assisted_injection declaration using std function */\n  using example_assisted_injection = std::function std::unique_ptr example (int, double, std::string) ;\n\n  auto injector = di::make_injector(\n      di::bind int ().to(87)\n    , di::bind interface ().to implementation ()\n      /* bind `example_assisted_injection` to assisted_injection creating `example` */\n    , di::bind example_assisted_injection ().to(di::extension::assisted_injection example ())\n  );\n\n  auto f = injector.create example_assisted_injection ();\n  f(42, 123.0,  str );\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/assisted_injection.cpp", 
            "title": "Assisted Injection"
        }, 
        {
            "location": "/extensions/index.html#extensible-injector", 
            "text": "#include  boost/di/extension/injections/extensible_injector.hpp \n\n#include  cassert \n#include  memory \n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual int num() = 0;\n};\n\nstruct any {\n  virtual ~any() noexcept = default;\n};\n\nstruct object : any {};\n\nstruct implementation1 : interface {\n  int num() override { return 1; }\n};\n\nstruct implementation2 : interface {\n  int num() override { return 2; }\n};\n\nstruct implementation3 : interface {\n  int num() override { return 3; }\n};\n\nstruct example {\n  example(std::unique_ptr interface  i, std::shared_ptr implementation3  im3) : i_(std::move(i)), im3_(im3) {}\n\n  std::shared_ptr interface  i_;\n  std::shared_ptr interface  im3_;\n};\n\nint main() {\n  // create instance object \n  auto im3_orig = std::make_shared implementation3 ();\n\n  // define injector \n  auto orig_injector = di::make_injector(\n      // bind interface to implementation1 \n      di::bind interface ().to implementation1 ().in(di::unique)\n\n      // bind any to object \n    , di::bind any ().to object ()\n\n      // overridden binding for any, object to object \n    , di::bind any, object ().to object ()[di::override]\n\n      // bind implementation3 to shared instance \n    , di::bind implementation3 ().to(im3_orig)\n  );\n\n  {\n    // define extended injector \n    auto extended_injector = di::make_injector(\n        // make extensible injector from original injector \n        di::extension::make_extensible(orig_injector)\n\n        // override bound interface to implementation2 \n      , di::bind interface ().to implementation2 ().in(di::unique)[di::override]\n    );\n\n    // both injectors live together \n    auto orig_example = orig_injector.create example ();\n    assert(1 == orig_example.i_- num());\n    assert(3 == orig_example.im3_- num());\n\n    auto extended_example = extended_injector.create example ();\n    assert(2 == extended_example.i_- num());\n    assert(3 == extended_example.im3_- num());\n\n    // both injectors share the same dependency \n    assert(extended_example.im3_ == orig_example.im3_);\n    assert(im3_orig == orig_example.im3_);\n\n    // injector supports multiple bindings \n    assert(orig_injector.create std::shared_ptr any () == orig_injector.create std::shared_ptr object ());\n  }\n  // after death of extended dependency original dependency is still alive \n  assert(im3_orig == orig_injector.create std::shared_ptr implementation3 ());\n\n  {\n    // make_extensible can be called with empty injector \n    auto empty_injector = di::make_injector();\n    auto empty_extended_injector = di::make_injector(di::extension::make_extensible(empty_injector));\n    auto instance = empty_extended_injector.create implementation1 ();\n    assert(1 == instance.num());\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/extensible_injector.cpp", 
            "title": "Extensible Injector"
        }, 
        {
            "location": "/extensions/index.html#concepts", 
            "text": "#include  boost/di/extension/injections/concepts.hpp \n\n#include  cassert \n\nnamespace di = boost::di;\n\ntemplate  typename T \nconcept bool Dummy() {\n  return requires(T a) { {a.dummy()}; };\n}\n\nstruct DummyImpl {\n  void dummy() {}\n};\n\nauto dummy_concept = [] {};\n\nstruct example {\n  BOOST_DI_INJECT(example, int i, auto t, (named = dummy_concept) Dummy d, (named = dummy_concept) std::unique_ptr Dummy  up) {\n    assert(42 == i);\n    static_assert(std::is_same decltype(t), int ::value,  );\n    assert(87 == t);\n    static_assert(std::is_same decltype(d), DummyImpl ::value,  );\n    static_assert(std::is_same decltype(up), std::unique_ptr DummyImpl ::value,  );\n  }\n};\n\nint main() {\n  auto injector = di::make_injector di::extension::concepts_provider_config (\n      di::bind int .to(42)\n    , di::bind di::_ .to(87)\n    , di::bind di::_ ().named(dummy_concept).to DummyImpl ()\n  );\n\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/concepts.cpp", 
            "title": "Concepts"
        }, 
        {
            "location": "/extensions/index.html#factory", 
            "text": "#include  boost/di/extension/injections/factory.hpp \n\n#include  cassert \n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy1() = 0;\n};\n\nstruct implementation : interface {\n  void dummy1() override {}\n};\n\nstruct implementation_exception : interface {\n#if defined(__EXCEPTIONS)\n  implementation_exception() { throw 0; }\n#endif\n  void dummy1() override {}\n};\n\nstruct implementation_with_args : interface {\n  implementation_with_args(int i, double d) {\n    assert(42 == i);\n    assert(87.0 == d);\n  }\n  void dummy1() override {}\n};\n\nstruct implementation_with_injected_args : interface {\n  implementation_with_injected_args(int i, double d) {\n    assert(123 == i);\n    assert(87.0 == d);\n  }\n  void dummy1() override {}\n};\n\n/* example `example` class */\nclass example {\n public:\n  example(const di::extension::ifactory interface  f1, const di::extension::ifactory interface, int, double  f2,\n          const di::extension::ifactory interface, double  f3) {\n    assert(dynamic_cast implementation* (f1.create().get()));\n    assert(dynamic_cast implementation_with_args* (f2.create(42, 87.0).get()));\n    assert(dynamic_cast implementation_with_injected_args* (f3.create(87.0).get()));\n  }\n};\n\nint main() {\n  // define injector \n  auto module = [] { return di::make_injector(di::bind ().to(123)); };\n\n  auto injector = di::make_injector(module()\n  //  bind instance just to make sure that factory doesn't affect injector \n  , di::bind interface ().to(std::make_shared implementation ())\n\n  //  bind instance which throws exception to make sure that exception doesn't affect injector \n  , di::bind di::extension::ifactory implementation_exception ().to(di::extension::factory implementation_exception {})\n\n  // bind factory interface to implementation \n  , di::bind di::extension::ifactory interface ().to(di::extension::factory implementation {})\n\n  // bind factory interface with parameters to implementation_with_args \n  , di::bind di::extension::ifactory interface, int, double ().to(di::extension::factory implementation_with_args {})\n\n  // bind factory interface with some parameters injected to implementation_with_injected_args \n  , di::bind di::extension::ifactory interface, double ().to(di::extension::factory implementation_with_injected_args {})\n  );\n\n  /* create `example` */\n  injector.create example ();\n\n/* create `implementation_exception` */\n#if defined(__EXCEPTIONS)\n  auto exception_thrown = false;\n  try {\n    injector.create const implementation_exception ();\n  } catch (...) {\n    exception_thrown = true;\n  }\n  assert(exception_thrown);\n#endif\n\n  // Check whether injector is affected by factory\n  assert(injector.create std::shared_ptr interface ());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/factory.cpp", 
            "title": "Factory"
        }, 
        {
            "location": "/extensions/index.html#shared-factory", 
            "text": "#include  boost/di/extension/injections/shared_factory.hpp \n\n#include  cassert \n\nnamespace di = boost::di;\nnamespace ext = di::extension;\n\nstruct interface1 {\n  virtual ~interface1() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct interface2 {\n  virtual ~interface2() noexcept = default;\n  virtual void dummy() = 0;\n};\n\nstruct implementation : interface1, interface2 {\n  static auto  ctor_calls() {\n    static auto calls = 0;\n    return calls;\n  }\n  static auto  dtor_calls() {\n    static auto calls = 0;\n    return calls;\n  }\n  implementation() { ctor_calls()++; }\n  ~implementation() { dtor_calls()++; }\n  void dummy() override {}\n};\n\nstruct implementation_exception : interface1 {\n#if defined(__EXCEPTIONS)\n  implementation_exception() { throw 0; }\n#endif\n  void dummy() override {}\n};\n\nint main() {\n  assert(!implementation::ctor_calls());\n  assert(!implementation::dtor_calls());\n\n  {\n    // define injector \n    auto injector = di::make_injector(\n      di::bind implementation_exception ().to(ext::shared_factory implementation_exception ([ ](const auto  inner_injector)\n      {\n        // throws an exception here \n        return inner_injector.template create std::shared_ptr implementation_exception ();\n      })),\n      // bind factory interface to implementation \n      di::bind interface1, implementation ().to(ext::shared_factory implementation, ext::no_recursion ([ ](const auto  inner_injector)\n      {\n        static int calls = 0;\n        assert(1 == ++calls);\n        // shouldn't be recursive call here \n        return inner_injector.template create std::shared_ptr implementation ();\n      })),\n      di::bind interface2 ().to(ext::conditional_shared_factory implementation ([ ]()\n      {\n        static int calls = 0;\n        assert(1 == ++calls);\n        return true;\n      }))\n    );\n\n    // create `implementation` via `shared_factory` \n    auto i1 = injector.create std::shared_ptr interface1 ();\n    auto i2 = injector.create std::shared_ptr implementation ();\n    assert(i1);\n    assert(i1 == i2);\n    assert(1 == implementation::ctor_calls());\n    assert(!implementation::dtor_calls());\n\n    // create `interface` via `conditional_shared_factory` \n    auto i3 = injector.create std::shared_ptr interface2 ();\n\n#if defined(__EXCEPTIONS)\n    auto exception_thrown = false;\n    try {\n      injector.create std::shared_ptr implementation_exception ();\n    } catch (...) {\n      exception_thrown = true;\n    }\n    assert(exception_thrown);\n#endif\n\n    auto i4 = injector.create std::shared_ptr interface2 ();\n    assert(i3);\n    assert(i3 == i4);\n    assert(1 == implementation::ctor_calls());\n    assert(!implementation::dtor_calls());\n  }\n  // Destroyed with injector \n  assert(1 == implementation::dtor_calls());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/shared_factory.cpp", 
            "title": "Shared Factory"
        }, 
        {
            "location": "/extensions/index.html#lazy", 
            "text": "#include  boost/di/extension/injections/lazy.hpp \n\n#include  cassert \n#include  memory \n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() noexcept = default;\n  virtual void dummy1() = 0;\n};\n\nstruct type_expensive_to_create : interface {\n  void dummy1() override {}\n};\n\n/* example `example` class */\nclass example {\n public:\n  explicit example(di::extension::lazy std::unique_ptr interface  l) : l(l) {}\n\n  void initialize() {\n    auto object = l.get();\n    assert(dynamic_cast type_expensive_to_create * (object.get()));\n  }\n\n private:\n  di::extension::lazy std::unique_ptr interface  l;\n};\n\nint main() {\n  /* define injector */\n  auto injector = di::make_injector(\n    di::bind interface ().to type_expensive_to_create ()\n  );\n\n  /* create `example` */\n  auto object = injector.create example ();\n  object.initialize();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/lazy.cpp", 
            "title": "Lazy"
        }, 
        {
            "location": "/extensions/index.html#named-parameters", 
            "text": "#include  boost/di/extension/injections/named_parameters.hpp \n\n#include  cassert \n#include  memory \n\nnamespace di = boost::di;\n\nstruct interface {\n  virtual ~interface() = default;\n  virtual void dummy() = 0;\n};\n\nstruct implementation : interface {\n  void dummy() override {}\n};\n\nstruct example {\n  /* inject constructor using automatic named parameters */\n  $inject(example, int i, std::unique_ptr interface  up, [[named( my_value )]] int value) {\n    assert(i == 42);\n    assert(dynamic_cast implementation* (up.get()));\n    assert(value == 87);\n  }\n};\n\nint main() {\n  using namespace di::extension;\n\n  /* bind named parameters */\n  auto injector = di::make_injector(\n      di::bind int .to(42)\n    , di::bind interface .to implementation ()\n    , di::bind int .named( my_value _s).to(87)\n  );\n\n  injector.create example ();\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/named_parameters.cpp", 
            "title": "Named Parameters"
        }, 
        {
            "location": "/extensions/index.html#xml-injection", 
            "text": "#include  boost/di/extension/injections/xml_injection.hpp \n\n#include  cassert \n#include  iostream \n\nnamespace di = boost::di;\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind di::extension::ixml_parser ().to xml_parser_stub ()\n  );\n};\n\nauto xml_module = [] {\n  return di::make_injector(\n    di::bind interface ().to(di::extension::xml implementation1, implementation2 ())\n  );\n};\n\nint main() {\n  /* make injector */\n  auto injector = di::make_injector(module(), xml_module());\n\n  /* create `interface` from xml configuration */\n  {\n    auto object = injector.create std::shared_ptr interface ();\n    assert(object.get());\n    assert(dynamic_cast implementation1* (object.get()));\n  }\n\n  /* create `interface` from different xml configuration */\n  {\n    auto object = injector.create std::shared_ptr interface ();\n    assert(object.get());\n    assert(dynamic_cast implementation2* (object.get()));\n  }\n\n  /* create `interface` from different xml configuration */\n  {\n    auto object = injector.create std::shared_ptr interface ();\n    assert(!object.get());\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/xml_injection.cpp", 
            "title": "XML Injection"
        }, 
        {
            "location": "/extensions/index.html#serialize", 
            "text": "#define BOOST_DI_DISABLE_SHARED_PTR_DEDUCTION\n#include  boost/di/extension/policies/serialize.hpp \n\n#include  cassert \n#include  iostream \n\nnamespace di = boost::di;\n\nstruct data {\n  unsigned int ui;\n  long l;\n  float f;\n};\n\nstruct even_more_data {\n  double d;\n  bool b;\n  long long ll;\n};\n\nstruct more_data {\n  int i;\n  long double ld;\n  even_more_data d;\n  short s;\n};\n\nstruct example {\n  example(data  d, more_data  md) : d(d), md(md) {}\n\n  void update() {\n    d.ui = 13;\n    d.l = 23l;\n    d.f = .33f;\n    md.i = 44;\n    md.ld = 42.0;\n    md.d.d = 55.0;\n    md.d.b = true;\n    md.d.ll = 66ll;\n    md.s = 77;\n  }\n\n  void reset() {\n    d.ui = {};\n    d.l = {};\n    d.f = {};\n    md.i = {};\n    md.ld = {};\n    md.d.d = {};\n    md.d.b = {};\n    md.d.ll = {};\n    md.s = {};\n  }\n\n  data  d;\n  more_data  md;\n};\n\nint main() {\n  auto injector = di::make_injector di::extension::serializable_policy (\n      di::bind ().to(42)\n  );\n\n  /* create `example` */\n  auto object = injector.create example ();\n  {\n    assert(0 == object.d.ui);\n    assert(0 == object.d.l);\n    assert(.0f == object.d.f);\n    assert(42 == object.md.i);  // bound\n    assert(0.0 == object.md.ld);\n    assert(0.0 == object.md.d.d);\n    assert(false == object.md.d.b);\n    assert(0 == object.md.d.ll);\n    assert(0 == object.md.s);\n  }\n\n  /* update internal data */\n  object.update();\n  {\n    assert(13 == object.d.ui);\n    assert(23 == object.d.l);\n    assert(.33f == object.d.f);\n    assert(44 == object.md.i);\n    assert(42.0 == object.md.ld);\n    assert(55.0 == object.md.d.d);\n    assert(true == object.md.d.b);\n    assert(66 == object.md.d.ll);\n    assert(77 == object.md.s);\n  }\n\n  /* serialize internal data to the stream */\n  std::stringstream str;\n  di::extension::serialize(injector, str);\n\n  /* reset internal data */\n  object.reset();\n\n  /* deserialize from the stream */\n  di::extension::deserialize(injector, str);\n  {\n    assert(13 == object.d.ui);\n    assert(23 == object.d.l);\n    assert(.33f == object.d.f);\n    assert(44 == object.md.i);\n    assert(42.0 == object.md.ld);\n    assert(55.0 == object.md.d.d);\n    assert(true == object.md.d.b);\n    assert(66 == object.md.d.ll);\n    assert(77 == object.md.s);\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/serialize.cpp", 
            "title": "Serialize"
        }, 
        {
            "location": "/extensions/index.html#types-dumper", 
            "text": "#include  boost/di/extension/policies/types_dumper.hpp \n\n#include  memory \n\nnamespace di = boost::di;\n\nauto int_1 = [] { return  first int ; };\nauto int_2 = [] { return  second int ; };\n\nstruct i0 {\n  virtual ~i0(){};\n};\nstruct c0 : i0 {};\nstruct c1 {\n  c1(std::shared_ptr i0 , int) {}\n};\nstruct c2 {\n  BOOST_DI_INJECT(c2, (named = int_1) int, (named = int_2) int, char) {}\n};\nstruct c3 {\n  c3(std::shared_ptr c1 , std::shared_ptr c2 ) {}\n};\n\nint main() {\n  /* define injector */\n  auto injector = di::make_injector di::extension::types_dumper (\n    di::bind i0 ().to c0 ()\n  , di::bind int ().named(int_1).to(42)\n  , di::bind int ().named(int_2).to(42)\n  );\n\n  /* iterate through created objects with `types_dumper` */\n  injector.create c3 ();\n\n  /*  output [pre\n      (2c3 -  2c3)\n          (St10shared_ptrI2c1E -  2c1)\n              (St10shared_ptrI2i0E -  2c0)\n              (i -  i)\n          (St10shared_ptrI2c2E -  2c2)\n              (i[first int] -  i)\n              (i[second int] -  i)\n              (c -  c)\n  ] */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/types_dumper.cpp", 
            "title": "Types Dumper"
        }, 
        {
            "location": "/extensions/index.html#uml-dumper", 
            "text": "#include  boost/di/extension/policies/uml_dumper.hpp \n\n#include  memory \n\nnamespace di = boost::di;\n\n\nint main() {\n  /* define injector */\n  auto injector = di::make_injector di::extension::uml_dumper (\n    di::bind i0 ().to c0 ()\n  , di::bind int ().named(int_1).to(42)\n  , di::bind int ().named(int_2).to(42)\n  );\n\n  /* iterate through created objects with `types_dumper` */\n  injector.create c3 ();\n\n  /* output [@images/uml_dumper.png [$images/uml_dumper.png [width 75%] [height 75%] ]] */\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/uml_dumper.cpp", 
            "title": "UML Dumper"
        }, 
        {
            "location": "/extensions/index.html#heap-provider", 
            "text": "#include  boost/di/extension/providers/heap.hpp \n\n#include  cassert \n#include  memory \n\nnamespace di = boost::di;\n\nclass new_call;\nclass del_call;\n\nstruct example {\n  template  class \n  static auto  calls() {\n    static auto i = 0;\n    return i;\n  }\n\n  void *operator new(size_t size) {\n    ++calls new_call ();\n    return ::operator new(size);\n  }\n\n  void operator delete(void *ptr) {\n    ++calls del_call ();\n    ::operator delete(ptr);\n  }\n};\n\nint main() {\n  struct heap_config : di::config {\n    auto provider(...) const noexcept { return di::extension::heap{}; }\n  };\n\n  auto injector = di::make_injector heap_config ();\n\n  assert(0 == example::calls new_call ());\n  assert(0 == example::calls del_call ());\n  injector.create example ();\n  assert(1 == example::calls new_call ());\n  assert(1 == example::calls del_call ());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/heap.cpp", 
            "title": "Heap Provider"
        }, 
        {
            "location": "/extensions/index.html#mocks-provider", 
            "text": "#include  boost/di/extension/providers/mocks_provider.hpp \n\n#include  cassert \n\nnamespace di = boost::di;\n\nstruct i1 {\n  virtual ~i1() noexcept = default;\n  virtual int get() = 0;\n};\n\nstruct i2 {\n  virtual ~i2() noexcept = default;\n  virtual int get() = 0;\n};\n\nstruct c {\n  c(std::shared_ptr i1  sp, std::unique_ptr i2  up, int i) {\n    assert(sp- get() == 42);\n    assert(up- get() == 123);\n    assert(i == 87);\n  }\n};\n\nint main() {\n  /* unit test */\n  {\n    /* create injector with `mocks_provider` */\n    auto mi = di::extension::mocks_injector();\n\n    /* set expectations */\n    expect(mi,  i1::get).will_return(42);\n    expect(mi,  i2::get).will_return(123);\n\n    /* create object to test with interfaces to be injected by di and int value passed directly to constructor */\n    c object{mi, mi, 87};\n  }\n\n  /* integration test */\n  {\n    struct impl1 : i1 {\n      int get() override { return 42; }\n    };\n\n    /* create injector with `mocks_provider` */\n      auto mi = di::extension::mocks_injector(\n        di::bind int ().to(87) // custom value\n      , di::bind i1 ().to impl1 () // original implementation\n      );\n\n    /* set expectations */\n    expect(mi,  i2::get).will_return(123);  // fake\n\n    /* create object to test with mocked `i1` and original `i2` and injected int value */\n    mi.create c ();\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/mocks_provider.cpp", 
            "title": "Mocks Provider"
        }, 
        {
            "location": "/extensions/index.html#runtime-provider", 
            "text": "#include  boost/di/extension/providers/runtime_provider.hpp \n\n#include  cassert \n#include  string \n\nnamespace di = boost::di;\n\nstruct i1 {\n  virtual ~i1() noexcept = default;\n  virtual int foo() const = 0;\n};\n\nstruct i2 {\n  virtual ~i2() noexcept = default;\n  virtual int bar() const = 0;\n};\n\nstruct i3 {\n  virtual ~i3() noexcept = default;\n  virtual int f() const = 0;\n};\n\nstruct i4 {\n  virtual ~i4() noexcept = default;\n  virtual int foo() const = 0;\n};\n\nstruct impl3 : i3 {\n  explicit impl3(const int  i) { assert(i == 87); }\n  int f() const override { return 1234; }\n};\n\nstruct impl2 : i2 {\n  explicit impl2(i3  i, std::string str) {\n    assert(i.f() == 1234);\n    assert(str ==  text );\n  }\n  int bar() const override { return 99; }\n};\n\nstruct impl1 : i1 {\n  explicit impl1(std::unique_ptr i2  sp2) { assert(sp2- bar() == 99); }\n  int foo() const override { return 42; }\n};\n\nclass ctor;\nclass dtor;\n\nstruct impl4 : i4 {\n  template  class \n  static auto  calls() {\n    static auto i = 0;\n    return i;\n  }\n\n  impl4() { ++calls ctor (); }\n  ~impl4() { ++calls dtor (); }\n\n  int foo() const override { return 100; }\n};\n\nclass module_example {\n public:\n  explicit module_example(std::shared_ptr i4  sp) : sp{sp} {}\n  auto get() const { return sp- foo() * 2; }\n\n private:\n  std::shared_ptr i4  sp{};\n};\n\nstruct example {\n  example(std::shared_ptr i1  sp, int i, module_example  me) {\n    assert(dynamic_cast impl1* (sp.get()));\n    assert(sp- foo() == 42);\n    assert(i == 87);\n    assert(me.get() == 2 * 100);\n  }\n};\n\nauto ct_module = [] { return di::make_injector(di::bind i4 ().to impl4 ()); };\ndi::extension::runtime_injector rt_module() { return di::make_injector(di::bind i4 ().to impl4 ()); }\n\nint main() {\n  namespace di = boost::di;\n\n  /* create runtime injector */\n  di::extension::runtime_injector injector{};\n\n  /* install bindings */\n  injector.install(\n    di::bind i1 ().to impl1 (),\n    di::bind i2 ().to impl2 ()\n  );\n\n  /* more bindings */\n  injector.install(di::bind int ().to(87));\n\n  /* injector bindings */\n  auto component = di::make_injector(\n    di::bind i3 ().to impl3 (),\n    di::bind std::string ().to( text )\n  );\n  injector.install(component);\n\n  /* module bindings */\n  injector.install(ct_module());\n\n  /* create example */\n  injector.create example ();\n\n  // scoped injector\n  {\n    impl4::calls ctor () = {};\n    impl4::calls dtor () = {};\n\n    di::extension::runtime_injector injector{};\n    injector.install(rt_module());\n    auto m = di::create module_example (injector);\n\n    assert(m.get() == 2 * 100);\n    assert(impl4::calls ctor () == 1);\n    assert(impl4::calls dtor () == 0);\n  }\n  assert(impl4::calls ctor () == 1);\n  assert(impl4::calls dtor () == 1);\n\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/runtime_provider.cpp", 
            "title": "Runtime Provider"
        }, 
        {
            "location": "/extensions/index.html#scoped-scope", 
            "text": "#include  boost/di/extension/scopes/scoped.hpp \n\n#include  cassert \n\nnamespace di = boost::di;\n\n\nauto module = [] {\n  return di::make_injector(\n    di::bind interface1 ().to implementation1 ()\n  );\n};\n\nint main() {\n  assert(!implementation1::ctor_calls());\n  assert(!implementation1::dtor_calls());\n  assert(!implementation2::ctor_calls());\n  assert(!implementation2::dtor_calls());\n\n  auto parent_injector = module();\n  /* create `interface1` using deduced singleton scope */\n  parent_injector.create interface1  ();\n  assert(1 == implementation1::ctor_calls());\n  {\n    /* create `child_injector` with `module` and binding using scoped singleton scope */\n    auto child_injector = di::make_injector(\n        module()\n      , di::bind interface2 ().to implementation2 ().in(di::extension::scoped)\n    );\n    child_injector.create interface2  ();\n    assert(1 == implementation2::ctor_calls());\n  }  // end of scoped\n  assert(1 == implementation2::dtor_calls());\n\n  /* create `interface1` again in singleton scope */\n  parent_injector.create interface1  ();\n  /* already created */\n  assert(1 == implementation1::ctor_calls());\n  /* `implementation1` will die with the app (static storage) */\n  assert(0 == implementation1::dtor_calls());\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/scoped.cpp", 
            "title": "Scoped Scope"
        }, 
        {
            "location": "/extensions/index.html#session-scope", 
            "text": "#include  boost/di/extension/scopes/session.hpp \n\n#include  cassert \n\nnamespace di = boost::di;\n\n\nauto my_session = [] {};\n\nint main() {\n  {\n    auto injector = di::make_injector(\n      di::bind interface1 ().to implementation1 ().in(di::extension::session(my_session))\n    );\n    assert(!injector.create std::shared_ptr interface1 ());\n\n    {\n      auto ms = di::extension::session(my_session)();\n      assert(injector.create std::shared_ptr interface1 ());\n    }  // end of my_session\n\n    assert(!injector.create std::shared_ptr interface1 ());\n  }\n\n  {\n    di::injector std::shared_ptr interface1  injector =\n      di::make_injector(\n        di::bind interface1 ().to implementation1 ().in(di::extension::session(my_session))\n      );\n    assert(!injector.create std::shared_ptr interface1 ());\n\n    {\n      auto ms = di::extension::session(my_session)();\n      assert(injector.create std::shared_ptr interface1 ());\n    }  // end of my_session\n\n    assert(!injector.create std::shared_ptr interface1 ());\n  }\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/session.cpp", 
            "title": "Session Scope"
        }, 
        {
            "location": "/extensions/index.html#shared-scope", 
            "text": "#include  boost/di/extension/scopes/shared.hpp \n\n#include  cassert \n\nnamespace di = boost::di;\n\n\nauto name = [] {};\n\nclass example {\n public:\n  BOOST_DI_INJECT(example, (named = name) std::shared_ptr interface1  sp1, (named = name) std::shared_ptr interface1  sp2,\n                  std::shared_ptr interface1  sp3) {\n    assert(sp1 == sp2);\n    assert(dynamic_cast implementation2* (sp1.get()));\n    assert(dynamic_cast implementation2* (sp2.get()));\n    assert(dynamic_cast implementation1* (sp3.get()));\n  }\n};\n\nint main() {\n  {\n    auto injector = di::make_injector di::extension::shared_config (\n      di::bind interface1 ().to implementation1 ().in(di::extension::shared)  // di::unique will fail (sp1 == sp2)\n    , di::bind interface1 ().to implementation2 ().named(name).in(di::extension::shared)\n    );\n    injector.create example ();\n  }\n\n  {\n    di::injector std::shared_ptr interface1  injector =\n      di::make_injector di::extension::shared_config (\n        di::bind interface1 ().to implementation1 ().in(di::extension::shared)\n    );\n\n    injector.create std::shared_ptr interface1 ();\n    // injector.create std::unique_ptr interface1 (); // error, std::unique_ptr interface1  is not exposed\n  }\n\n  {\n    di::injector BOOST_DI_EXPOSE((named = name)std::shared_ptr interface1 ), std::shared_ptr interface1  injector =\n        di::make_injector di::extension::shared_config (\n        di::bind interface1 ().to implementation1 ().in(di::extension::shared).named(name)\n      , di::bind interface1 ().to implementation2 ().in(di::extension::shared).named(name)[di::override]\n      , di::bind interface1 ().to implementation1 ().in(di::extension::shared)\n    );\n\n    injector.create example ();\n  }\n\n  {\n    auto injector1 = di::make_injector di::extension::shared_config (di::bind interface1 ().to implementation1 ().in(di::extension::shared));\n\n    auto i1 = injector1.create std::shared_ptr interface1 ();\n    auto injector2 = di::make_injector di::extension::shared_config (std::move(injector1));\n    // check whether shared scope was successfully moved\n    assert(i1 == injector2.create std::shared_ptr interface1 ());\n  }\n\n  calls implementation1, ctor () = 0;\n  calls implementation1, dtor () = 0;\n  calls implementation2, ctor () = 0;\n  calls implementation2, dtor () = 0;\n  calls implementation3, ctor () = 0;\n  calls implementation3, dtor () = 0;\n  {\n    const auto injector = di::make_injector di::extension::shared_config (\n       di::bind implementation1 ().in(di::singleton)          /// explicit singleton scope\n     , di::bind implementation2 ().in(di::extension::shared)  /// explicit shared scope\n     , di::bind interface1 ().to implementation3 ()           /// deduced shared scope\n    );\n\n    injector.create implementation1 ();\n    injector.create implementation2 ();\n    assert(dynamic_cast interface1* (injector.create std::shared_ptr interface1 ().get()));\n\n    assert((calls implementation1, ctor () == 2));\n    assert((calls implementation1, dtor () == 1));\n\n    assert((calls implementation2, ctor () == 2));\n    assert((calls implementation2, dtor () == 1));\n\n    assert((calls implementation3, ctor () == 1));\n    assert((calls implementation3, dtor () == 0));\n\n  }  // injector dies\n  assert((calls implementation1, ctor () == 2));\n  assert((calls implementation1, dtor () == 1));  // not destroyed\n\n  assert((calls implementation2, ctor () == 2));\n  assert((calls implementation2, dtor () == 2));  // explicit scope destroyed with injector\n\n  assert((calls implementation3, ctor () == 1));\n  assert((calls implementation3, dtor () == 1));  // deduced scope destroyed with config/injector\n}   https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/shared.cpp", 
            "title": "Shared Scope"
        }, 
        {
            "location": "/FAQ/index.html", 
            "text": "Dependency Inversion vs Dependency Injection\n\nIn principle Dependency Inversion might be implemented using DI or Service Locator (SL).\nThe latter is more like a 'God' object. It has a lot of benefits but, probably, the same\namount of cons such as that SL requires that SL will be the only constructor parameter for any class which can be created using it.\nDI, on the other hand, is less intrusive and easier to follow than SL.\n\n\n\n\n\n\n\n\n\n\nWhy C++14 is required for [Boost].DI?\n\nAt first [Boost].DI was implemented using C++03 standard with a switch to C++11 when available/possible.\nHowever, this approach, although was/is working just fine, was/is really slow to compile and hard to maintain too.\nMoreover, interface for \nmodules\n wasn't perfect due to missing return type deduction for functions in C++11.\nTherefore, I made a decision to reimplement the core using C++14 features which sped up compilation times dramatically\nand make the interface cleaner and easier to maintain. Nevertheless, effort was made to support the newest versions of\npopular C++ compilers including GCC/Clang and MSVC. If you are interested in C++03 version of the library, please, take\na look into \ncpp03\n branch. Please, also notice that this\nbranch is not maintained anymore.\n\n\n\n\n\n\n\n\n\n\nHow the constructor deduction works without reflection support in C++?\n\nPlease check out \ninjection\n design and http://boost-experimental.github.io/di/cppnow-2016/#/7/11.\n\n\n\n\n\n\n\n\n\n\nCan I inject templates/concepts?\n\nYes, concepts/templates can be injected.\n:w\n\n\n\n\ntemplate \nclass T = class Greater\n\nstruct example { \n  using type = T;\n};\n\nstruct hello {};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind\nclass Greater\n().to\nhello\n()\n  );\n\n  auto object = injector.create\nexample\n();\n  static_assert(std::is_same\nhello, decltype(object)::type\n{});\n}\n\n\n\n\n\n\n\n\n\n\nCan I use XML in order to set-up bindings configuration?\n\nYes, however, XML injection is not part of the [Boost].DI release.\nPlease, check out \nXML Extension\n.\n\n\n\n\n\n\n\n\n\n\nSince [Boost].DI has a compile time approach can I have dynamic bindings?\n\nYes, [Boost].DI supports dynamic bindings.\n\n\n\n\nauto use_gui_view = true/false;\n\nauto injector = di::make_injector(\n  di::bind\niview\n.to([\n](const auto\n injector) -\n iview\n {\n    if (use_gui_view)\n      return injector.template create\ngui_view\n();\n    else\n      return injector.template create\ntext_view\n();\n  })\n, di::bind\n.to(42) // renderer device\n);\n\n\n\n\nCheck out full example of \nDynamic Bindings\n.", 
            "title": "FAQ"
        }, 
        {
            "location": "/FAQ/index.html#dependency-inversion-vs-dependency-injection", 
            "text": "In principle Dependency Inversion might be implemented using DI or Service Locator (SL).\nThe latter is more like a 'God' object. It has a lot of benefits but, probably, the same\namount of cons such as that SL requires that SL will be the only constructor parameter for any class which can be created using it.\nDI, on the other hand, is less intrusive and easier to follow than SL.", 
            "title": "Dependency Inversion vs Dependency Injection"
        }, 
        {
            "location": "/FAQ/index.html#why-c14-is-required-for-boostdi", 
            "text": "At first [Boost].DI was implemented using C++03 standard with a switch to C++11 when available/possible.\nHowever, this approach, although was/is working just fine, was/is really slow to compile and hard to maintain too.\nMoreover, interface for  modules  wasn't perfect due to missing return type deduction for functions in C++11.\nTherefore, I made a decision to reimplement the core using C++14 features which sped up compilation times dramatically\nand make the interface cleaner and easier to maintain. Nevertheless, effort was made to support the newest versions of\npopular C++ compilers including GCC/Clang and MSVC. If you are interested in C++03 version of the library, please, take\na look into  cpp03  branch. Please, also notice that this\nbranch is not maintained anymore.", 
            "title": "Why C++14 is required for [Boost].DI?"
        }, 
        {
            "location": "/FAQ/index.html#how-the-constructor-deduction-works-without-reflection-support-in-c", 
            "text": "Please check out  injection  design and http://boost-experimental.github.io/di/cppnow-2016/#/7/11.", 
            "title": "How the constructor deduction works without reflection support in C++?"
        }, 
        {
            "location": "/FAQ/index.html#can-i-inject-templatesconcepts", 
            "text": "Yes, concepts/templates can be injected.\n:w   template  class T = class Greater \nstruct example { \n  using type = T;\n};\n\nstruct hello {};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind class Greater ().to hello ()\n  );\n\n  auto object = injector.create example ();\n  static_assert(std::is_same hello, decltype(object)::type {});\n}", 
            "title": "Can I inject templates/concepts?"
        }, 
        {
            "location": "/FAQ/index.html#can-i-use-xml-in-order-to-set-up-bindings-configuration", 
            "text": "Yes, however, XML injection is not part of the [Boost].DI release.\nPlease, check out  XML Extension .", 
            "title": "Can I use XML in order to set-up bindings configuration?"
        }, 
        {
            "location": "/FAQ/index.html#since-boostdi-has-a-compile-time-approach-can-i-have-dynamic-bindings", 
            "text": "Yes, [Boost].DI supports dynamic bindings.   auto use_gui_view = true/false;\n\nauto injector = di::make_injector(\n  di::bind iview .to([ ](const auto  injector) -  iview  {\n    if (use_gui_view)\n      return injector.template create gui_view ();\n    else\n      return injector.template create text_view ();\n  })\n, di::bind .to(42) // renderer device\n);  Check out full example of  Dynamic Bindings .", 
            "title": "Since [Boost].DI has a compile time approach can I have dynamic bindings?"
        }, 
        {
            "location": "/CHANGELOG/index.html", 
            "text": "1.1.0\n - 2019-01-07\n\n\n\n\nAdditions\n\n\nSupport for Clang-5.0/6.0/7.0\n\n\nSupport for GCC-7/8\n\n\nSupport for MSVC-2017 Preview\n\n\n\n\nCore\n\n\nIs Creatable\n\n\nBinding To Constructor\n\n\n\n\n\n\n\n\nExamples\n\n\nPolymorphism\n\n\nInheritance\n\n\nType Erasure\n\n\nVariant\n\n\nTemplates\n\n\nConcepts\n\n\n\n\n\n\n\n\nExtensions\n\n\nRuntime Provider\n\n\nInjector\n\n\n\n\n\n\n\n\n\n\n\n\nBug Fixes\n\n\nIssues\n\n\n\n\n\n\n\n\nContributions\n\n\nKanstantsin Chernik\n\n\nJaak Ristioja\n\n\nGregor Jasny\n\n\n\n\n\n\n\n\n1.0.2\n - 2018-01-04\n\n\n\n\nAdditions\n\n\nSupport for Clang-4.0\n\n\nSupport for GCC-7\n\n\nSupport for MSVC-2017\n\n\nFixed support for MSVC-2015 Update 3\n\n\n\n\nCore\n\n\nSupport for injecting templates/concepts\n\n\n\n\n\n\n\n\nExtensions\n\n\nExtensions are now available using header files\n\n\nExtensible Injector\n\n\nShared Factory\n\n\n\n\n\n\n\n\n\n\n\n\nBug Fixes\n\n\nImplementation class cannot be marked as \nfinal\n\n\nCreation with Factory doesn't allow to pass exceptions through\n\n\nBound policy doesn't work with multiple bindings\n\n\nProblems compiling with _GLIBCXX_DEBUG defined\n\n\nException in ctor not propagated\n\n\nUnable to compile with VS 2017 RC, VS 2015 works fine\n\n\nBroken under VS2015 Update 3\n\n\n\n\n\n\n\n\nContributions\n\n\nKanstantsin Chernik\n\n\n\n\n\n\n\n\n1.0.1\n - 2016-05-04\n\n\n\n\nBreaking Changes\n\n\nSimplified interface for policies\n\n\n\n\n\n\n\n\nAdditions\n\n\nSupport for Clang-3.9\n\n\nSupport for GCC-6\n\n\n\n\nExtensions\n\n\nContextual Bindings\n\n\nSerialize\n\n\n\n\n\n\n\n\n\n\n\n\nBug Fixes\n\n\nLink error if di.hpp is included in two cpp-files\n\n\nCreation of empty injector crashes on MSVC 2015, Update 1, x64, Debug\n\n\n\n\n\n\n\n\n1.0.0\n - 2016-02-22\n\n\n\n\nSupport for MSVC-2015+\n\n\nSupport for GCC-5+\n\n\nSupport for CMake 2.8+\n\n\nSupport for libc++, libstdc++\n\n\nSupport for Mac OS\n\n\n\n\n0.5.0\n - 2015-01-12\n\n\n\n\nC++14 version\n\n\nSupport for Clang3.4+\n\n\n\n\n0.1.0\n - 2014-08-15\n\n\n\n\nC++03/C++11 version\n\n\nSupport for Clang3.2+", 
            "title": "CHANGELOG"
        }, 
        {
            "location": "/CHANGELOG/index.html#110-2019-01-07", 
            "text": "Additions  Support for Clang-5.0/6.0/7.0  Support for GCC-7/8  Support for MSVC-2017 Preview   Core  Is Creatable  Binding To Constructor     Examples  Polymorphism  Inheritance  Type Erasure  Variant  Templates  Concepts     Extensions  Runtime Provider  Injector       Bug Fixes  Issues     Contributions  Kanstantsin Chernik  Jaak Ristioja  Gregor Jasny", 
            "title": "1.1.0 - 2019-01-07"
        }, 
        {
            "location": "/CHANGELOG/index.html#102-2018-01-04", 
            "text": "Additions  Support for Clang-4.0  Support for GCC-7  Support for MSVC-2017  Fixed support for MSVC-2015 Update 3   Core  Support for injecting templates/concepts     Extensions  Extensions are now available using header files  Extensible Injector  Shared Factory       Bug Fixes  Implementation class cannot be marked as  final  Creation with Factory doesn't allow to pass exceptions through  Bound policy doesn't work with multiple bindings  Problems compiling with _GLIBCXX_DEBUG defined  Exception in ctor not propagated  Unable to compile with VS 2017 RC, VS 2015 works fine  Broken under VS2015 Update 3     Contributions  Kanstantsin Chernik", 
            "title": "1.0.2 - 2018-01-04"
        }, 
        {
            "location": "/CHANGELOG/index.html#101-2016-05-04", 
            "text": "Breaking Changes  Simplified interface for policies     Additions  Support for Clang-3.9  Support for GCC-6   Extensions  Contextual Bindings  Serialize       Bug Fixes  Link error if di.hpp is included in two cpp-files  Creation of empty injector crashes on MSVC 2015, Update 1, x64, Debug", 
            "title": "1.0.1 - 2016-05-04"
        }, 
        {
            "location": "/CHANGELOG/index.html#100-2016-02-22", 
            "text": "Support for MSVC-2015+  Support for GCC-5+  Support for CMake 2.8+  Support for libc++, libstdc++  Support for Mac OS", 
            "title": "1.0.0 - 2016-02-22"
        }, 
        {
            "location": "/CHANGELOG/index.html#050-2015-01-12", 
            "text": "C++14 version  Support for Clang3.4+", 
            "title": "0.5.0 - 2015-01-12"
        }, 
        {
            "location": "/CHANGELOG/index.html#010-2014-08-15", 
            "text": "C++03/C++11 version  Support for Clang3.2+", 
            "title": "0.1.0 - 2014-08-15"
        }
    ]
}