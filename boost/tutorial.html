<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">



<title>Tutorial - [Boost].DI</title>

<link href="./css/boostbook.css" rel="stylesheet">
<link href="./css/github.css" rel="stylesheet">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<div width="100%">
<a href="http://www.boost.org/"><img alt="Boost C++ Libraries" width="277" height="86" src="./images/boost.png"></a>
</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  ><img src="./images/prev.png" alt="Prev"></a><a accesskey="u" href=""><img src="./images/up.png" alt="Up"></a><a accesskey="h" href=""><img src="./images/home.png" alt="Home"></a><a accesskey="n"  ><img src="./images/next.png" alt="Next"></a>
</div>

<div class="chapter">


<div class="toc">
<dl class="toc">

    
        <dt><span class="section"><a href="index.html">Introduction</a></span></dt>
    

    
        <dt><span class="section"><a href="overview.html">Overview</a></span></dt>
    

    
        <dt><span class="section"><a href="tutorial.html">Tutorial</a></span></dt>
    

    
        <dt><span class="section"><a href="try_it.html">Try It Online!</a></span></dt>
    

    
        <dt><span class="section"><a href="benchmarks.html">Benchmarks</a></span></dt>
    

    
        <dt><span class="section"><a href="user_guide.html">User Guide</a></span></dt>
    

    
        <dt><span class="section"><a href="examples.html">Examples</a></span></dt>
    

    
        <dt><span class="section"><a href="extensions.html">Extensions</a></span></dt>
    

    
        <dt><span class="section"><a href="FAQ.html">FAQ</a></span></dt>
    

    
        <dt><span class="section"><a href="CHANGELOG.html">CHANGELOG</a></span></dt>
    

</dl>
</div>



<div class="section">
<h3 id="0-pre-refactor-towards-di">0. [Pre] Refactor towards DI</h3>
<p>If you write a new application you can skip this step and go directly to <a href="#1-basic-create-objects-tree">step 1</a>.
However, if you have a lot code which is not using DI and you wonder what can it be refactored,
then you are in the right place.</p>
<p>Basically, there is a only one (big) step to get all benefits of Dependency Injection.
You have to separate creation logic from business logic, which means that your code
should be free of object creation inside other objects...</p>
<pre><code class="cpp">class controller {
public:
  controller(config c) 
    : model_(std::make_unique&lt;model&gt;(c))
  { }

  void run();

private:
  std::unique_ptr&lt;model&gt; model_;
};

int main() {
  controller controller_;
  controller_.run();
}
</code></pre>

<p>Instead, DI approach would look like that...</p>
<pre><code class="cpp">class controller {
public:
  explicit controller(model&amp; m) : model_(m) {}
  void run();

private:
  model&amp; model_;
};

int main() {
  model model_;
  controller controller_{model_};
  controller_.run();
}
</code></pre>

<p>So, what happened here? We just took the responsibility of creation <code>model</code> out from the <code>controller</code>. In other words,
we have split the creation logic and the business logic.</p>
<p>That's basically everything you have to remember in order to create applications using DI.
Nevertheless, please, be careful and don't 'carry out' your dependencies. What is meant by that,
is NOT to pass an object into constructor if it won't be stored (<a href="https://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a>).</p>
<pre><code class="cpp">class app {
public:
  explicit app(model&amp; m) : controller_(m) {} // BAD
  explicit app(controller&amp; c) : controller_(c) {} // GOOD

private:
  controller controller_;
};
class controller {
public:
  explicit controller(model&amp;);
};

int main() {
  model model_;
  app app_{model_};
}
</code></pre>

<p>Additionally, you can consider using <code>strong typedefs</code> which will make your constructor interface cleaner/stronger.</p>
<pre><code class="cpp">class button {
public:
  button(int, int); // weak constructor interface (cpp file has to checked in order to figure out the meaning of int's)
};
</code></pre>

<p><code>button</code> constructor is not clear because <code>int's</code> are ambiguous and both present just a number.
It can be seen more clearly in the following example.</p>
<pre><code class="cpp">button{10, 15}; // OK, but what's 10? what's 15? Can I swap them?
button{15, 10}; // Hmm, potenial missue of the constructor
</code></pre>

<p>A better approach would be to introduce a strong typedefs for both numbers
in order to avoid potential misuse of the constructor, especially when used by other/external teams.</p>
<pre><code class="cpp">struct width {
  int value;
  constexpr operator int() const { return value; }
};
struct height {
  int value;
  constexpr operator int() const { return value; }
};
class button {
public:
  button(width, height); // strong constructor interface
};
</code></pre>

<p>Right now, <code>button</code> constructor is much easier to follow (no need to check cpp file) because
it expresses the intention.</p>
<pre><code class="cpp">button{width{10}, height{15}}; // OK, declartive approach
button{height{10}, with{15}}; // Compile Error
button{10, 15}; // Compile Error
</code></pre>

<p>Similar mechanism is used by [Boost].DI to achieve <a href="user_guide.html#di_named">named</a> parameters which and it will be presented in this tutorial later on.</p>
<h3 id="1-basic-create-objects-tree">1. [Basic] Create objects tree</h3>
<p>Before we will get into creating objects tree, let's first create a 'dummy' example.
In order to do so, firstly, we have to include (one and only) <a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp">boost/di.hpp</a> header</p>
<pre><code class="sh">wget https://raw.githubusercontent.com/boost-experimental/di/cpp14/include/boost/di.hpp
</code></pre>

<p>and declare a convenient <code>di</code> namespace alias.</p>
<pre><code class="cpp">#include &lt;boost/di.hpp&gt;
namespace di = boost::di;
</code></pre>

<p>That is enough to try out <code>[Boost].DI</code>!</p>
<p>To have a first complete and working example we just have to add <code>main</code> function as usual.</p>
<pre><code class="cpp">int main() {}
</code></pre>

<p>and compile our code using compiler supporting C++14 standard (Clang-3.4/GCC-5/MSVC-2015).</p>
<pre><code>$CXX -std=c++14 example.cpp
</code></pre>

<p>Congrats, you are now ready to check out <code>[Boost].DI</code> features!</p>
<hr />
<p>Let's move on to creating objects tree. Applications, usually, consists of a number of objects
which have to be instantiated. For example, let's consider a simplified Model View Controller code...</p>
<p><a href="images/tutorial_create_objects_tree.png"><img alt="Create objects tree" src="images/tutorial_create_objects_tree.png" /></a></p>
<p>The usual approach to create <code>app</code> would be following...</p>
<pre><code class="cpp">renderer renderer_;
view view_{&quot;&quot;, renderer_};
model model_;
controller controller_{model_, view_};
user user_;
app app_{controller_, user_};
</code></pre>

<p>Which is alright for a really small applications. However, it's really tedious to maintain.
Just imagine, that we have to change something here. For instance, <code>view</code> may need a new object <code>window</code>
or, even worse, we refactored the code and dependencies order has changed - yea <strong>ORDER</strong> of above is important!
<strong>ANY</strong> change in these classes constructors require developer input to maintain above boilerplate code!
Not fun, not fun at all :(</p>
<p>Right now imagine that your maintain effort will be minimized almost to none. How does it sound?
Well, that might be simply achieved with <code>[Boost].DI</code>!</p>
<p>The same result might be achieved with [Boost].DI. All, non-ambiguous, dependencies will be automatically
resolved and injected properly. It doesn't matter how big the hierarchy will be and/or if the order of constructor parameters will be changed in the future.
We just have to create <a href="user_guide.html#di_make_injector">injector</a> using <a href="user_guide.html#make_injector">make_injector</a>, create the <code>app</code> and DI will take care of injecting proper types for us.</p>
<pre><code class="cpp">auto app_ = make_injector().create&lt;app&gt;(); // It will create an `app` on stack and call its copy constructor
</code></pre>

<p>How is that possible? [Boost].DI is able to figure out what parameters are required for the constructor of type T.
Also, [Boost].DI is able to do it recursively for all required types by the constructor T. Hence, NO information
about constructors parameters is required to be registered.</p>
<p>Moreover, changes in the constructor of created objects will be handled automatically, so in our case
when we add a <code>window</code> to <code>view</code> or change <code>view&amp;</code> to <code>std::shared_ptr&lt;view&gt;</code> required effort will be
exactly '0'. <code>[Boost].DI</code> will take care of everything for us!</p>
<table>
<thead>
<tr>
<th>Type <code>T</code></th>
<th>Is allowed?</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>T*</code></td>
<td>✔</td>
<td>Ownership transfer!</td>
</tr>
<tr>
<td><code>const T*</code></td>
<td>✔</td>
<td>Ownership transfer!</td>
</tr>
<tr>
<td><code>T&amp;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>const T&amp;</code></td>
<td>✔</td>
<td>Reference with <a href="user_guide.html#di_singleton">singleton</a> / Temporary with <a href="user_guide.html#di_unique">unique</a></td>
</tr>
<tr>
<td><code>T&amp;&amp;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::unique_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::shared_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>std::weak_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>boost_shared_ptr&lt;T&gt;</code></td>
<td>✔</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>Furthermore, there is no performance penalty for using <code>[Boost].DI</code> (see <a href="overview.html#performance">Performance</a>)!</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
[Boost].DI can <a href="user_guide.html#di_automatic">inject</a> dependencies using direct initialization <code>T(...)</code> or uniform initialization <code>T{...}</code> for aggregate types.
</span></p>
<p>And full example!
<img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_create_objects_tree.cpp" /></p>
<p>Check out also other examples. Please, notice that the diagram was also generated using <code>[Boost].DI</code> but we will get into that a bit later.</p>
<p><img alt="CPP(BTN)" src="Run_Hello_World_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/hello_world.cpp" />
<img alt="CPP(BTN)" src="Run_Automatic_Injection_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/automatic_injection.cpp" />
<img alt="CPP(BTN)" src="Run_UML_Dumper_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/uml_dumper.cpp" /></p>
<p><br /><hr /></p>
<h3 id="2-basic-first-steps-with-bindings">2. [Basic] First steps with bindings</h3>
<p>But objects tree is not everything. A lot of classes uses interfaces or required a value to be passed.
<code>[Boost].DI</code> solution for this are <a href="user_guide.html#bindings">bindings</a>.</p>
<p>For purpose of this tutorial, let's change <code>view</code> class into interface <code>iview</code> in order to support <code>text_view</code> and <code>gui_view</code>.</p>
<pre><code class="cpp">class iview {
public:
  virtual ~iview() noexcept = default;
  virtual void update() =0;
};

class gui_view: public iview {
public:
  gui_view(std::string title, const renderer&amp;) {}
  void update() override {}
};

class text_view: public iview {
public:
  void update() override {}
};
</code></pre>

<p>Please, notice that <code>text_view</code> doesn't require any constructor parameters, whilst <code>gui_view</code> does.</p>
<p>So, what will happen right now, when we try to create an <code>app</code>?</p>
<pre><code class="cpp">auto app = make_injector().create&lt;app&gt;();
</code></pre>

<p>COMPILE error! (See also: <a href="overview.html#error-messages">Error Messages</a>)</p>
<pre><code class="cpp">warning: 'create&lt;app&gt;' is deprecated: creatable constraint not satisfied
  injector.create&lt;app&gt;();
           ^
boost/di.hpp:870:2: error: 'boost::di::v1_0_0::concepts::abstract_type&lt;iview&gt;::is_not_bound::error'
  error(_ = &quot;type is not bound, did you forget to add: 'di::bind&lt;interface&gt;.to&lt;implementation&gt;()'?&quot;);
</code></pre>

<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
You can get more info about error by increasing <a href="overview.html#configuration">BOOST_DI_CFG_DIAGNOSTICS_LEVEL</a> [0-2] value (default=1).
</span></p>
<p>Ah, okay, we haven't bound <code>iview</code> which means that <code>BOOST.DI</code> can't figure out whether we want <code>text_view</code> or <code>gui_view</code>?
Well, it's really simple to fix it, we just follow suggestion provided.</p>
<pre><code class="cpp">const auto injector = di::make_injector(
  di::bind&lt;iview&gt;.to&lt;gui_view&gt;()
);
</code></pre>

<p>Let's try again. Yay! It's compiling.</p>
<p>But what about <code>render.device</code> value? So far, it was value initialized by default(=0).
What, if you we want to initialize it with a user defined value instead?
We've already seen how to bind interface to implementation.
The same approach might be used in order to bind a type to a value.</p>
<pre><code class="cpp">di::bind&lt;T&gt;.to(value) // bind type T to given value
</code></pre>

<p>Moving back to our <code>render.device</code>...</p>
<pre><code class="cpp">struct renderer {
  int device;
};
</code></pre>

<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
If you want change the default behaviour and be sure that all required dependencies are bound and not value initialized
take a look at <a href="user_guide.html#di_constructible">constructible</a> policy.
</span></p>
<pre><code class="cpp">const auto injector = di::make_injector(
  di::bind&lt;iview&gt;.to&lt;gui_view&gt;()
, di::bind&lt;int&gt;.to(42) // renderer.device | [Boost].DI can also deduce 'int' type for you -&gt; 'di::bind&lt;&gt;.to(42)'
);
</code></pre>

<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
[Boost].DI is a compile time beast which means that it guarantees that if your code compiles, all dependencies will be resolved
correctly. No runtime exceptions or runtime asserts, EVER!
</span></p>
<p>And full example!
<img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings.cpp" /></p>
<p>That's nice but I don't want to be using a dynamic (virtual) dispatch. What about concepts/templates?
Good news, <code>[Boost].DI</code> can inject concepts/templates too!</p>
<pre><code class="cpp">template &lt;class T = class Greater&gt;
struct example { 
  using type = T;
};

struct hello {};

int main() {
  const auto injector = di::make_injector(
    di::bind&lt;class Greater&gt;.to&lt;hello&gt;()
  );

  auto object = injector.create&lt;example&gt;();
  static_assert(std::is_same&lt;hello, decltype(object)::type&gt;{});
}
</code></pre>

<p>And full example!
<img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_template_bindings.cpp" /></p>
<p>Great, but my code is more dynamic than that! I mean that I want to choose <code>gui_view</code> or <code>text_view</code> at runtime.
<code>[Boost].DI</code> can handle that too!</p>
<pre><code class="cpp">auto use_gui_view = true/false;

const auto injector = di::make_injector(
  di::bind&lt;iview&gt;.to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
    if (use_gui_view)
      return injector.template create&lt;gui_view&amp;&gt;();
    else
      return injector.template create&lt;text_view&amp;&gt;();
  })
, di::bind&lt;&gt;.to(42) // renderer device
);
</code></pre>

<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
It is safe to throw exceptions from lambda. It will be passed through.
</span></p>
<p>Notice, that <a href="user_guide.html#di_make_injector">injector</a> was passed to lambda expression in order to create <code>gui_view</code> / <code>text_view</code>.
This way <code>[Boost].DI</code> can inject appropriate dependencies into chosen types. See <a href="user_guide.html#bindings">bindings</a> for more details.</p>
<p>And full example!
<img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_dynamic_bindings.cpp" /></p>
<p>Okay, so what about the input. We have <code>user</code>, however, in the real life, we will have more clients.
<code>[Boost].DI</code> allows multiple bindings to the same type for <code>array/vector/set</code>. Let's do it then!</p>
<pre><code class="cpp">class iclient {
 public:
   virtual ~iclient() noexcept = default;
   virtual void process() = 0;
};

class user : public iclient {
 public:
   void process() override {};
};

class timer : public iclient {
 public:
   void process() override {};
};

class app {
 public:
  app(controller&amp;, std::vector&lt;std::unique_ptr&lt;iclient&gt;&gt;);
};
</code></pre>

<p>And our bindings...</p>
<pre><code class="cpp">di::bind&lt;iclient*[]&gt;.to&lt;user, client&gt;()
</code></pre>

<p>And full example!
<img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_multiple_bindings.cpp" /></p>
<p>The last but not least, sometimes, it's really useful to override some bindings. For example, for testing purposes.
With <code>[Boost].DI</code> you can easily do that with <a href="user_guide.html#di_bind">override</a> specifier (Implemented using <code>operator[](override)</code>).</p>
<pre><code class="cpp">const auto injector = di::make_injector(
  di::bind&lt;int&gt;.to(42) // renderer device
, di::bind&lt;int&gt;.to(123) [di::override] // override renderer device
);
</code></pre>

<p>Without the <code>di::override</code> following compilation error will occur...</p>
<pre><code class="cpp">boost/di.hpp:281:3: error: static_assert failed &quot;constraint not satisfied&quot;
boost/di.hpp:2683:80: type&lt;int&gt;::is_bound_more_than_once
  inline auto make_injector(TDeps... args) noexcept
</code></pre>

<p>And full example!
<img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_first_steps_with_bindings_override.cpp" /></p>
<p>Check out also.</p>
<p><img alt="CPP(BTN)" src="Run_Bindings_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/bindings.cpp" />
<img alt="CPP(BTN)" src="Run_Forward_Bindings_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/fwd_bindings.cpp" />
<img alt="CPP(BTN)" src="Run_Dynamic_Bindings_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/dynamic_bindings.cpp" />
<img alt="CPP(BTN)" src="Run_Multiple_Bindings_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/multiple_bindings.cpp" />
<img alt="CPP(BTN)" src="Run_Constructor_Bindings_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/bindings/constructor_bindings.cpp" /></p>
<p><br /><br /><br /><hr /></p>
<h3 id="3-basic-decide-the-life-times">3. [Basic] Decide the life times</h3>
<p>So far so good but where are these objects stored?
Well, <code>[Boost].DI</code> supports <a href="user_guide.html#scopes">scopes</a> which are response for maintaining the life time of created objects.
By default there are 4 scopes</p>
<ul>
<li><a href="user_guide.html#di_deduce">deduce</a> scope (default)</li>
<li><a href="user_guide.html#di_instance">instance</a> scope (bind&lt;&gt;.to(value) where value is maintained by the user)</li>
<li><a href="user_guide.html#di_unique">unique</a> scope (one instance per request)</li>
<li><a href="user_guide.html#di_singleton">singleton</a> scope (shared instance)</li>
</ul>
<p>By default <a href="user_guide.html#di_deduce">deduce</a> scope is used which means that scope is deduced based on a constructor parameter.
For instance, reference, shared_ptr will be deduced as <a href="user_guide.html#di_singleton">singleton</a> scope and pointer, unique_ptr will be deduced as <a href="user_guide.html#di_unique">unique</a> scope.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Scope</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td><a href="user_guide.html#di_unique">unique</a></td>
</tr>
<tr>
<td>T&amp;</td>
<td><a href="user_guide.html#di_singleton">singleton</a></td>
</tr>
<tr>
<td>const T&amp;</td>
<td><a href="user_guide.html#di_unique">unique</a> (temporary) / <a href="user_guide.html#di_singleton">singleton</a></td>
</tr>
<tr>
<td>T*</td>
<td><a href="user_guide.html#di_unique">unique</a> (ownership transfer)</td>
</tr>
<tr>
<td>const T*</td>
<td><a href="user_guide.html#di_unique">unique</a> (ownership transfer)</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td><a href="user_guide.html#di_unique">unique</a></td>
</tr>
<tr>
<td>std::unique_ptr<T></td>
<td><a href="user_guide.html#di_unique">unique</a></td>
</tr>
<tr>
<td>std::shared_ptr<T></td>
<td><a href="user_guide.html#di_singleton">singleton</a></td>
</tr>
<tr>
<td>boost::shared_ptr<T></td>
<td><a href="user_guide.html#di_singleton">singleton</a></td>
</tr>
<tr>
<td>std::weak_ptr<T></td>
<td><a href="user_guide.html#di_singleton">singleton</a></td>
</tr>
</tbody>
</table>
<p>Example</p>
<pre><code class="cpp">class scopes_deduction {
  scopes_deduction(const int&amp; /*singleton scope*/,
                   std::shared_ptr&lt;int&gt; /*singleton scope*/,
                   std::unique_ptr&lt;int&gt; /*unique scope*/,
                   int /*unique scope*/)
  { }
};

di::make_injector().create&lt;example&gt;(); // scopes will be deduced based on constructor parameter types
</code></pre>

<p>Coming back to our example, we got quite a few <code>singletons</code> there as we just needed one instance per application life time.
Although scope deduction is very useful, it's not always what we need and therefore <code>[Boost].DI</code> allows changing the scope for a given type.</p>
<pre><code class="cpp">const auto injector = di::make_injector(
  di::bind&lt;iview&gt;.to&lt;gui_view&gt;().in(di::singleton) // explicitly specify singleton scope
);
</code></pre>

<p>What if I want to change <code>gui_view</code> to be a different instance per each request. Let's change the scope to <a href="user_guide.html#di_unique">unique</a> then.</p>
<pre><code class="cpp">const auto injector = di::make_injector(
  di::bind&lt;iview&gt;.to&lt;gui_view&gt;().in(di::unique)
);
</code></pre>

<p>We will get a COMPILATION TIME ERROR because a unique scope can't be converted to a reference.
In other words, having a reference to a copy is forbidden and it won't compile!</p>
<pre><code class="cpp">warning: 'create&lt;app&gt;' is deprecated: creatable constraint not satisfied
  injector.create&lt;app&gt;();
           ^
boost/di.hpp:897:2: error: 'scoped&lt;scopes::unique, gui_view&gt;::is_not_convertible_to&lt;iview &amp;&gt;::error'
  error(_ = &quot;scoped object is not convertible to the requested type, did you mistake the scope: 'di::bind&lt;T&gt;.in(scope)'?&quot;);
</code></pre>

<p>Ah, reference doesn't make much sense with <a href="user_guide.html#di_unique">unique</a> scope because it would mean that it has to be stored somewhere.
It would be better to use <code>std::unique_ptr&lt;iview&gt;</code> instead.</p>
<table>
<thead>
<tr>
<th>Type/Scope</th>
<th><a href="user_guide.html#di_unique">unique</a></th>
<th><a href="user_guide.html#di_singleton">singleton</a></th>
<th><a href="user_guide.html#di_instance">instance</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>✔</td>
<td>-</td>
<td>✔</td>
</tr>
<tr>
<td>T&amp;</td>
<td>-</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>const T&amp;</td>
<td>✔ (temporary)</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>T* (transfer ownership)</td>
<td>✔</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>const T*</td>
<td>✔</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>✔</td>
<td>-</td>
<td>✔</td>
</tr>
<tr>
<td>std::unique_ptr<T></td>
<td>✔</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>std::shared_ptr<T></td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>boost::shared_ptr<T></td>
<td>✔</td>
<td>✔</td>
<td>- / ✔ converted to</td>
</tr>
<tr>
<td>std::weak_ptr<T></td>
<td>-</td>
<td>✔</td>
<td>- / ✔ converted to</td>
</tr>
</tbody>
</table>
<p>Hmm, let's try something else then. We have list of unique clients, we can share objects just by changing the list to
use <code>std::shared_ptr</code> instead.</p>
<pre><code class="cpp">class app {
 public:
  app(controller&amp;, std::vector&lt;std::shared_ptr&lt;iclient&gt;&gt;);
};
</code></pre>

<p>But, it would be better if <code>timer</code> was always created per request, although it's a <code>shared_ptr</code>.
To do so, we just need add scope when binding it, like this...</p>
<pre><code class="cpp">const auto injector = di::make_injector(
  di::bind&lt;timer&gt;.in(di::unique) // different per request
);
</code></pre>

<p>Check out the full example here.
<img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_decide_the_life_times.cpp" /></p>
<p>See also.</p>
<p><img alt="CPP(BTN)" src="Run_Deduce_Scope_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/deduce_scope.cpp" />
<img alt="CPP(BTN)" src="Run_Scopes_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/scopes.cpp" />
<img alt="CPP(BTN)" src="Run_Eager_Singletons_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/eager_singletons.cpp" /></p>
<p><br /><br /><hr /></p>
<h3 id="4-basic-annotations-to-the-rescue">4. [Basic] Annotations to the rescue</h3>
<p>Above example are fine and dandy, nonetheless, they don't cover one important thing.
How <code>[Boost].DI</code> knows which constructor to choose and what if they are ambiguous?</p>
<p>Well, the algorithm is very simple. The longest (most parameters), unique constructor will be chosen.
Otherwise, <code>[Boost].DI</code> will give up with a compile time error. However, which constructor should
be chosen is configurable by <a href="user_guide.html#BOOST_DI_INJECT">BOOST_DI_INJECT</a>.</p>
<p>To illustrate this, let's modify <code>model</code> constructor.</p>
<pre><code class="cpp">class model {
 public:
   model(int size, double precision) { }
   model(int rows, int cols) { }
};
</code></pre>

<p>Right now, as expected, we get a compile time error!</p>
<pre><code class="cpp">warning: 'create&lt;app&gt;' is deprecated: creatable constraint not satisfied
  injector.create&lt;app&gt;();
           ^
boost/di.hpp:942:4: error: 'type&lt;model&gt;::has_ambiguous_number_of_constructor_parameters::error'
  error(_ = &quot;verify BOOST_DI_INJECT_TRAITS or di::ctor_traits&quot;);
</code></pre>

<p>Let's fix it using <a href="user_guide.html#BOOST_DI_INJECT">BOOST_DI_INJECT</a> then!</p>
<pre><code class="cpp">class model {
 public:
   model(int size, double precision) { }
   BOOST_DI_INJECT(model, int rows, int cols) { } // this constructor will be injected
};
</code></pre>

<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
We can also write <code>model(int rows, int cols, ...)</code> to get the same result.
By adding <code>...</code> as the last parameter of the constructor it's guaranteed by [Boost].DI
that it will be used for injection as it will have the highest number of constructor parameters (infinite number).
</span></p>
<p>Okay, right now it compiles but, wait a minute, <code>123</code> (renderer device) was injected for both <code>rows</code> and <code>cols</code>!
Well, it wasn't even close to what we wanted, but we can fix it easily using <a href="user_guide.html#di_named">named</a> annotations.</p>
<p>Firstly, we have to create names. That's easy as names are just unique objects.</p>
<pre><code class="cpp">auto Rows = []{};
auto Cols = []{};
</code></pre>

<p>Secondly, we have to tell <code>model</code> constructor about it.</p>
<pre><code class="cpp">class model {
 public:
   model(int size, double precision) { }
   BOOST_DI_INJECT(model, (named = Rows) int rows, (named = Cols) int cols); // this constructor will be injected
};

model::model(int rows, int cols) {}
</code></pre>

<p>Please, notice that we have separated <code>model</code> constructor definition and declaration to show that definition doesn't
require named annotations.</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
If you happen to use clang/gcc compiler you can use string literals instead of creating objects,
for example <code>(named = "Rows"_s)</code>.
</span></p>
<p>Finally, we have to bind our values.</p>
<pre><code class="cpp">const auto injector = di::make_injector(
  di::bind&lt;int&gt;.named(Rows).to(6)
, di::bind&lt;int&gt;.named(Cols).to(8)
);
</code></pre>

<p>That's all.</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
The same result might be accomplished with having different types for rows and cols.
</span></p>
<p>Full example here.
<img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_annotations_to_the_rescue.cpp" /></p>
<p>Check out also...</p>
<p><img alt="CPP(BTN)" src="Run_Constructor_Injection_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_injection.cpp" />
<img alt="CPP(BTN)" src="Run_Constructor_Signature_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/constructor_signature.cpp" />
<img alt="CPP(BTN)" src="Run_Annotations_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/annotations.cpp" /></p>
<p><br /><br /><hr /></p>
<h3 id="5-basic-split-your-configuration">5. [Basic] Split your configuration</h3>
<p>But my project has hundreds of interfaces and I would like to split my bindings into separate components.
This is simple to do with [Boost.DI] as an <a href="user_guide.html#di_make_injector">injector</a> can be extended by other injectors.</p>
<p>Let's split our configuration then and keep our <code>model</code> bindings separately from <code>app</code> bindings.</p>
<pre><code class="cpp">auto model_module = [] {
  return di::make_injector(
    di::bind&lt;int&gt;.named(Rows).to(6)
  , di::bind&lt;int&gt;.named(Cols).to(8)
  );
};

auto app_module = [](const bool&amp; use_gui_view) {
  return di::make_injector(
    di::bind&lt;iview&gt;.to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
      if (use_gui_view)
        return injector.template create&lt;gui_view&amp;&gt;();
      else
        return injector.template create&lt;text_view&amp;&gt;();
    })
  , di::bind&lt;timer&gt;.in(di::unique) // different per request
  , di::bind&lt;iclient*[]&gt;().to&lt;user, timer&gt;() // bind many clients
  );
};
</code></pre>

<p>And glue them into one injector the same way...</p>
<pre><code class="cpp">  const auto injector = di::make_injector(
    model_module()
  , app_module(use_gui_view)
  );
</code></pre>

<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
Gluing many <a href="user_guide.html#di_make_injector">injector</a>s into one is order independent.
</span></p>
<p>And full example!
<img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration.cpp" /></p>
<p>But I would like to have a module in <code>cpp</code> file, how can I do that?
Such design might be achieved with <code>[Boost].DI</code> using <a href="user_guide.html#di_make_injector">injector</a> and exposing given types.</p>
<ul>
<li>Expose all types (default)</li>
</ul>
<pre><code class="cpp">const const auto injector = // auto exposes all types
  di::make_injector(
    di::bind&lt;int&gt;.to(42)
  , di::bind&lt;double&gt;.to(87.0)
  );

injector.create&lt;int&gt;(); OK
injector.create&lt;double&gt;(); // OK
</code></pre>

<ul>
<li>Expose only specific types</li>
</ul>
<pre><code class="cpp">const di::injector&lt;int&gt; injector = // only int is exposed
  di::make_injector(
    di::bind&lt;int&gt;.to(42)
  , di::bind&lt;double&gt;.to(87.0)
  );

injector.create&lt;int&gt;(); OK
injector.create&lt;double&gt;(); // COMPILE TIME ERROR, double is not exposed by the injector
</code></pre>

<p>When exposing all types using <code>auto</code> modules have to be implemented in a header file.
With <code>di::injector&lt;T...&gt;</code> a definition might be put in a cpp file as it’s just a regular type.</p>
<p>Such approach has a few benefits:
* It’s useful for encapsulation (ex. Another team provides a module but they don't want to expose an ability to create implementation details)
* May also speed compilation times in case of extend usage of cpp files</p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
There is no performance (compile-time, run-time) overhead between exposing all types or just a specific ones.
</span></p>
<p>Moving back to our example. Let's refactor it then.</p>
<pre><code class="cpp">di::injector&lt;model&amp;&gt; model_module() {
  return di::make_injector(
    di::bind&lt;int&gt;.named(Rows).to(6)
  , di::bind&lt;int&gt;.named(Cols).to(8)
  );
}

di::injector&lt;app&gt; app_module(const bool&amp; use_gui_view) {
  return di::make_injector(
    di::bind&lt;iview&gt;.to([&amp;](const auto&amp; injector) -&gt; iview&amp; {
      if (use_gui_view)
        return injector.template create&lt;gui_view&amp;&gt;();
      else
        return injector.template create&lt;text_view&amp;&gt;();
    })
  , di::bind&lt;timer&gt;.in(di::unique) // different per request
  , di::bind&lt;iclient*[]&gt;.to&lt;user, timer&gt;() // bind many clients
  , model_module()
  );
}
</code></pre>

<p>Right now you can easily separate definition and declaration between <code>hpp</code> and <code>cpp</code> files.</p>
<p>Check the full example here!
<img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/tutorial/basic_split_your_configuration_expose.cpp" /></p>
<p><span class="fa fa-eye wy-text-neutral warning"> <strong>Note</strong><br/><br/>
You can also expose named parameters using <code>di::injector&lt;BOOST_DI_EXPOSE((named = Rows) int)&gt;</code>.
Different variations of the same type have to be exposed explicitly using <code>di::injector&lt;model&amp;, std::unique_ptr&lt;model&gt;&gt;</code>.
Type erasure is used under the hood when types are exposed explicitly (<code>di::injector&lt;T…&gt;</code>).</p>
<p>Check out more examples here!</p>
<p><img alt="CPP(BTN)" src="Run_Modules_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/modules.cpp" />
<img alt="CPP(BTN)" src="Run_Exposed_Annotated_Type_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/module_exposed_annotated_type.cpp" />
<img alt="CPP(BTN)" src="Run_Exposed_Complex_Types_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/module_exposed_complex_types.cpp" /></p>
<p><br /><br /></p>
<p>Congrats! You have finished the basic part of the tutorial.
Hopefully, you have noticed potential of DI and <code>[Boost].DI</code> but if are still not convinced check out the <a href="#6-advanced-dumplimit-your-types">Advanced</a> part.</p>
<h3 id="6-advanced-dumplimit-your-types">6. [Advanced] Dump/Limit your types</h3>
<p>It's often a case that we would like to generate object diagram of our application in order to see code dependencies
more clear. Usually, it's a really hard task as creation of objects may happen anywhere in the code. However,
if the responsibility for creation  objects will be given to <code>[Boost].DI</code> we get such functionality for free.
The only thing we have to do is to implement how to dump our objects.</p>
<p>Let's dump our dependencies using <a href="http://plantuml.com">Plant UML</a> format.</p>
<p><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/uml_dumper.cpp" />
<a href="images/uml_dumper.png"><img alt="UML Dumper" src="images/uml_dumper.png" /></a></p>
<p>See also.  <br /><br />
<img alt="CPP(BTN)" src="Run_Custom_Policy_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp" />
<img alt="CPP(BTN)" src="Run_Types_Dumper_Extension|https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/types_dumper.cpp" /></p>
<p><br /></p>
<p>On the other hand, it would be great to be able to limit types which might be constructed. For example, we just want to allow
smart pointers and disallow raw pointers too. We may want to have a <code>view</code> only with const parameters being passed, etc.
<code>[Boost].DI</code> allows you to do so by using <a href="user_guide.html#di_constructible">constructible</a> policy or writing a custom <a href="user_guide.html#policies">policy</a>.</p>
<p><img alt="CPP" src="https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_global.cpp" /></p>
<p>See also.</p>
<p><img alt="CPP(BTN)" src="Run_Constructible_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/user_guide/policies_constructible_local.cpp" /></p>
<p><br /><hr /></p>
<h3 id="7-advanced-customize-it">7. [Advanced] Customize it</h3>
<p><code>[Boost].DI</code> was design having extensibility in mind. You can easily customize</p>
<ul>
<li><a href="user_guide.html#scopes">scopes</a> - to have custom life time of an object</li>
<li><a href="user_guide.html#providers">providers</a> - to have custom way of creating objects, for example by using preallocated memory</li>
<li><a href="user_guide.html#policies">policies</a> - to have custom way of dumping types at run-time or limiting them at compile-time</li>
</ul>
<p><img alt="CPP(BTN)" src="Run_Custom_Policy_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_policy.cpp" />
<img alt="CPP(BTN)" src="Run_Custom_Provider_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/custom_provider.cpp" />
<img alt="CPP(BTN)" src="Run_Pool_Provider_Example|https://raw.githubusercontent.com/boost-experimental/di/cpp14/example/pool_provider.cpp" /></p>
<p><br /><hr /></p>
<h3 id="8-advanced-extend-it">8. [Advanced] Extend it</h3>
<p>As mentioned before, <code>[Boost].DI</code> is quite easy to extend and therefore a lot of extensions exists already.
Please check them out and write your own!</p>
<ul>
<li><a href="extensions.html#constructor-bindings">Constructor Bindings</a></li>
<li><a href="extensions.html#assisted-injection">Assisted Injection</a></li>
<li><a href="extensions.html#concepts">Concepts</a></li>
<li><a href="extensions.html#lazy">Lazy</a></li>
<li><a href="extensions.html#named-parameters">Named Parameters</a></li>
<li><a href="extensions.html#xml-injection">XML Injection</a></li>
<li><a href="extensions.html#types-dumper">Types Dumper</a></li>
<li><a href="extensions.html#uml-dumper">UML Dumper</a></li>
<li><a href="extensions.html#mocks-provider">Mocks Provider</a></li>
<li><a href="extensions.html#scoped-scope">Scoped Scope</a></li>
<li><a href="extensions.html#session-scope">Session Scope</a></li>
<li><a href="extensions.html#shared-scope">Shared Scope</a></li>
</ul>
</div>

<script src="./js/highlight.pack.js"></script>

<script>
hljs.configure({languages:['cpp']});
hljs.initHighlightingOnLoad();
</script>
<script src="search/main.js"></script>

<div class="copyright-footer">
      <p>Distributed under the Boost Software License, Version 1.0.
      (See accompanying file <code class="filename">LICENSE_1_0.txt</code> or copy at
      <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>

</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  ><img src="./images/prev.png" alt="Prev"></a><a accesskey="u" href=""><img src="./images/up.png" alt="Up"></a><a accesskey="h" href=""><img src="./images/home.png" alt="Home"></a><a accesskey="n"  ><img src="./images/next.png" alt="Next"></a>
</div>

<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<select onChange="window.location.href=this.value" style="position: absolute; top: 20px; right: 30px; z-index: 10;">
    <option value="https://boost-experimental.github.io/di">Theme: Boost Experimental</option>
    <option value="https://boost-experimental.github.io/di/boost" selected>Theme: Boost Classic</option>
</select>
</body>
</html>